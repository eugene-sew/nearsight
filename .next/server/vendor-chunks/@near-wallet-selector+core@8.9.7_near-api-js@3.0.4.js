"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-wallet-selector+core@8.9.7_near-api-js@3.0.4";
exports.ids = ["vendor-chunks/@near-wallet-selector+core@8.9.7_near-api-js@3.0.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@near-wallet-selector+core@8.9.7_near-api-js@3.0.4/node_modules/@near-wallet-selector/core/index.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-wallet-selector+core@8.9.7_near-api-js@3.0.4/node_modules/@near-wallet-selector/core/index.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* binding */ EventEmitter),\n/* harmony export */   allowOnlyLanguage: () => (/* binding */ allowOnlyLanguage),\n/* harmony export */   getActiveAccount: () => (/* binding */ getActiveAccount),\n/* harmony export */   isCurrentBrowserSupported: () => (/* binding */ isCurrentBrowserSupported),\n/* harmony export */   serializeNep413: () => (/* binding */ serializeNep413),\n/* harmony export */   setupWalletSelector: () => (/* binding */ setupWalletSelector),\n/* harmony export */   translate: () => (/* binding */ translate),\n/* harmony export */   verifyFullKeyBelongsToUser: () => (/* binding */ verifyFullKeyBelongsToUser),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature),\n/* harmony export */   waitFor: () => (/* binding */ waitFor)\n/* harmony export */ });\n/* harmony import */ var near_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! near-api-js */ \"(ssr)/./node_modules/.pnpm/near-api-js@3.0.4/node_modules/near-api-js/lib/index.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! rxjs */ \"(ssr)/./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/scan.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js\");\n/* harmony import */ var js_sha256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! js-sha256 */ \"(ssr)/./node_modules/.pnpm/js-sha256@0.9.0/node_modules/js-sha256/src/sha256.js\");\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass Provider {\n  constructor(url) {\n    this.provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n      url\n    });\n  }\n  query(params) {\n    return this.provider.query(params);\n  }\n  viewAccessKey({\n    accountId,\n    publicKey\n  }) {\n    return this.query({\n      request_type: \"view_access_key\",\n      finality: \"final\",\n      account_id: accountId,\n      public_key: publicKey\n    });\n  }\n  block(reference) {\n    return this.provider.block(reference);\n  }\n  sendTransaction(signedTransaction) {\n    return this.provider.sendTransaction(signedTransaction);\n  }\n}\n\nconst KEY_DELIMITER = \":\";\nclass JsonStorage {\n  constructor(storage, namespace) {\n    this.storage = storage;\n    this.namespace = Array.isArray(namespace) ? namespace.join(KEY_DELIMITER) : namespace;\n  }\n  resolveKey(key) {\n    return [this.namespace, key].join(KEY_DELIMITER);\n  }\n  getItem(key) {\n    return this.storage.getItem(this.resolveKey(key)).then(item => {\n      return typeof item === \"string\" ? JSON.parse(item) : null;\n    });\n  }\n  setItem(key, value) {\n    return this.storage.setItem(this.resolveKey(key), JSON.stringify(value));\n  }\n  removeItem(key) {\n    return this.storage.removeItem(this.resolveKey(key));\n  }\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$t =\n  // eslint-disable-next-line es-x/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$s = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$r = fails$s;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$r(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n\nvar fails$q = fails$s;\n\nvar functionBindNative = !fails$q(function () {\n  // eslint-disable-next-line es-x/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar call$l = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$3 ? call$l.bind(call$l) : function () {\n  return call$l.apply(call$l, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$2 && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$2(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar FunctionPrototype$2 = Function.prototype;\nvar bind$7 = FunctionPrototype$2.bind;\nvar call$k = FunctionPrototype$2.call;\nvar uncurryThis$p = NATIVE_BIND$2 && bind$7.bind(call$k, call$k);\n\nvar functionUncurryThis = NATIVE_BIND$2 ? function (fn) {\n  return fn && uncurryThis$p(fn);\n} : function (fn) {\n  return fn && function () {\n    return call$k.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$o = functionUncurryThis;\n\nvar toString$7 = uncurryThis$o({}.toString);\nvar stringSlice$3 = uncurryThis$o(''.slice);\n\nvar classofRaw$1 = function (it) {\n  return stringSlice$3(toString$7(it), 8, -1);\n};\n\nvar uncurryThis$n = functionUncurryThis;\nvar fails$p = fails$s;\nvar classof$b = classofRaw$1;\n\nvar $Object$4 = Object;\nvar split = uncurryThis$n(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$p(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$4('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$b(it) == 'String' ? split(it, '') : $Object$4(it);\n} : $Object$4;\n\nvar $TypeError$f = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$6 = function (it) {\n  if (it == undefined) throw $TypeError$f(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$5 = requireObjectCoercible$6;\n\nvar toIndexedObject$6 = function (it) {\n  return IndexedObject$3(requireObjectCoercible$5(it));\n};\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$n = function (argument) {\n  return typeof argument == 'function';\n};\n\nvar isCallable$m = isCallable$n;\n\nvar isObject$d = function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$m(it);\n};\n\nvar global$s = global$t;\nvar isCallable$l = isCallable$n;\n\nvar aFunction = function (argument) {\n  return isCallable$l(argument) ? argument : undefined;\n};\n\nvar getBuiltIn$8 = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(global$s[namespace]) : global$s[namespace] && global$s[namespace][method];\n};\n\nvar uncurryThis$m = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$m({}.isPrototypeOf);\n\nvar getBuiltIn$7 = getBuiltIn$8;\n\nvar engineUserAgent = getBuiltIn$7('navigator', 'userAgent') || '';\n\nvar global$r = global$t;\nvar userAgent$5 = engineUserAgent;\n\nvar process$3 = global$r.process;\nvar Deno$1 = global$r.Deno;\nvar versions = process$3 && process$3.versions || Deno$1 && Deno$1.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$5) {\n  match = userAgent$5.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$5.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar V8_VERSION$1 = engineV8Version;\nvar fails$o = fails$s;\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- required for testing\nvar nativeSymbol = !!Object.getOwnPropertySymbols && !fails$o(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$1 && V8_VERSION$1 < 41;\n});\n\n/* eslint-disable es-x/no-symbol -- required for testing */\n\nvar NATIVE_SYMBOL$1 = nativeSymbol;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$1\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$6 = getBuiltIn$8;\nvar isCallable$k = isCallable$n;\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$3 = Object;\n\nvar isSymbol$3 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$6('Symbol');\n  return isCallable$k($Symbol) && isPrototypeOf$4($Symbol.prototype, $Object$3(it));\n};\n\nvar $String$3 = String;\n\nvar tryToString$5 = function (argument) {\n  try {\n    return $String$3(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$j = isCallable$n;\nvar tryToString$4 = tryToString$5;\n\nvar $TypeError$e = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$9 = function (argument) {\n  if (isCallable$j(argument)) return argument;\n  throw $TypeError$e(tryToString$4(argument) + ' is not a function');\n};\n\nvar aCallable$8 = aCallable$9;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$4 = function (V, P) {\n  var func = V[P];\n  return func == null ? undefined : aCallable$8(func);\n};\n\nvar call$j = functionCall;\nvar isCallable$i = isCallable$n;\nvar isObject$c = isObject$d;\n\nvar $TypeError$d = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  if (isCallable$i(fn = input.valueOf) && !isObject$c(val = call$j(fn, input))) return val;\n  if (pref !== 'string' && isCallable$i(fn = input.toString) && !isObject$c(val = call$j(fn, input))) return val;\n  throw $TypeError$d(\"Can't convert object to primitive value\");\n};\n\nvar shared$4 = {exports: {}};\n\nvar global$q = global$t;\n\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$7 = Object.defineProperty;\n\nvar defineGlobalProperty$3 = function (key, value) {\n  try {\n    defineProperty$7(global$q, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$q[key] = value;\n  } return value;\n};\n\nvar global$p = global$t;\nvar defineGlobalProperty$2 = defineGlobalProperty$3;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$p[SHARED] || defineGlobalProperty$2(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$4.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.23.3',\n  mode: 'global',\n  copyright: 'Â© 2014-2022 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar requireObjectCoercible$4 = requireObjectCoercible$6;\n\nvar $Object$2 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$7 = function (argument) {\n  return $Object$2(requireObjectCoercible$4(argument));\n};\n\nvar uncurryThis$l = functionUncurryThis;\nvar toObject$6 = toObject$7;\n\nvar hasOwnProperty = uncurryThis$l({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es-x/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$6(it), key);\n};\n\nvar uncurryThis$k = functionUncurryThis;\n\nvar id = 0;\nvar postfix = Math.random();\nvar toString$6 = uncurryThis$k(1.0.toString);\n\nvar uid$3 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$6(++id + postfix, 36);\n};\n\nvar global$o = global$t;\nvar shared$3 = shared$4.exports;\nvar hasOwn$b = hasOwnProperty_1;\nvar uid$2 = uid$3;\nvar NATIVE_SYMBOL = nativeSymbol;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar WellKnownSymbolsStore = shared$3('wks');\nvar Symbol$1 = global$o.Symbol;\nvar symbolFor = Symbol$1 && Symbol$1['for'];\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;\n\nvar wellKnownSymbol$j = function (name) {\n  if (!hasOwn$b(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    var description = 'Symbol.' + name;\n    if (NATIVE_SYMBOL && hasOwn$b(Symbol$1, name)) {\n      WellKnownSymbolsStore[name] = Symbol$1[name];\n    } else if (USE_SYMBOL_AS_UID && symbolFor) {\n      WellKnownSymbolsStore[name] = symbolFor(description);\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n\nvar call$i = functionCall;\nvar isObject$b = isObject$d;\nvar isSymbol$2 = isSymbol$3;\nvar getMethod$3 = getMethod$4;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$i = wellKnownSymbol$j;\n\nvar $TypeError$c = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$i('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$2 = function (input, pref) {\n  if (!isObject$b(input) || isSymbol$2(input)) return input;\n  var exoticToPrim = getMethod$3(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$i(exoticToPrim, input, pref);\n    if (!isObject$b(result) || isSymbol$2(result)) return result;\n    throw $TypeError$c(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive$1 = toPrimitive$2;\nvar isSymbol$1 = isSymbol$3;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$4 = function (argument) {\n  var key = toPrimitive$1(argument, 'string');\n  return isSymbol$1(key) ? key : key + '';\n};\n\nvar global$n = global$t;\nvar isObject$a = isObject$d;\n\nvar document$3 = global$n.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$a(document$3) && isObject$a(document$3.createElement);\n\nvar documentCreateElement$2 = function (it) {\n  return EXISTS$1 ? document$3.createElement(it) : {};\n};\n\nvar DESCRIPTORS$d = descriptors;\nvar fails$n = fails$s;\nvar createElement$1 = documentCreateElement$2;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$d && !fails$n(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement$1('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n\nvar DESCRIPTORS$c = descriptors;\nvar call$h = functionCall;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$5 = toIndexedObject$6;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$a = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$c ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$5(O);\n  P = toPropertyKey$3(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$1(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$a(O, P)) return createPropertyDescriptor$4(!call$h(propertyIsEnumerableModule$1.f, O, P), O[P]);\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$b = descriptors;\nvar fails$m = fails$s;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$b && fails$m(function () {\n  // eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype != 42;\n});\n\nvar isObject$9 = isObject$d;\n\nvar $String$2 = String;\nvar $TypeError$b = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$e = function (argument) {\n  if (isObject$9(argument)) return argument;\n  throw $TypeError$b($String$2(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$a = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$d = anObject$e;\nvar toPropertyKey$2 = toPropertyKey$4;\n\nvar $TypeError$a = TypeError;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$a ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject$d(O);\n  P = toPropertyKey$2(P);\n  anObject$d(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw $TypeError$a('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$9 = descriptors;\nvar definePropertyModule$6 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$8 = DESCRIPTORS$9 ? function (object, key, value) {\n  return definePropertyModule$6.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar makeBuiltIn$2 = {exports: {}};\n\nvar DESCRIPTORS$8 = descriptors;\nvar hasOwn$9 = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$8 && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$9(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$8 || (DESCRIPTORS$8 && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$h = isCallable$n;\nvar store$1 = sharedStore;\n\nvar functionToString = uncurryThis$j(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$h(store$1.inspectSource)) {\n  store$1.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$4 = store$1.inspectSource;\n\nvar global$m = global$t;\nvar isCallable$g = isCallable$n;\nvar inspectSource$3 = inspectSource$4;\n\nvar WeakMap$1 = global$m.WeakMap;\n\nvar nativeWeakMap = isCallable$g(WeakMap$1) && /native code/.test(inspectSource$3(WeakMap$1));\n\nvar shared$2 = shared$4.exports;\nvar uid$1 = uid$3;\n\nvar keys$1 = shared$2('keys');\n\nvar sharedKey$3 = function (key) {\n  return keys$1[key] || (keys$1[key] = uid$1(key));\n};\n\nvar hiddenKeys$4 = {};\n\nvar NATIVE_WEAK_MAP = nativeWeakMap;\nvar global$l = global$t;\nvar uncurryThis$i = functionUncurryThis;\nvar isObject$8 = isObject$d;\nvar createNonEnumerableProperty$7 = createNonEnumerableProperty$8;\nvar hasOwn$8 = hasOwnProperty_1;\nvar shared$1 = sharedStore;\nvar sharedKey$2 = sharedKey$3;\nvar hiddenKeys$3 = hiddenKeys$4;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$3 = global$l.TypeError;\nvar WeakMap = global$l.WeakMap;\nvar set$2, get$1, has;\n\nvar enforce = function (it) {\n  return has(it) ? get$1(it) : set$2(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$8(it) || (state = get$1(it)).type !== TYPE) {\n      throw TypeError$3('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared$1.state) {\n  var store = shared$1.state || (shared$1.state = new WeakMap());\n  var wmget = uncurryThis$i(store.get);\n  var wmhas = uncurryThis$i(store.has);\n  var wmset = uncurryThis$i(store.set);\n  set$2 = function (it, metadata) {\n    if (wmhas(store, it)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset(store, it, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return wmget(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas(store, it);\n  };\n} else {\n  var STATE = sharedKey$2('state');\n  hiddenKeys$3[STATE] = true;\n  set$2 = function (it, metadata) {\n    if (hasOwn$8(it, STATE)) throw new TypeError$3(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$7(it, STATE, metadata);\n    return metadata;\n  };\n  get$1 = function (it) {\n    return hasOwn$8(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$8(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$2,\n  get: get$1,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar fails$l = fails$s;\nvar isCallable$f = isCallable$n;\nvar hasOwn$7 = hasOwnProperty_1;\nvar DESCRIPTORS$7 = descriptors;\nvar CONFIGURABLE_FUNCTION_NAME$2 = functionName.CONFIGURABLE;\nvar inspectSource$2 = inspectSource$4;\nvar InternalStateModule$5 = internalState;\n\nvar enforceInternalState$2 = InternalStateModule$5.enforce;\nvar getInternalState$5 = InternalStateModule$5.get;\n// eslint-disable-next-line es-x/no-object-defineproperty -- safe\nvar defineProperty$6 = Object.defineProperty;\n\nvar CONFIGURABLE_LENGTH = DESCRIPTORS$7 && !fails$l(function () {\n  return defineProperty$6(function () { /* empty */ }, 'length', { value: 8 }).length !== 8;\n});\n\nvar TEMPLATE = String(String).split('String');\n\nvar makeBuiltIn$1 = makeBuiltIn$2.exports = function (value, name, options) {\n  if (String(name).slice(0, 7) === 'Symbol(') {\n    name = '[' + String(name).replace(/^Symbol\\(([^)]*)\\)/, '$1') + ']';\n  }\n  if (options && options.getter) name = 'get ' + name;\n  if (options && options.setter) name = 'set ' + name;\n  if (!hasOwn$7(value, 'name') || (CONFIGURABLE_FUNCTION_NAME$2 && value.name !== name)) {\n    if (DESCRIPTORS$7) defineProperty$6(value, 'name', { value: name, configurable: true });\n    else value.name = name;\n  }\n  if (CONFIGURABLE_LENGTH && options && hasOwn$7(options, 'arity') && value.length !== options.arity) {\n    defineProperty$6(value, 'length', { value: options.arity });\n  }\n  try {\n    if (options && hasOwn$7(options, 'constructor') && options.constructor) {\n      if (DESCRIPTORS$7) defineProperty$6(value, 'prototype', { writable: false });\n    // in V8 ~ Chrome 53, prototypes of some methods, like `Array.prototype.values`, are non-writable\n    } else if (value.prototype) value.prototype = undefined;\n  } catch (error) { /* empty */ }\n  var state = enforceInternalState$2(value);\n  if (!hasOwn$7(state, 'source')) {\n    state.source = TEMPLATE.join(typeof name == 'string' ? name : '');\n  } return value;\n};\n\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n// eslint-disable-next-line no-extend-native -- required\nFunction.prototype.toString = makeBuiltIn$1(function toString() {\n  return isCallable$f(this) && getInternalState$5(this).source || inspectSource$2(this);\n}, 'toString');\n\nvar isCallable$e = isCallable$n;\nvar definePropertyModule$5 = objectDefineProperty;\nvar makeBuiltIn = makeBuiltIn$2.exports;\nvar defineGlobalProperty$1 = defineGlobalProperty$3;\n\nvar defineBuiltIn$8 = function (O, key, value, options) {\n  if (!options) options = {};\n  var simple = options.enumerable;\n  var name = options.name !== undefined ? options.name : key;\n  if (isCallable$e(value)) makeBuiltIn(value, name, options);\n  if (options.global) {\n    if (simple) O[key] = value;\n    else defineGlobalProperty$1(key, value);\n  } else {\n    try {\n      if (!options.unsafe) delete O[key];\n      else if (O[key]) simple = true;\n    } catch (error) { /* empty */ }\n    if (simple) O[key] = value;\n    else definePropertyModule$5.f(O, key, {\n      value: value,\n      enumerable: false,\n      configurable: !options.nonConfigurable,\n      writable: !options.nonWritable\n    });\n  } return O;\n};\n\nvar objectGetOwnPropertyNames = {};\n\nvar ceil = Math.ceil;\nvar floor$3 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es-x/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$3 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$6 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$5 = toIntegerOrInfinity$6;\n\nvar max$1 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$4 = function (index, length) {\n  var integer = toIntegerOrInfinity$5(index);\n  return integer < 0 ? max$1(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$4 = toIntegerOrInfinity$6;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$6 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$4(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength$5 = toLength$6;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$8 = function (obj) {\n  return toLength$5(obj.length);\n};\n\nvar toIndexedObject$4 = toIndexedObject$6;\nvar toAbsoluteIndex$3 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$8;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$4 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$4($this);\n    var length = lengthOfArrayLike$7(O);\n    var index = toAbsoluteIndex$3(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$4(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$4(false)\n};\n\nvar uncurryThis$h = functionUncurryThis;\nvar hasOwn$6 = hasOwnProperty_1;\nvar toIndexedObject$3 = toIndexedObject$6;\nvar indexOf$1 = arrayIncludes.indexOf;\nvar hiddenKeys$2 = hiddenKeys$4;\n\nvar push$2 = uncurryThis$h([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$3(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$6(hiddenKeys$2, key) && hasOwn$6(O, key) && push$2(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$6(O, key = names[i++])) {\n    ~indexOf$1(result, key) || push$2(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\nvar hiddenKeys$1 = enumBugKeys$2.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es-x/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys$1(O, hiddenKeys$1);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es-x/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar getBuiltIn$5 = getBuiltIn$8;\nvar uncurryThis$g = functionUncurryThis;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar anObject$c = anObject$e;\n\nvar concat$1 = uncurryThis$g([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$1 = getBuiltIn$5('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject$c(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n  return getOwnPropertySymbols ? concat$1(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar hasOwn$5 = hasOwnProperty_1;\nvar ownKeys = ownKeys$1;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule$4 = objectDefineProperty;\n\nvar copyConstructorProperties$1 = function (target, source, exceptions) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule$4.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!hasOwn$5(target, key) && !(exceptions && hasOwn$5(exceptions, key))) {\n      defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n    }\n  }\n};\n\nvar fails$k = fails$s;\nvar isCallable$d = isCallable$n;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$2 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : isCallable$d(detection) ? fails$k(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$2.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$2.data = {};\nvar NATIVE = isForced$2.NATIVE = 'N';\nvar POLYFILL = isForced$2.POLYFILL = 'P';\n\nvar isForced_1 = isForced$2;\n\nvar global$k = global$t;\nvar getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;\nvar createNonEnumerableProperty$6 = createNonEnumerableProperty$8;\nvar defineBuiltIn$7 = defineBuiltIn$8;\nvar defineGlobalProperty = defineGlobalProperty$3;\nvar copyConstructorProperties = copyConstructorProperties$1;\nvar isForced$1 = isForced_1;\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global$k;\n  } else if (STATIC) {\n    target = global$k[TARGET] || defineGlobalProperty(TARGET, {});\n  } else {\n    target = (global$k[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$1(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty == typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$6(sourceProperty, 'sham', true);\n    }\n    defineBuiltIn$7(target, key, sourceProperty, options);\n  }\n};\n\nvar classof$a = classofRaw$1;\nvar global$j = global$t;\n\nvar engineIsNode = classof$a(global$j.process) == 'process';\n\nvar isCallable$c = isCallable$n;\n\nvar $String$1 = String;\nvar $TypeError$9 = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$c(argument)) return argument;\n  throw $TypeError$9(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\n\nvar uncurryThis$f = functionUncurryThis;\nvar anObject$b = anObject$e;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es-x/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es-x/no-object-getownpropertydescriptor -- safe\n    setter = uncurryThis$f(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set);\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$b(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar defineProperty$5 = objectDefineProperty.f;\nvar hasOwn$4 = hasOwnProperty_1;\nvar wellKnownSymbol$h = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$4 = wellKnownSymbol$h('toStringTag');\n\nvar setToStringTag$4 = function (target, TAG, STATIC) {\n  if (target && !STATIC) target = target.prototype;\n  if (target && !hasOwn$4(target, TO_STRING_TAG$4)) {\n    defineProperty$5(target, TO_STRING_TAG$4, { configurable: true, value: TAG });\n  }\n};\n\nvar getBuiltIn$4 = getBuiltIn$8;\nvar definePropertyModule$3 = objectDefineProperty;\nvar wellKnownSymbol$g = wellKnownSymbol$j;\nvar DESCRIPTORS$6 = descriptors;\n\nvar SPECIES$4 = wellKnownSymbol$g('species');\n\nvar setSpecies$2 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$4(CONSTRUCTOR_NAME);\n  var defineProperty = definePropertyModule$3.f;\n\n  if (DESCRIPTORS$6 && Constructor && !Constructor[SPECIES$4]) {\n    defineProperty(Constructor, SPECIES$4, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar isPrototypeOf$3 = objectIsPrototypeOf;\n\nvar $TypeError$8 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$3(Prototype, it)) return it;\n  throw $TypeError$8('Incorrect invocation');\n};\n\nvar wellKnownSymbol$f = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$f('toStringTag');\nvar test = {};\n\ntest[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar isCallable$b = isCallable$n;\nvar classofRaw = classofRaw$1;\nvar wellKnownSymbol$e = wellKnownSymbol$j;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$e('toStringTag');\nvar $Object$1 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$9 = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$1(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) == 'Object' && isCallable$b(O.callee) ? 'Arguments' : result;\n};\n\nvar uncurryThis$e = functionUncurryThis;\nvar fails$j = fails$s;\nvar isCallable$a = isCallable$n;\nvar classof$8 = classof$9;\nvar getBuiltIn$3 = getBuiltIn$8;\nvar inspectSource$1 = inspectSource$4;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct = getBuiltIn$3('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$e(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  try {\n    construct(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$a(argument)) return false;\n  switch (classof$8(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource$1(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$2 = !construct || fails$j(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar isConstructor$1 = isConstructor$2;\nvar tryToString$3 = tryToString$5;\n\nvar $TypeError$7 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$2 = function (argument) {\n  if (isConstructor$1(argument)) return argument;\n  throw $TypeError$7(tryToString$3(argument) + ' is not a constructor');\n};\n\nvar anObject$a = anObject$e;\nvar aConstructor$1 = aConstructor$2;\nvar wellKnownSymbol$d = wellKnownSymbol$j;\n\nvar SPECIES$3 = wellKnownSymbol$d('species');\n\n// `SpeciesConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-speciesconstructor\nvar speciesConstructor$3 = function (O, defaultConstructor) {\n  var C = anObject$a(O).constructor;\n  var S;\n  return C === undefined || (S = anObject$a(C)[SPECIES$3]) == undefined ? defaultConstructor : aConstructor$1(S);\n};\n\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar FunctionPrototype = Function.prototype;\nvar apply$3 = FunctionPrototype.apply;\nvar call$g = FunctionPrototype.call;\n\n// eslint-disable-next-line es-x/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$1 ? call$g.bind(apply$3) : function () {\n  return call$g.apply(apply$3, arguments);\n});\n\nvar uncurryThis$d = functionUncurryThis;\nvar aCallable$7 = aCallable$9;\nvar NATIVE_BIND = functionBindNative;\n\nvar bind$6 = uncurryThis$d(uncurryThis$d.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$7(fn);\n  return that === undefined ? fn : NATIVE_BIND ? bind$6(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar getBuiltIn$2 = getBuiltIn$8;\n\nvar html$2 = getBuiltIn$2('document', 'documentElement');\n\nvar uncurryThis$c = functionUncurryThis;\n\nvar arraySlice$5 = uncurryThis$c([].slice);\n\nvar $TypeError$6 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw $TypeError$6('Not enough arguments');\n  return passed;\n};\n\nvar userAgent$4 = engineUserAgent;\n\nvar engineIsIos = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent$4);\n\nvar global$i = global$t;\nvar apply$2 = functionApply;\nvar bind$5 = functionBindContext;\nvar isCallable$9 = isCallable$n;\nvar hasOwn$3 = hasOwnProperty_1;\nvar fails$i = fails$s;\nvar html$1 = html$2;\nvar arraySlice$4 = arraySlice$5;\nvar createElement = documentCreateElement$2;\nvar validateArgumentsLength = validateArgumentsLength$1;\nvar IS_IOS$1 = engineIsIos;\nvar IS_NODE$3 = engineIsNode;\n\nvar set$1 = global$i.setImmediate;\nvar clear = global$i.clearImmediate;\nvar process$2 = global$i.process;\nvar Dispatch = global$i.Dispatch;\nvar Function$1 = global$i.Function;\nvar MessageChannel = global$i.MessageChannel;\nvar String$1 = global$i.String;\nvar counter = 0;\nvar queue$1 = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar location, defer, channel, port;\n\ntry {\n  // Deno throws a ReferenceError on `location` access without `--location` flag\n  location = global$i.location;\n} catch (error) { /* empty */ }\n\nvar run = function (id) {\n  if (hasOwn$3(queue$1, id)) {\n    var fn = queue$1[id];\n    delete queue$1[id];\n    fn();\n  }\n};\n\nvar runner = function (id) {\n  return function () {\n    run(id);\n  };\n};\n\nvar listener = function (event) {\n  run(event.data);\n};\n\nvar post = function (id) {\n  // old engines have not location.origin\n  global$i.postMessage(String$1(id), location.protocol + '//' + location.host);\n};\n\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif (!set$1 || !clear) {\n  set$1 = function setImmediate(handler) {\n    validateArgumentsLength(arguments.length, 1);\n    var fn = isCallable$9(handler) ? handler : Function$1(handler);\n    var args = arraySlice$4(arguments, 1);\n    queue$1[++counter] = function () {\n      apply$2(fn, undefined, args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clear = function clearImmediate(id) {\n    delete queue$1[id];\n  };\n  // Node.js 0.8-\n  if (IS_NODE$3) {\n    defer = function (id) {\n      process$2.nextTick(runner(id));\n    };\n  // Sphere (JS game engine) Dispatch API\n  } else if (Dispatch && Dispatch.now) {\n    defer = function (id) {\n      Dispatch.now(runner(id));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  // except iOS - https://github.com/zloirock/core-js/issues/624\n  } else if (MessageChannel && !IS_IOS$1) {\n    channel = new MessageChannel();\n    port = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = bind$5(port.postMessage, port);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if (\n    global$i.addEventListener &&\n    isCallable$9(global$i.postMessage) &&\n    !global$i.importScripts &&\n    location && location.protocol !== 'file:' &&\n    !fails$i(post)\n  ) {\n    defer = post;\n    global$i.addEventListener('message', listener, false);\n  // IE8-\n  } else if (ONREADYSTATECHANGE in createElement('script')) {\n    defer = function (id) {\n      html$1.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n        html$1.removeChild(this);\n        run(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function (id) {\n      setTimeout(runner(id), 0);\n    };\n  }\n}\n\nvar task$1 = {\n  set: set$1,\n  clear: clear\n};\n\nvar userAgent$3 = engineUserAgent;\nvar global$h = global$t;\n\nvar engineIsIosPebble = /ipad|iphone|ipod/i.test(userAgent$3) && global$h.Pebble !== undefined;\n\nvar userAgent$2 = engineUserAgent;\n\nvar engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(userAgent$2);\n\nvar global$g = global$t;\nvar bind$4 = functionBindContext;\nvar getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar macrotask = task$1.set;\nvar IS_IOS = engineIsIos;\nvar IS_IOS_PEBBLE = engineIsIosPebble;\nvar IS_WEBOS_WEBKIT = engineIsWebosWebkit;\nvar IS_NODE$2 = engineIsNode;\n\nvar MutationObserver = global$g.MutationObserver || global$g.WebKitMutationObserver;\nvar document$2 = global$g.document;\nvar process$1 = global$g.process;\nvar Promise$1 = global$g.Promise;\n// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$g, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\n\nvar flush, head, last, notify$1, toggle, node, promise, then;\n\n// modern engines have queueMicrotask method\nif (!queueMicrotask) {\n  flush = function () {\n    var parent, fn;\n    if (IS_NODE$2 && (parent = process$1.domain)) parent.exit();\n    while (head) {\n      fn = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch (error) {\n        if (head) notify$1();\n        else last = undefined;\n        throw error;\n      }\n    } last = undefined;\n    if (parent) parent.enter();\n  };\n\n  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339\n  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898\n  if (!IS_IOS && !IS_NODE$2 && !IS_WEBOS_WEBKIT && MutationObserver && document$2) {\n    toggle = true;\n    node = document$2.createTextNode('');\n    new MutationObserver(flush).observe(node, { characterData: true });\n    notify$1 = function () {\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if (!IS_IOS_PEBBLE && Promise$1 && Promise$1.resolve) {\n    // Promise.resolve without an argument throws an error in LG WebOS 2\n    promise = Promise$1.resolve(undefined);\n    // workaround of WebKit ~ iOS Safari 10.1 bug\n    promise.constructor = Promise$1;\n    then = bind$4(promise.then, promise);\n    notify$1 = function () {\n      then(flush);\n    };\n  // Node.js without promises\n  } else if (IS_NODE$2) {\n    notify$1 = function () {\n      process$1.nextTick(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessage\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    // strange IE + webpack dev server bug - use .bind(global)\n    macrotask = bind$4(macrotask, global$g);\n    notify$1 = function () {\n      macrotask(flush);\n    };\n  }\n}\n\nvar microtask$1 = queueMicrotask || function (fn) {\n  var task = { fn: fn, next: undefined };\n  if (last) last.next = task;\n  if (!head) {\n    head = task;\n    notify$1();\n  } last = task;\n};\n\nvar global$f = global$t;\n\nvar hostReportErrors$1 = function (a, b) {\n  var console = global$f.console;\n  if (console && console.error) {\n    arguments.length == 1 ? console.error(a) : console.error(a, b);\n  }\n};\n\nvar perform$3 = function (exec) {\n  try {\n    return { error: false, value: exec() };\n  } catch (error) {\n    return { error: true, value: error };\n  }\n};\n\nvar Queue$1 = function () {\n  this.head = null;\n  this.tail = null;\n};\n\nQueue$1.prototype = {\n  add: function (item) {\n    var entry = { item: item, next: null };\n    if (this.head) this.tail.next = entry;\n    else this.head = entry;\n    this.tail = entry;\n  },\n  get: function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = entry.next;\n      if (this.tail === entry) this.tail = null;\n      return entry.item;\n    }\n  }\n};\n\nvar queue = Queue$1;\n\nvar global$e = global$t;\n\nvar promiseNativeConstructor = global$e.Promise;\n\nvar engineIsBrowser = typeof window == 'object' && typeof Deno != 'object';\n\nvar global$d = global$t;\nvar NativePromiseConstructor$3 = promiseNativeConstructor;\nvar isCallable$8 = isCallable$n;\nvar isForced = isForced_1;\nvar inspectSource = inspectSource$4;\nvar wellKnownSymbol$c = wellKnownSymbol$j;\nvar IS_BROWSER = engineIsBrowser;\nvar V8_VERSION = engineV8Version;\n\nNativePromiseConstructor$3 && NativePromiseConstructor$3.prototype;\nvar SPECIES$2 = wellKnownSymbol$c('species');\nvar SUBCLASSING = false;\nvar NATIVE_PROMISE_REJECTION_EVENT$1 = isCallable$8(global$d.PromiseRejectionEvent);\n\nvar FORCED_PROMISE_CONSTRUCTOR$5 = isForced('Promise', function () {\n  var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(NativePromiseConstructor$3);\n  var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(NativePromiseConstructor$3);\n  // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n  // We can't detect it synchronously, so just check versions\n  if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66) return true;\n  // We can't use @@species feature detection in V8 since it causes\n  // deoptimization and performance degradation\n  // https://github.com/zloirock/core-js/issues/679\n  if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE)) return false;\n  // Detect correctness of subclassing with @@species support\n  var promise = new NativePromiseConstructor$3(function (resolve) { resolve(1); });\n  var FakePromise = function (exec) {\n    exec(function () { /* empty */ }, function () { /* empty */ });\n  };\n  var constructor = promise.constructor = {};\n  constructor[SPECIES$2] = FakePromise;\n  SUBCLASSING = promise.then(function () { /* empty */ }) instanceof FakePromise;\n  if (!SUBCLASSING) return true;\n  // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n  return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_PROMISE_REJECTION_EVENT$1;\n});\n\nvar promiseConstructorDetection = {\n  CONSTRUCTOR: FORCED_PROMISE_CONSTRUCTOR$5,\n  REJECTION_EVENT: NATIVE_PROMISE_REJECTION_EVENT$1,\n  SUBCLASSING: SUBCLASSING\n};\n\nvar newPromiseCapability$2 = {};\n\nvar aCallable$6 = aCallable$9;\n\nvar PromiseCapability = function (C) {\n  var resolve, reject;\n  this.promise = new C(function ($$resolve, $$reject) {\n    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject = $$reject;\n  });\n  this.resolve = aCallable$6(resolve);\n  this.reject = aCallable$6(reject);\n};\n\n// `NewPromiseCapability` abstract operation\n// https://tc39.es/ecma262/#sec-newpromisecapability\nnewPromiseCapability$2.f = function (C) {\n  return new PromiseCapability(C);\n};\n\nvar $$e = _export;\nvar IS_NODE$1 = engineIsNode;\nvar global$c = global$t;\nvar call$f = functionCall;\nvar defineBuiltIn$6 = defineBuiltIn$8;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\nvar setToStringTag$3 = setToStringTag$4;\nvar setSpecies$1 = setSpecies$2;\nvar aCallable$5 = aCallable$9;\nvar isCallable$7 = isCallable$n;\nvar isObject$7 = isObject$d;\nvar anInstance$2 = anInstance$3;\nvar speciesConstructor$2 = speciesConstructor$3;\nvar task = task$1.set;\nvar microtask = microtask$1;\nvar hostReportErrors = hostReportErrors$1;\nvar perform$2 = perform$3;\nvar Queue = queue;\nvar InternalStateModule$4 = internalState;\nvar NativePromiseConstructor$2 = promiseNativeConstructor;\nvar PromiseConstructorDetection = promiseConstructorDetection;\nvar newPromiseCapabilityModule$3 = newPromiseCapability$2;\n\nvar PROMISE = 'Promise';\nvar FORCED_PROMISE_CONSTRUCTOR$4 = PromiseConstructorDetection.CONSTRUCTOR;\nvar NATIVE_PROMISE_REJECTION_EVENT = PromiseConstructorDetection.REJECTION_EVENT;\nvar NATIVE_PROMISE_SUBCLASSING = PromiseConstructorDetection.SUBCLASSING;\nvar getInternalPromiseState = InternalStateModule$4.getterFor(PROMISE);\nvar setInternalState$3 = InternalStateModule$4.set;\nvar NativePromisePrototype$1 = NativePromiseConstructor$2 && NativePromiseConstructor$2.prototype;\nvar PromiseConstructor = NativePromiseConstructor$2;\nvar PromisePrototype = NativePromisePrototype$1;\nvar TypeError$2 = global$c.TypeError;\nvar document$1 = global$c.document;\nvar process = global$c.process;\nvar newPromiseCapability$1 = newPromiseCapabilityModule$3.f;\nvar newGenericPromiseCapability = newPromiseCapability$1;\n\nvar DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$c.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\n\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\n\n// helpers\nvar isThenable = function (it) {\n  var then;\n  return isObject$7(it) && isCallable$7(then = it.then) ? then : false;\n};\n\nvar callReaction = function (reaction, state) {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var handler = ok ? reaction.ok : reaction.fail;\n  var resolve = reaction.resolve;\n  var reject = reaction.reject;\n  var domain = reaction.domain;\n  var result, then, exited;\n  try {\n    if (handler) {\n      if (!ok) {\n        if (state.rejection === UNHANDLED) onHandleUnhandled(state);\n        state.rejection = HANDLED;\n      }\n      if (handler === true) result = value;\n      else {\n        if (domain) domain.enter();\n        result = handler(value); // can throw\n        if (domain) {\n          domain.exit();\n          exited = true;\n        }\n      }\n      if (result === reaction.promise) {\n        reject(TypeError$2('Promise-chain cycle'));\n      } else if (then = isThenable(result)) {\n        call$f(then, result, resolve, reject);\n      } else resolve(result);\n    } else reject(value);\n  } catch (error) {\n    if (domain && !exited) domain.exit();\n    reject(error);\n  }\n};\n\nvar notify = function (state, isReject) {\n  if (state.notified) return;\n  state.notified = true;\n  microtask(function () {\n    var reactions = state.reactions;\n    var reaction;\n    while (reaction = reactions.get()) {\n      callReaction(reaction, state);\n    }\n    state.notified = false;\n    if (isReject && !state.rejection) onUnhandled(state);\n  });\n};\n\nvar dispatchEvent = function (name, promise, reason) {\n  var event, handler;\n  if (DISPATCH_EVENT) {\n    event = document$1.createEvent('Event');\n    event.promise = promise;\n    event.reason = reason;\n    event.initEvent(name, false, true);\n    global$c.dispatchEvent(event);\n  } else event = { promise: promise, reason: reason };\n  if (!NATIVE_PROMISE_REJECTION_EVENT && (handler = global$c['on' + name])) handler(event);\n  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);\n};\n\nvar onUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    var value = state.value;\n    var IS_UNHANDLED = isUnhandled(state);\n    var result;\n    if (IS_UNHANDLED) {\n      result = perform$2(function () {\n        if (IS_NODE$1) {\n          process.emit('unhandledRejection', value, promise);\n        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      state.rejection = IS_NODE$1 || isUnhandled(state) ? UNHANDLED : HANDLED;\n      if (result.error) throw result.value;\n    }\n  });\n};\n\nvar isUnhandled = function (state) {\n  return state.rejection !== HANDLED && !state.parent;\n};\n\nvar onHandleUnhandled = function (state) {\n  call$f(task, global$c, function () {\n    var promise = state.facade;\n    if (IS_NODE$1) {\n      process.emit('rejectionHandled', promise);\n    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);\n  });\n};\n\nvar bind$3 = function (fn, state, unwrap) {\n  return function (value) {\n    fn(state, value, unwrap);\n  };\n};\n\nvar internalReject = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  state.value = value;\n  state.state = REJECTED;\n  notify(state, true);\n};\n\nvar internalResolve = function (state, value, unwrap) {\n  if (state.done) return;\n  state.done = true;\n  if (unwrap) state = unwrap;\n  try {\n    if (state.facade === value) throw TypeError$2(\"Promise can't be resolved itself\");\n    var then = isThenable(value);\n    if (then) {\n      microtask(function () {\n        var wrapper = { done: false };\n        try {\n          call$f(then, value,\n            bind$3(internalResolve, wrapper, state),\n            bind$3(internalReject, wrapper, state)\n          );\n        } catch (error) {\n          internalReject(wrapper, error, state);\n        }\n      });\n    } else {\n      state.value = value;\n      state.state = FULFILLED;\n      notify(state, false);\n    }\n  } catch (error) {\n    internalReject({ done: false }, error, state);\n  }\n};\n\n// constructor polyfill\nif (FORCED_PROMISE_CONSTRUCTOR$4) {\n  // 25.4.3.1 Promise(executor)\n  PromiseConstructor = function Promise(executor) {\n    anInstance$2(this, PromisePrototype);\n    aCallable$5(executor);\n    call$f(Internal, this);\n    var state = getInternalPromiseState(this);\n    try {\n      executor(bind$3(internalResolve, state), bind$3(internalReject, state));\n    } catch (error) {\n      internalReject(state, error);\n    }\n  };\n\n  PromisePrototype = PromiseConstructor.prototype;\n\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  Internal = function Promise(executor) {\n    setInternalState$3(this, {\n      type: PROMISE,\n      done: false,\n      notified: false,\n      parent: false,\n      reactions: new Queue(),\n      rejection: false,\n      state: PENDING,\n      value: undefined\n    });\n  };\n\n  // `Promise.prototype.then` method\n  // https://tc39.es/ecma262/#sec-promise.prototype.then\n  Internal.prototype = defineBuiltIn$6(PromisePrototype, 'then', function then(onFulfilled, onRejected) {\n    var state = getInternalPromiseState(this);\n    var reaction = newPromiseCapability$1(speciesConstructor$2(this, PromiseConstructor));\n    state.parent = true;\n    reaction.ok = isCallable$7(onFulfilled) ? onFulfilled : true;\n    reaction.fail = isCallable$7(onRejected) && onRejected;\n    reaction.domain = IS_NODE$1 ? process.domain : undefined;\n    if (state.state == PENDING) state.reactions.add(reaction);\n    else microtask(function () {\n      callReaction(reaction, state);\n    });\n    return reaction.promise;\n  });\n\n  OwnPromiseCapability = function () {\n    var promise = new Internal();\n    var state = getInternalPromiseState(promise);\n    this.promise = promise;\n    this.resolve = bind$3(internalResolve, state);\n    this.reject = bind$3(internalReject, state);\n  };\n\n  newPromiseCapabilityModule$3.f = newPromiseCapability$1 = function (C) {\n    return C === PromiseConstructor || C === PromiseWrapper\n      ? new OwnPromiseCapability(C)\n      : newGenericPromiseCapability(C);\n  };\n\n  if (isCallable$7(NativePromiseConstructor$2) && NativePromisePrototype$1 !== Object.prototype) {\n    nativeThen = NativePromisePrototype$1.then;\n\n    if (!NATIVE_PROMISE_SUBCLASSING) {\n      // make `Promise#then` return a polyfilled `Promise` for native promise-based APIs\n      defineBuiltIn$6(NativePromisePrototype$1, 'then', function then(onFulfilled, onRejected) {\n        var that = this;\n        return new PromiseConstructor(function (resolve, reject) {\n          call$f(nativeThen, that, resolve, reject);\n        }).then(onFulfilled, onRejected);\n      // https://github.com/zloirock/core-js/issues/640\n      }, { unsafe: true });\n    }\n\n    // make `.constructor === Promise` work for native promise-based APIs\n    try {\n      delete NativePromisePrototype$1.constructor;\n    } catch (error) { /* empty */ }\n\n    // make `instanceof Promise` work for native promise-based APIs\n    if (setPrototypeOf$5) {\n      setPrototypeOf$5(NativePromisePrototype$1, PromisePrototype);\n    }\n  }\n}\n\n$$e({ global: true, constructor: true, wrap: true, forced: FORCED_PROMISE_CONSTRUCTOR$4 }, {\n  Promise: PromiseConstructor\n});\n\nsetToStringTag$3(PromiseConstructor, PROMISE, false);\nsetSpecies$1(PROMISE);\n\nvar iterators = {};\n\nvar wellKnownSymbol$b = wellKnownSymbol$j;\nvar Iterators$4 = iterators;\n\nvar ITERATOR$5 = wellKnownSymbol$b('iterator');\nvar ArrayPrototype$1 = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$4.Array === it || ArrayPrototype$1[ITERATOR$5] === it);\n};\n\nvar classof$7 = classof$9;\nvar getMethod$2 = getMethod$4;\nvar Iterators$3 = iterators;\nvar wellKnownSymbol$a = wellKnownSymbol$j;\n\nvar ITERATOR$4 = wellKnownSymbol$a('iterator');\n\nvar getIteratorMethod$3 = function (it) {\n  if (it != undefined) return getMethod$2(it, ITERATOR$4)\n    || getMethod$2(it, '@@iterator')\n    || Iterators$3[classof$7(it)];\n};\n\nvar call$e = functionCall;\nvar aCallable$4 = aCallable$9;\nvar anObject$9 = anObject$e;\nvar tryToString$2 = tryToString$5;\nvar getIteratorMethod$2 = getIteratorMethod$3;\n\nvar $TypeError$5 = TypeError;\n\nvar getIterator$2 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$2(argument) : usingIterator;\n  if (aCallable$4(iteratorMethod)) return anObject$9(call$e(iteratorMethod, argument));\n  throw $TypeError$5(tryToString$2(argument) + ' is not iterable');\n};\n\nvar call$d = functionCall;\nvar anObject$8 = anObject$e;\nvar getMethod$1 = getMethod$4;\n\nvar iteratorClose$1 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$8(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$d(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$8(innerResult);\n  return value;\n};\n\nvar bind$2 = functionBindContext;\nvar call$c = functionCall;\nvar anObject$7 = anObject$e;\nvar tryToString$1 = tryToString$5;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$8;\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar getIterator$1 = getIterator$2;\nvar getIteratorMethod$1 = getIteratorMethod$3;\nvar iteratorClose = iteratorClose$1;\n\nvar $TypeError$4 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$2 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$2(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$7(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod$1(iterable);\n    if (!iterFn) throw $TypeError$4(tryToString$1(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod$1(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$6(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$2(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator$1(iterable, iterFn);\n  }\n\n  next = iterator.next;\n  while (!(step = call$c(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$2(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar wellKnownSymbol$9 = wellKnownSymbol$j;\n\nvar ITERATOR$3 = wellKnownSymbol$9('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$3] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es-x/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$2 = function (exec, SKIP_CLOSING) {\n  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$3] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar NativePromiseConstructor$1 = promiseNativeConstructor;\nvar checkCorrectnessOfIteration$1 = checkCorrectnessOfIteration$2;\nvar FORCED_PROMISE_CONSTRUCTOR$3 = promiseConstructorDetection.CONSTRUCTOR;\n\nvar promiseStaticsIncorrectIteration = FORCED_PROMISE_CONSTRUCTOR$3 || !checkCorrectnessOfIteration$1(function (iterable) {\n  NativePromiseConstructor$1.all(iterable).then(undefined, function () { /* empty */ });\n});\n\nvar $$d = _export;\nvar call$b = functionCall;\nvar aCallable$3 = aCallable$9;\nvar newPromiseCapabilityModule$2 = newPromiseCapability$2;\nvar perform$1 = perform$3;\nvar iterate$1 = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION$1 = promiseStaticsIncorrectIteration;\n\n// `Promise.all` method\n// https://tc39.es/ecma262/#sec-promise.all\n$$d({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION$1 }, {\n  all: function all(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$2.f(C);\n    var resolve = capability.resolve;\n    var reject = capability.reject;\n    var result = perform$1(function () {\n      var $promiseResolve = aCallable$3(C.resolve);\n      var values = [];\n      var counter = 0;\n      var remaining = 1;\n      iterate$1(iterable, function (promise) {\n        var index = counter++;\n        var alreadyCalled = false;\n        remaining++;\n        call$b($promiseResolve, C, promise).then(function (value) {\n          if (alreadyCalled) return;\n          alreadyCalled = true;\n          values[index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$c = _export;\nvar FORCED_PROMISE_CONSTRUCTOR$2 = promiseConstructorDetection.CONSTRUCTOR;\nvar NativePromiseConstructor = promiseNativeConstructor;\nvar getBuiltIn$1 = getBuiltIn$8;\nvar isCallable$6 = isCallable$n;\nvar defineBuiltIn$5 = defineBuiltIn$8;\n\nvar NativePromisePrototype = NativePromiseConstructor && NativePromiseConstructor.prototype;\n\n// `Promise.prototype.catch` method\n// https://tc39.es/ecma262/#sec-promise.prototype.catch\n$$c({ target: 'Promise', proto: true, forced: FORCED_PROMISE_CONSTRUCTOR$2, real: true }, {\n  'catch': function (onRejected) {\n    return this.then(undefined, onRejected);\n  }\n});\n\n// makes sure that native promise-based APIs `Promise#catch` properly works with patched `Promise#then`\nif (isCallable$6(NativePromiseConstructor)) {\n  var method = getBuiltIn$1('Promise').prototype['catch'];\n  if (NativePromisePrototype['catch'] !== method) {\n    defineBuiltIn$5(NativePromisePrototype, 'catch', method, { unsafe: true });\n  }\n}\n\nvar $$b = _export;\nvar call$a = functionCall;\nvar aCallable$2 = aCallable$9;\nvar newPromiseCapabilityModule$1 = newPromiseCapability$2;\nvar perform = perform$3;\nvar iterate = iterate$2;\nvar PROMISE_STATICS_INCORRECT_ITERATION = promiseStaticsIncorrectIteration;\n\n// `Promise.race` method\n// https://tc39.es/ecma262/#sec-promise.race\n$$b({ target: 'Promise', stat: true, forced: PROMISE_STATICS_INCORRECT_ITERATION }, {\n  race: function race(iterable) {\n    var C = this;\n    var capability = newPromiseCapabilityModule$1.f(C);\n    var reject = capability.reject;\n    var result = perform(function () {\n      var $promiseResolve = aCallable$2(C.resolve);\n      iterate(iterable, function (promise) {\n        call$a($promiseResolve, C, promise).then(capability.resolve, reject);\n      });\n    });\n    if (result.error) reject(result.value);\n    return capability.promise;\n  }\n});\n\nvar $$a = _export;\nvar call$9 = functionCall;\nvar newPromiseCapabilityModule = newPromiseCapability$2;\nvar FORCED_PROMISE_CONSTRUCTOR$1 = promiseConstructorDetection.CONSTRUCTOR;\n\n// `Promise.reject` method\n// https://tc39.es/ecma262/#sec-promise.reject\n$$a({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR$1 }, {\n  reject: function reject(r) {\n    var capability = newPromiseCapabilityModule.f(this);\n    call$9(capability.reject, undefined, r);\n    return capability.promise;\n  }\n});\n\nvar anObject$6 = anObject$e;\nvar isObject$6 = isObject$d;\nvar newPromiseCapability = newPromiseCapability$2;\n\nvar promiseResolve$1 = function (C, x) {\n  anObject$6(C);\n  if (isObject$6(x) && x.constructor === C) return x;\n  var promiseCapability = newPromiseCapability.f(C);\n  var resolve = promiseCapability.resolve;\n  resolve(x);\n  return promiseCapability.promise;\n};\n\nvar $$9 = _export;\nvar getBuiltIn = getBuiltIn$8;\nvar FORCED_PROMISE_CONSTRUCTOR = promiseConstructorDetection.CONSTRUCTOR;\nvar promiseResolve = promiseResolve$1;\n\ngetBuiltIn('Promise');\n\n// `Promise.resolve` method\n// https://tc39.es/ecma262/#sec-promise.resolve\n$$9({ target: 'Promise', stat: true, forced: FORCED_PROMISE_CONSTRUCTOR }, {\n  resolve: function resolve(x) {\n    return promiseResolve(this, x);\n  }\n});\n\nclass WebStorageService {\n  getItem(key) {\n    return new Promise(resolve => {\n      const value = localStorage.getItem(key);\n      resolve(value);\n    });\n  }\n  setItem(key, value) {\n    return new Promise(resolve => {\n      localStorage.setItem(key, value);\n      resolve();\n    });\n  }\n  removeItem(key) {\n    return new Promise(resolve => {\n      localStorage.removeItem(key);\n      resolve();\n    });\n  }\n}\n\nvar objectDefineProperties = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys$1 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es-x/no-object-keys -- safe\nvar objectKeys$2 = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys$1);\n};\n\nvar DESCRIPTORS$5 = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$5 = anObject$e;\nvar toIndexedObject$2 = toIndexedObject$6;\nvar objectKeys$1 = objectKeys$2;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es-x/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$5 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$5(O);\n  var props = toIndexedObject$2(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\n/* global ActiveXObject -- old IE, WSH */\n\nvar anObject$4 = anObject$e;\nvar definePropertiesModule = objectDefineProperties;\nvar enumBugKeys = enumBugKeys$3;\nvar hiddenKeys = hiddenKeys$4;\nvar html = html$2;\nvar documentCreateElement$1 = documentCreateElement$2;\nvar sharedKey$1 = sharedKey$3;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE$1 = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$1('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement$1('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es-x/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE$1] = anObject$4(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\nvar wellKnownSymbol$8 = wellKnownSymbol$j;\nvar create$3 = objectCreate;\nvar defineProperty$4 = objectDefineProperty.f;\n\nvar UNSCOPABLES = wellKnownSymbol$8('unscopables');\nvar ArrayPrototype = Array.prototype;\n\n// Array.prototype[@@unscopables]\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n  defineProperty$4(ArrayPrototype, UNSCOPABLES, {\n    configurable: true,\n    value: create$3(null)\n  });\n}\n\n// add a key to Array.prototype[@@unscopables]\nvar addToUnscopables$2 = function (key) {\n  ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\nvar fails$h = fails$s;\n\nvar correctPrototypeGetter = !fails$h(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es-x/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$2 = hasOwnProperty_1;\nvar isCallable$5 = isCallable$n;\nvar toObject$5 = toObject$7;\nvar sharedKey = sharedKey$3;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype$2 = $Object.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es-x/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n  var object = toObject$5(O);\n  if (hasOwn$2(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$5(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object ? ObjectPrototype$2 : null;\n};\n\nvar fails$g = fails$s;\nvar isCallable$4 = isCallable$n;\nvar getPrototypeOf$3 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$8;\nvar wellKnownSymbol$7 = wellKnownSymbol$j;\n\nvar ITERATOR$2 = wellKnownSymbol$7('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es-x/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = IteratorPrototype$2 == undefined || fails$g(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$2[ITERATOR$2].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$2 = {};\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$4(IteratorPrototype$2[ITERATOR$2])) {\n  defineBuiltIn$4(IteratorPrototype$2, ITERATOR$2, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$2,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar IteratorPrototype$1 = iteratorsCore.IteratorPrototype;\nvar create$2 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$2 = setToStringTag$4;\nvar Iterators$2 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar createIteratorConstructor$1 = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$2(IteratorPrototype$1, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);\n  Iterators$2[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar $$8 = _export;\nvar call$8 = functionCall;\nvar FunctionName$1 = functionName;\nvar isCallable$3 = isCallable$n;\nvar createIteratorConstructor = createIteratorConstructor$1;\nvar getPrototypeOf$2 = objectGetPrototypeOf;\nvar setPrototypeOf$4 = objectSetPrototypeOf;\nvar setToStringTag$1 = setToStringTag$4;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$8;\nvar defineBuiltIn$3 = defineBuiltIn$8;\nvar wellKnownSymbol$6 = wellKnownSymbol$j;\nvar Iterators$1 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME$2 = FunctionName$1.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME$1 = FunctionName$1.CONFIGURABLE;\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$1 = wellKnownSymbol$6('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar defineIterator$1 = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    } return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$1]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {\n        if (setPrototypeOf$4) {\n          setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);\n        } else if (!isCallable$3(CurrentIteratorPrototype[ITERATOR$1])) {\n          defineBuiltIn$3(CurrentIteratorPrototype, ITERATOR$1, returnThis);\n        }\n      }\n      // Set @@toStringTag to native iterators\n      setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME$2 && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    if (CONFIGURABLE_FUNCTION_NAME$1) {\n      createNonEnumerableProperty$5(IterablePrototype, 'name', VALUES);\n    } else {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$8(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$8({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if (IterablePrototype[ITERATOR$1] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$1, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$1[NAME] = defaultIterator;\n\n  return methods;\n};\n\nvar toIndexedObject$1 = toIndexedObject$6;\nvar addToUnscopables$1 = addToUnscopables$2;\nvar Iterators = iterators;\nvar InternalStateModule$3 = internalState;\nvar defineProperty$3 = objectDefineProperty.f;\nvar defineIterator = defineIterator$1;\nvar DESCRIPTORS$4 = descriptors;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$2 = InternalStateModule$3.set;\nvar getInternalState$4 = InternalStateModule$3.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\nvar es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {\n  setInternalState$2(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject$1(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$4(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return { value: undefined, done: true };\n  }\n  if (kind == 'keys') return { value: index, done: false };\n  if (kind == 'values') return { value: target[index], done: false };\n  return { value: [index, target[index]], done: false };\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nvar values = Iterators.Arguments = Iterators.Array;\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables$1('keys');\naddToUnscopables$1('values');\naddToUnscopables$1('entries');\n\n// V8 ~ Chrome 45- bug\nif (DESCRIPTORS$4 && values.name !== 'values') try {\n  defineProperty$3(values, 'name', { value: 'values' });\n} catch (error) { /* empty */ }\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\n// in old WebKit versions, `element.classList` is not an instance of global `DOMTokenList`\nvar documentCreateElement = documentCreateElement$2;\n\nvar classList = documentCreateElement('span').classList;\nvar DOMTokenListPrototype$1 = classList && classList.constructor && classList.constructor.prototype;\n\nvar domTokenListPrototype = DOMTokenListPrototype$1 === Object.prototype ? undefined : DOMTokenListPrototype$1;\n\nvar global$b = global$t;\nvar DOMIterables = domIterables;\nvar DOMTokenListPrototype = domTokenListPrototype;\nvar ArrayIteratorMethods = es_array_iterator;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$8;\nvar wellKnownSymbol$5 = wellKnownSymbol$j;\n\nvar ITERATOR = wellKnownSymbol$5('iterator');\nvar TO_STRING_TAG$1 = wellKnownSymbol$5('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\n\nvar handlePrototype = function (CollectionPrototype, COLLECTION_NAME) {\n  if (CollectionPrototype) {\n    // some Chrome versions have non-configurable methods on DOMTokenList\n    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {\n      createNonEnumerableProperty$4(CollectionPrototype, ITERATOR, ArrayValues);\n    } catch (error) {\n      CollectionPrototype[ITERATOR] = ArrayValues;\n    }\n    if (!CollectionPrototype[TO_STRING_TAG$1]) {\n      createNonEnumerableProperty$4(CollectionPrototype, TO_STRING_TAG$1, COLLECTION_NAME);\n    }\n    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {\n      // some Chrome versions have non-configurable methods on DOMTokenList\n      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {\n        createNonEnumerableProperty$4(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n      } catch (error) {\n        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n      }\n    }\n  }\n};\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  handlePrototype(global$b[COLLECTION_NAME] && global$b[COLLECTION_NAME].prototype, COLLECTION_NAME);\n}\n\nhandlePrototype(DOMTokenListPrototype, 'DOMTokenList');\n\nclass Logger {\n  constructor(namespace) {\n    this.namespace = namespace;\n  }\n  emit(method, ...params) {\n    if (!Logger.debug) {\n      return;\n    }\n    if (this.namespace && method !== \"error\") {\n      // eslint-disable-next-line no-console\n      console[method](this.namespace, ...params);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console[method](...params);\n  }\n  log(...params) {\n    this.emit(\"log\", ...params);\n  }\n  info(...params) {\n    this.emit(\"info\", ...params);\n  }\n  warn(...params) {\n    this.emit(\"warn\", ...params);\n  }\n  error(...params) {\n    this.emit(\"error\", ...params);\n  }\n}\nLogger.debug = false;\nconst logger = new Logger();\n\nvar $$7 = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$f = fails$s;\nvar addToUnscopables = addToUnscopables$2;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$f(function () {\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$7({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables\naddToUnscopables('includes');\n\nvar isObject$5 = isObject$d;\nvar classof$6 = classofRaw$1;\nvar wellKnownSymbol$4 = wellKnownSymbol$j;\n\nvar MATCH$1 = wellKnownSymbol$4('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$5(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$6(it) == 'RegExp');\n};\n\nvar isRegExp$1 = isRegexp;\n\nvar $TypeError$3 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp$1(it)) {\n    throw $TypeError$3(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar classof$5 = classof$9;\n\nvar $String = String;\n\nvar toString$5 = function (argument) {\n  if (classof$5(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');\n  return $String(argument);\n};\n\nvar wellKnownSymbol$3 = wellKnownSymbol$j;\n\nvar MATCH = wellKnownSymbol$3('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$6 = _export;\nvar uncurryThis$b = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$3 = requireObjectCoercible$6;\nvar toString$4 = toString$5;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$b(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$6({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$4(requireObjectCoercible$3(this)),\n      toString$4(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\n// a string of all valid unicode whitespaces\nvar whitespaces$2 = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar uncurryThis$a = functionUncurryThis;\nvar requireObjectCoercible$2 = requireObjectCoercible$6;\nvar toString$3 = toString$5;\nvar whitespaces$1 = whitespaces$2;\n\nvar replace$1 = uncurryThis$a(''.replace);\nvar whitespace = '[' + whitespaces$1 + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod$3 = function (TYPE) {\n  return function ($this) {\n    var string = toString$3(requireObjectCoercible$2($this));\n    if (TYPE & 1) string = replace$1(string, ltrim, '');\n    if (TYPE & 2) string = replace$1(string, rtrim, '');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$3(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod$3(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod$3(3)\n};\n\nvar PROPER_FUNCTION_NAME$1 = functionName.PROPER;\nvar fails$e = fails$s;\nvar whitespaces = whitespaces$2;\n\nvar non = '\\u200B\\u0085\\u180E';\n\n// check that a method works with the correct list\n// of whitespaces and has a correct name\nvar stringTrimForced = function (METHOD_NAME) {\n  return fails$e(function () {\n    return !!whitespaces[METHOD_NAME]()\n      || non[METHOD_NAME]() !== non\n      || (PROPER_FUNCTION_NAME$1 && whitespaces[METHOD_NAME].name !== METHOD_NAME);\n  });\n};\n\nvar $$5 = _export;\nvar $trim = stringTrim.trim;\nvar forcedStringTrimMethod = stringTrimForced;\n\n// `String.prototype.trim` method\n// https://tc39.es/ecma262/#sec-string.prototype.trim\n$$5({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {\n  trim: function trim() {\n    return $trim(this);\n  }\n});\n\nvar DESCRIPTORS$3 = descriptors;\nvar uncurryThis$9 = functionUncurryThis;\nvar call$7 = functionCall;\nvar fails$d = fails$s;\nvar objectKeys = objectKeys$2;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar toObject$4 = toObject$7;\nvar IndexedObject$2 = indexedObject;\n\n// eslint-disable-next-line es-x/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es-x/no-object-defineproperty -- required for testing\nvar defineProperty$2 = Object.defineProperty;\nvar concat = uncurryThis$9([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$d(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$3 && $assign({ b: 1 }, $assign(defineProperty$2({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$2(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es-x/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$4(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$2(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat(objectKeys(S), getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$3 || call$7(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$4 = _export;\nvar assign = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es-x/no-object-assign -- required for testing\n$$4({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign }, {\n  assign: assign\n});\n\nclass EventEmitter {\n  constructor() {\n    this.emitter = new events__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();\n  }\n  on(eventName, callback) {\n    this.emitter.on(eventName, callback);\n    return {\n      remove: () => this.emitter.off(eventName, callback)\n    };\n  }\n  off(eventName, callback) {\n    this.emitter.off(eventName, callback);\n  }\n  emit(eventName, event) {\n    this.emitter.emit(eventName, event);\n  }\n}\n\nconst PACKAGE_NAME = \"near-wallet-selector\";\nconst RECENTLY_SIGNED_IN_WALLETS = \"recentlySignedInWallets\";\nconst CONTRACT = \"contract\";\nconst PENDING_CONTRACT = \"contract:pending\";\nconst SELECTED_WALLET_ID = `selectedWalletId`;\nconst PENDING_SELECTED_WALLET_ID = `selectedWalletId:pending`;\n\nclass WalletModules {\n  constructor({\n    factories,\n    storage,\n    options,\n    store,\n    emitter,\n    provider\n  }) {\n    this.factories = factories;\n    this.storage = storage;\n    this.options = options;\n    this.store = store;\n    this.emitter = emitter;\n    this.provider = provider;\n    this.modules = [];\n    this.instances = {};\n  }\n  validateWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let accounts = [];\n      const wallet = yield this.getWallet(id);\n      if (wallet) {\n        // Ensure our persistent state aligns with the selected wallet.\n        // For example a wallet is selected, but it returns no accounts (not signed in).\n        accounts = yield wallet.getAccounts().catch(err => {\n          logger.log(`Failed to validate ${wallet.id} during setup`);\n          logger.error(err);\n          return [];\n        });\n      }\n      return accounts;\n    });\n  }\n  resolveStorageState() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const pendingSelectedWalletId = yield jsonStorage.getItem(PENDING_SELECTED_WALLET_ID);\n      const pendingContract = yield jsonStorage.getItem(PENDING_CONTRACT);\n      if (pendingSelectedWalletId && pendingContract) {\n        const _accounts = yield this.validateWallet(pendingSelectedWalletId);\n        yield jsonStorage.removeItem(PENDING_SELECTED_WALLET_ID);\n        yield jsonStorage.removeItem(PENDING_CONTRACT);\n        if (_accounts.length) {\n          const {\n            selectedWalletId: _selectedWalletId\n          } = this.store.getState();\n          const selectedWallet = yield this.getWallet(_selectedWalletId);\n          if (selectedWallet && pendingSelectedWalletId !== _selectedWalletId) {\n            yield selectedWallet.signOut().catch(err => {\n              logger.log(\"Failed to sign out existing wallet\");\n              logger.error(err);\n            });\n          }\n          const recentlySignedInWalletsFromPending = yield this.setWalletAsRecentlySignedIn(pendingSelectedWalletId);\n          return {\n            accounts: _accounts,\n            contract: pendingContract,\n            selectedWalletId: pendingSelectedWalletId,\n            recentlySignedInWallets: recentlySignedInWalletsFromPending\n          };\n        }\n      }\n      const {\n        contract,\n        selectedWalletId\n      } = this.store.getState();\n      const accounts = yield this.validateWallet(selectedWalletId);\n      const recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!accounts.length) {\n        return {\n          accounts: [],\n          contract: null,\n          selectedWalletId: null,\n          recentlySignedInWallets: recentlySignedInWallets || []\n        };\n      }\n      return {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets: recentlySignedInWallets || []\n      };\n    });\n  }\n  setWalletAsRecentlySignedIn(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      let recentlySignedInWallets = yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS);\n      if (!recentlySignedInWallets) {\n        recentlySignedInWallets = [];\n      }\n      if (!recentlySignedInWallets.includes(walletId)) {\n        recentlySignedInWallets.unshift(walletId);\n        recentlySignedInWallets = recentlySignedInWallets.slice(0, 5);\n        yield jsonStorage.setItem(RECENTLY_SIGNED_IN_WALLETS, recentlySignedInWallets);\n      }\n      return recentlySignedInWallets;\n    });\n  }\n  signOutWallet(walletId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = yield this.getWallet(walletId);\n      yield wallet.signOut().catch(err => {\n        logger.log(`Failed to sign out ${wallet.id}`);\n        logger.error(err);\n        // At least clean up state on our side.\n        this.onWalletSignedOut(wallet.id);\n      });\n    });\n  }\n  onWalletSignedIn(walletId, {\n    accounts,\n    contractId,\n    methodNames\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      const jsonStorage = new JsonStorage(this.storage, PACKAGE_NAME);\n      const contract = {\n        contractId,\n        methodNames\n      };\n      if (!accounts.length) {\n        const module = this.getModule(walletId);\n        // We can't guarantee the user will actually sign in with browser wallets.\n        // Best we can do is set in storage and validate on init.\n        if (module.type === \"browser\") {\n          yield jsonStorage.setItem(PENDING_SELECTED_WALLET_ID, walletId);\n          yield jsonStorage.setItem(PENDING_CONTRACT, contract);\n        }\n        return;\n      }\n      if (selectedWalletId && selectedWalletId !== walletId) {\n        yield this.signOutWallet(selectedWalletId);\n      }\n      const recentlySignedInWallets = yield this.setWalletAsRecentlySignedIn(walletId);\n      this.store.dispatch({\n        type: \"WALLET_CONNECTED\",\n        payload: {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        }\n      });\n      this.emitter.emit(\"signedIn\", {\n        walletId,\n        contractId,\n        methodNames,\n        accounts\n      });\n    });\n  }\n  onWalletSignedOut(walletId) {\n    this.store.dispatch({\n      type: \"WALLET_DISCONNECTED\",\n      payload: {\n        walletId\n      }\n    });\n    this.emitter.emit(\"signedOut\", {\n      walletId\n    });\n  }\n  setupWalletEmitter(module) {\n    const emitter = new EventEmitter();\n    emitter.on(\"signedOut\", () => {\n      this.onWalletSignedOut(module.id);\n    });\n    emitter.on(\"signedIn\", event => {\n      this.onWalletSignedIn(module.id, event);\n    });\n    emitter.on(\"accountsChanged\", ({\n      accounts\n    }) => __awaiter(this, void 0, void 0, function* () {\n      this.emitter.emit(\"accountsChanged\", {\n        walletId: module.id,\n        accounts\n      });\n      if (!accounts.length) {\n        return this.signOutWallet(module.id);\n      }\n      this.store.dispatch({\n        type: \"ACCOUNTS_CHANGED\",\n        payload: {\n          walletId: module.id,\n          accounts\n        }\n      });\n    }));\n    emitter.on(\"networkChanged\", ({\n      networkId\n    }) => {\n      this.emitter.emit(\"networkChanged\", {\n        walletId: module.id,\n        networkId\n      });\n    });\n    emitter.on(\"uriChanged\", ({\n      uri\n    }) => {\n      this.emitter.emit(\"uriChanged\", {\n        walletId: module.id,\n        uri\n      });\n    });\n    return emitter;\n  }\n  validateSignMessageParams({\n    message,\n    nonce,\n    recipient\n  }) {\n    if (!message || message.trim() === \"\") {\n      throw new Error(\"Invalid message. It must be a non-empty string.\");\n    }\n    if (!Buffer.isBuffer(nonce) || nonce.length !== 32) {\n      throw new Error(\"Invalid nonce. It must be a Buffer with a length of 32 bytes.\");\n    }\n    if (!recipient || recipient.trim() === \"\") {\n      throw new Error(\"Invalid recipient. It must be a non-empty string.\");\n    }\n  }\n  decorateWallet(wallet) {\n    const _signIn = wallet.signIn;\n    const _signOut = wallet.signOut;\n    const _signMessage = wallet.signMessage;\n    wallet.signIn = params => __awaiter(this, void 0, void 0, function* () {\n      const accounts = yield _signIn(params);\n      const {\n        contractId,\n        methodNames = []\n      } = params;\n      yield this.onWalletSignedIn(wallet.id, {\n        accounts,\n        contractId,\n        methodNames\n      });\n      return accounts;\n    });\n    wallet.signOut = () => __awaiter(this, void 0, void 0, function* () {\n      yield _signOut();\n      this.onWalletSignedOut(wallet.id);\n    });\n    wallet.signMessage = params => __awaiter(this, void 0, void 0, function* () {\n      if (_signMessage === undefined) {\n        throw Error(`The signMessage method is not supported by ${wallet.metadata.name}`);\n      }\n      this.validateSignMessageParams(params);\n      return yield _signMessage(params);\n    });\n    return wallet;\n  }\n  setupInstance(module) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!module.metadata.available) {\n        const message = module.type === \"injected\" ? \"not installed\" : \"not available\";\n        throw Error(`${module.metadata.name} is ${message}`);\n      }\n      const wallet = Object.assign({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata\n      }, yield module.init({\n        id: module.id,\n        type: module.type,\n        metadata: module.metadata,\n        options: this.options,\n        store: this.store.toReadOnly(),\n        provider: this.provider,\n        emitter: this.setupWalletEmitter(module),\n        logger: new Logger(module.id),\n        storage: new JsonStorage(this.storage, [PACKAGE_NAME, module.id])\n      }));\n      return this.decorateWallet(wallet);\n    });\n  }\n  getModule(id) {\n    return this.modules.find(x => x.id === id);\n  }\n  getWallet(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const module = this.getModule(id);\n      if (!module) {\n        return null;\n      }\n      const {\n        selectedWalletId\n      } = this.store.getState();\n      // If user uninstalled/removed a wallet which was previously signed in with\n      // best we can do is clean up state on our side.\n      if (!module.metadata.available && selectedWalletId) {\n        this.onWalletSignedOut(selectedWalletId);\n        return null;\n      }\n      return yield module.wallet();\n    });\n  }\n  setup() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const modules = [];\n      for (let i = 0; i < this.factories.length; i += 1) {\n        const module = yield this.factories[i]({\n          options: this.options\n        }).catch(err => {\n          logger.log(\"Failed to setup module\");\n          logger.error(err);\n          return null;\n        });\n        // Filter out wallets that aren't available.\n        if (!module) {\n          continue;\n        }\n        // Skip duplicated module.\n        if (modules.some(x => x.id === module.id)) {\n          continue;\n        }\n        modules.push({\n          id: module.id,\n          type: module.type,\n          metadata: module.metadata,\n          wallet: () => __awaiter(this, void 0, void 0, function* () {\n            let instance = this.instances[module.id];\n            if (instance) {\n              return instance;\n            }\n            instance = yield this.setupInstance(module);\n            this.instances[module.id] = instance;\n            return instance;\n          })\n        });\n      }\n      this.modules = modules;\n      const {\n        accounts,\n        contract,\n        selectedWalletId,\n        recentlySignedInWallets\n      } = yield this.resolveStorageState();\n      this.store.dispatch({\n        type: \"SETUP_WALLET_MODULES\",\n        payload: {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        }\n      });\n      for (let i = 0; i < this.modules.length; i++) {\n        if (this.modules[i].type !== \"instant-link\") {\n          continue;\n        }\n        const wallet = yield this.modules[i].wallet();\n        if (!wallet.metadata.runOnStartup) {\n          continue;\n        }\n        try {\n          yield wallet.signIn({\n            contractId: wallet.getContractId()\n          });\n        } catch (err) {\n          logger.error(\"Failed to sign in to wallet. \" + err);\n        }\n      }\n    });\n  }\n}\n\nconst getNetworkPreset = networkId => {\n  switch (networkId) {\n    case \"mainnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.mainnet.near.org\",\n        helperUrl: \"https://helper.mainnet.near.org\",\n        explorerUrl: \"https://nearblocks.io\",\n        indexerUrl: \"https://api.kitwallet.app\"\n      };\n    case \"testnet\":\n      return {\n        networkId,\n        nodeUrl: \"https://rpc.testnet.near.org\",\n        helperUrl: \"https://helper.testnet.near.org\",\n        explorerUrl: \"https://testnet.nearblocks.io\",\n        indexerUrl: \"https://testnet-api.kitwallet.app\"\n      };\n    default:\n      throw Error(`Failed to find config for: '${networkId}'`);\n  }\n};\nconst resolveNetwork = network => {\n  return typeof network === \"string\" ? getNetworkPreset(network) : network;\n};\nconst resolveOptions = params => {\n  const options = {\n    languageCode: params.languageCode || undefined,\n    network: resolveNetwork(params.network),\n    debug: params.debug || false,\n    optimizeWalletOrder: params.optimizeWalletOrder === false ? false : true,\n    randomizeWalletOrder: params.randomizeWalletOrder || false,\n    relayerUrl: params.relayerUrl || undefined\n  };\n  return {\n    options,\n    storage: params.storage || new WebStorageService()\n  };\n};\n\nconst reducer = (state, action) => {\n  logger.log(\"Store Action\", action);\n  switch (action.type) {\n    case \"SETUP_WALLET_MODULES\":\n      {\n        const {\n          modules,\n          accounts,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        } = action.payload;\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === 0\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          modules,\n          accounts: accountStates,\n          contract,\n          selectedWalletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_CONNECTED\":\n      {\n        const {\n          walletId,\n          contract,\n          accounts,\n          recentlySignedInWallets\n        } = action.payload;\n        if (!accounts.length) {\n          return state;\n        }\n        const activeAccountIndex = state.accounts.findIndex(account => account.active);\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: i === (activeAccountIndex > -1 ? activeAccountIndex : 0)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          contract,\n          accounts: accountStates,\n          selectedWalletId: walletId,\n          recentlySignedInWallets\n        });\n      }\n    case \"WALLET_DISCONNECTED\":\n      {\n        const {\n          walletId\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        return Object.assign(Object.assign({}, state), {\n          contract: null,\n          accounts: [],\n          selectedWalletId: null\n        });\n      }\n    case \"ACCOUNTS_CHANGED\":\n      {\n        const {\n          walletId,\n          accounts\n        } = action.payload;\n        if (walletId !== state.selectedWalletId) {\n          return state;\n        }\n        const activeAccount = state.accounts.find(account => account.active);\n        const isActiveAccountRemoved = !accounts.some(account => account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId));\n        const accountStates = accounts.map((account, i) => {\n          return Object.assign(Object.assign({}, account), {\n            active: isActiveAccountRemoved ? i === 0 : account.accountId === (activeAccount === null || activeAccount === void 0 ? void 0 : activeAccount.accountId)\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    case \"SET_ACTIVE_ACCOUNT\":\n      {\n        const {\n          accountId\n        } = action.payload;\n        const accountStates = state.accounts.map(account => {\n          return Object.assign(Object.assign({}, account), {\n            active: account.accountId === accountId\n          });\n        });\n        return Object.assign(Object.assign({}, state), {\n          accounts: accountStates\n        });\n      }\n    default:\n      return state;\n  }\n};\nconst createStore = storage => __awaiter(void 0, void 0, void 0, function* () {\n  const jsonStorage = new JsonStorage(storage, PACKAGE_NAME);\n  const initialState = {\n    modules: [],\n    accounts: [],\n    contract: yield jsonStorage.getItem(CONTRACT),\n    selectedWalletId: yield jsonStorage.getItem(SELECTED_WALLET_ID),\n    recentlySignedInWallets: (yield jsonStorage.getItem(RECENTLY_SIGNED_IN_WALLETS)) || []\n  };\n  const state$ = new rxjs__WEBPACK_IMPORTED_MODULE_4__.BehaviorSubject(initialState);\n  const actions$ = new rxjs__WEBPACK_IMPORTED_MODULE_5__.Subject();\n  actions$.pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_6__.scan)(reducer, initialState)).subscribe(state$);\n  const syncStorage = (prevState, state, storageKey, property) => __awaiter(void 0, void 0, void 0, function* () {\n    if (state[property] === prevState[property]) {\n      return;\n    }\n    if (state[property]) {\n      yield jsonStorage.setItem(storageKey, state[property]);\n      return;\n    }\n    yield jsonStorage.removeItem(storageKey);\n  });\n  let prevState = state$.getValue();\n  state$.subscribe(state => {\n    syncStorage(prevState, state, SELECTED_WALLET_ID, \"selectedWalletId\");\n    syncStorage(prevState, state, CONTRACT, \"contract\");\n    syncStorage(prevState, state, RECENTLY_SIGNED_IN_WALLETS, \"recentlySignedInWallets\");\n    prevState = state;\n  });\n  return {\n    observable: state$,\n    getState: () => state$.getValue(),\n    dispatch: action => actions$.next(action),\n    toReadOnly: () => ({\n      getState: () => state$.getValue(),\n      observable: state$.asObservable()\n    })\n  };\n});\n\nlet walletSelectorInstance = null;\nconst createSelector = (options, store, walletModules, emitter) => {\n  return {\n    options,\n    store: store.toReadOnly(),\n    wallet: id => __awaiter(void 0, void 0, void 0, function* () {\n      const {\n        selectedWalletId\n      } = store.getState();\n      const wallet = yield walletModules.getWallet(id || selectedWalletId);\n      if (!wallet) {\n        if (id) {\n          throw new Error(\"Invalid wallet id\");\n        }\n        throw new Error(\"No wallet selected\");\n      }\n      return wallet;\n    }),\n    setActiveAccount: accountId => {\n      const {\n        accounts\n      } = store.getState();\n      if (!accounts.some(account => account.accountId === accountId)) {\n        throw new Error(\"Invalid account id\");\n      }\n      store.dispatch({\n        type: \"SET_ACTIVE_ACCOUNT\",\n        payload: {\n          accountId\n        }\n      });\n    },\n    isSignedIn() {\n      const {\n        accounts\n      } = store.getState();\n      return Boolean(accounts.length);\n    },\n    on: (eventName, callback) => {\n      return emitter.on(eventName, callback);\n    },\n    off: (eventName, callback) => {\n      emitter.off(eventName, callback);\n    }\n  };\n};\n/**\r\n * Initiates a wallet selector instance\r\n * @param {WalletSelectorParams} params Selector parameters (network, modules...)\r\n * @returns {Promise<WalletSelector>} Returns a WalletSelector object\r\n */\nconst setupWalletSelector = params => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    options,\n    storage\n  } = resolveOptions(params);\n  Logger.debug = options.debug;\n  const emitter = new EventEmitter();\n  const store = yield createStore(storage);\n  const walletModules = new WalletModules({\n    factories: params.modules,\n    storage,\n    options,\n    store,\n    emitter,\n    provider: new Provider(options.network.nodeUrl)\n  });\n  yield walletModules.setup();\n  if (params.allowMultipleSelectors) {\n    return createSelector(options, store, walletModules, emitter);\n  }\n  if (!walletSelectorInstance) {\n    walletSelectorInstance = createSelector(options, store, walletModules, emitter);\n  }\n  return walletSelectorInstance;\n});\n\nconst wait = ms => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\nconst poll = (cb, interval, remaining) => __awaiter(void 0, void 0, void 0, function* () {\n  const result = cb();\n  if (result) {\n    return result;\n  }\n  if (!remaining) {\n    throw new Error(\"Exceeded timeout\");\n  }\n  return wait(interval).then(() => poll(cb, interval, remaining - 1));\n});\nconst waitFor = (cb, opts = {}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    timeout = 100,\n    interval = 50\n  } = opts;\n  return Promise.race([wait(timeout).then(() => {\n    throw new Error(\"Exceeded timeout\");\n  }), poll(cb, interval, Math.floor(timeout / interval))]);\n});\n\nconst getActiveAccount = state => {\n  return state.accounts.find(account => account.active) || null;\n};\n\nvar aCallable$1 = aCallable$9;\nvar toObject$3 = toObject$7;\nvar IndexedObject$1 = indexedObject;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$8;\n\nvar $TypeError$2 = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod$2 = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable$1(callbackfn);\n    var O = toObject$3(that);\n    var self = IndexedObject$1(O);\n    var length = lengthOfArrayLike$5(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw $TypeError$2('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod$2(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod$2(true)\n};\n\nvar fails$c = fails$s;\n\nvar arrayMethodIsStrict$1 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$c(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar $$3 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict = arrayMethodIsStrict$1;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$3({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar anObject$3 = anObject$e;\n\n// `RegExp.prototype.flags` getter implementation\n// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags\nvar regexpFlags$1 = function () {\n  var that = anObject$3(this);\n  var result = '';\n  if (that.hasIndices) result += 'd';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.dotAll) result += 's';\n  if (that.unicode) result += 'u';\n  if (that.unicodeSets) result += 'v';\n  if (that.sticky) result += 'y';\n  return result;\n};\n\nvar fails$b = fails$s;\nvar global$a = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError\nvar $RegExp$2 = global$a.RegExp;\n\nvar UNSUPPORTED_Y$2 = fails$b(function () {\n  var re = $RegExp$2('a', 'y');\n  re.lastIndex = 2;\n  return re.exec('abcd') != null;\n});\n\n// UC Browser bug\n// https://github.com/zloirock/core-js/issues/1008\nvar MISSED_STICKY = UNSUPPORTED_Y$2 || fails$b(function () {\n  return !$RegExp$2('a', 'y').sticky;\n});\n\nvar BROKEN_CARET = UNSUPPORTED_Y$2 || fails$b(function () {\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687\n  var re = $RegExp$2('^r', 'gy');\n  re.lastIndex = 2;\n  return re.exec('str') != null;\n});\n\nvar regexpStickyHelpers = {\n  BROKEN_CARET: BROKEN_CARET,\n  MISSED_STICKY: MISSED_STICKY,\n  UNSUPPORTED_Y: UNSUPPORTED_Y$2\n};\n\nvar fails$a = fails$s;\nvar global$9 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('.', 's') -> /./s and it causes SyntaxError\nvar $RegExp$1 = global$9.RegExp;\n\nvar regexpUnsupportedDotAll = fails$a(function () {\n  var re = $RegExp$1('.', 's');\n  return !(re.dotAll && re.exec('\\n') && re.flags === 's');\n});\n\nvar fails$9 = fails$s;\nvar global$8 = global$t;\n\n// babel-minify and Closure Compiler transpiles RegExp('(?<a>b)', 'g') -> /(?<a>b)/g and it causes SyntaxError\nvar $RegExp = global$8.RegExp;\n\nvar regexpUnsupportedNcg = fails$9(function () {\n  var re = $RegExp('(?<a>b)', 'g');\n  return re.exec('b').groups.a !== 'b' ||\n    'b'.replace(re, '$<a>c') !== 'bc';\n});\n\n/* eslint-disable regexp/no-empty-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing */\n/* eslint-disable regexp/no-useless-quantifier -- testing */\nvar call$6 = functionCall;\nvar uncurryThis$8 = functionUncurryThis;\nvar toString$2 = toString$5;\nvar regexpFlags = regexpFlags$1;\nvar stickyHelpers$1 = regexpStickyHelpers;\nvar shared = shared$4.exports;\nvar create$1 = objectCreate;\nvar getInternalState$3 = internalState.get;\nvar UNSUPPORTED_DOT_ALL = regexpUnsupportedDotAll;\nvar UNSUPPORTED_NCG = regexpUnsupportedNcg;\n\nvar nativeReplace = shared('native-string-replace', String.prototype.replace);\nvar nativeExec = RegExp.prototype.exec;\nvar patchedExec = nativeExec;\nvar charAt$2 = uncurryThis$8(''.charAt);\nvar indexOf = uncurryThis$8(''.indexOf);\nvar replace = uncurryThis$8(''.replace);\nvar stringSlice$2 = uncurryThis$8(''.slice);\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/;\n  var re2 = /b*/g;\n  call$6(nativeExec, re1, 'a');\n  call$6(nativeExec, re2, 'a');\n  return re1.lastIndex !== 0 || re2.lastIndex !== 0;\n})();\n\nvar UNSUPPORTED_Y$1 = stickyHelpers$1.BROKEN_CARET;\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1 || UNSUPPORTED_DOT_ALL || UNSUPPORTED_NCG;\n\nif (PATCH) {\n  patchedExec = function exec(string) {\n    var re = this;\n    var state = getInternalState$3(re);\n    var str = toString$2(string);\n    var raw = state.raw;\n    var result, reCopy, lastIndex, match, i, object, group;\n\n    if (raw) {\n      raw.lastIndex = re.lastIndex;\n      result = call$6(patchedExec, raw, str);\n      re.lastIndex = raw.lastIndex;\n      return result;\n    }\n\n    var groups = state.groups;\n    var sticky = UNSUPPORTED_Y$1 && re.sticky;\n    var flags = call$6(regexpFlags, re);\n    var source = re.source;\n    var charsAdded = 0;\n    var strCopy = str;\n\n    if (sticky) {\n      flags = replace(flags, 'y', '');\n      if (indexOf(flags, 'g') === -1) {\n        flags += 'g';\n      }\n\n      strCopy = stringSlice$2(str, re.lastIndex);\n      // Support anchored sticky behavior.\n      if (re.lastIndex > 0 && (!re.multiline || re.multiline && charAt$2(str, re.lastIndex - 1) !== '\\n')) {\n        source = '(?: ' + source + ')';\n        strCopy = ' ' + strCopy;\n        charsAdded++;\n      }\n      // ^(? + rx + ) is needed, in combination with some str slicing, to\n      // simulate the 'y' flag.\n      reCopy = new RegExp('^(?:' + source + ')', flags);\n    }\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + source + '$(?!\\\\s)', flags);\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;\n\n    match = call$6(nativeExec, sticky ? reCopy : re, strCopy);\n\n    if (sticky) {\n      if (match) {\n        match.input = stringSlice$2(match.input, charsAdded);\n        match[0] = stringSlice$2(match[0], charsAdded);\n        match.index = re.lastIndex;\n        re.lastIndex += match[0].length;\n      } else re.lastIndex = 0;\n    } else if (UPDATES_LAST_INDEX_WRONG && match) {\n      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      call$6(nativeReplace, match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    if (match && groups) {\n      match.groups = object = create$1(null);\n      for (i = 0; i < groups.length; i++) {\n        group = groups[i];\n        object[group[0]] = match[group[1]];\n      }\n    }\n\n    return match;\n  };\n}\n\nvar regexpExec$3 = patchedExec;\n\nvar $$2 = _export;\nvar exec$1 = regexpExec$3;\n\n// `RegExp.prototype.exec` method\n// https://tc39.es/ecma262/#sec-regexp.prototype.exec\n$$2({ target: 'RegExp', proto: true, forced: /./.exec !== exec$1 }, {\n  exec: exec$1\n});\n\n/* eslint-disable no-useless-escape */\n// https://github.com/DamonOehlman/detect-browser/blob/master/src/index.ts\nconst SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nconst userAgentRules = [[\"aol\", /AOLShield\\/([0-9\\._]+)/], [\"edge\", /Edge\\/([0-9\\._]+)/], [\"edge-ios\", /EdgiOS\\/([0-9\\._]+)/], [\"yandexbrowser\", /YaBrowser\\/([0-9\\._]+)/], [\"kakaotalk\", /KAKAOTALK\\s([0-9\\.]+)/], [\"samsung\", /SamsungBrowser\\/([0-9\\.]+)/], [\"silk\", /\\bSilk\\/([0-9._-]+)\\b/], [\"miui\", /MiuiBrowser\\/([0-9\\.]+)$/], [\"beaker\", /BeakerBrowser\\/([0-9\\.]+)/], [\"edge-chromium\", /EdgA?\\/([0-9\\.]+)/], [\"chromium-webview\", /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"chrome\", /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/], [\"phantomjs\", /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/], [\"crios\", /CriOS\\/([0-9\\.]+)(:?\\s|$)/], [\"firefox\", /Firefox\\/([0-9\\.]+)(?:\\s|$)/], [\"fxios\", /FxiOS\\/([0-9\\.]+)/], [\"opera-mini\", /Opera Mini.*Version\\/([0-9\\.]+)/], [\"opera\", /Opera\\/([0-9\\.]+)(?:\\s|$)/], [\"opera\", /OPR\\/([0-9\\.]+)(:?\\s|$)/], [\"pie\", /^Microsoft Pocket Internet Explorer\\/(\\d+\\.\\d+)$/], [\"pie\", /^Mozilla\\/\\d\\.\\d+\\s\\(compatible;\\s(?:MSP?IE|MSInternet Explorer) (\\d+\\.\\d+);.*Windows CE.*\\)$/], [\"netfront\", /^Mozilla\\/\\d\\.\\d+.*NetFront\\/(\\d.\\d)/], [\"ie\", /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/], [\"ie\", /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/], [\"ie\", /MSIE\\s(7\\.0)/], [\"bb10\", /BB10;\\sTouch.*Version\\/([0-9\\.]+)/], [\"android\", /Android\\s([0-9\\.]+)/], [\"ios\", /Version\\/([0-9\\._]+).*Mobile.*Safari.*/], [\"safari\", /Version\\/([0-9\\._]+).*Safari/], [\"facebook\", /FB[AS]V\\/([0-9\\.]+)/], [\"instagram\", /Instagram\\s([0-9\\.]+)/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Mobile/], [\"ios-webview\", /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/], [\"curl\", /^curl\\/([0-9\\.]+)$/], [\"searchbot\", SEARCHBOX_UA_REGEX]];\nconst matchUserAgent = ua => {\n  return ua !== \"\" && userAgentRules.reduce((matched, [browser, regex]) => {\n    if (matched) {\n      return matched;\n    }\n    const uaMatch = regex.exec(ua);\n    return !!uaMatch && [browser, uaMatch];\n  }, false);\n};\nconst isCurrentBrowserSupported = supportedBrowser => {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const matchedRule = matchUserAgent(navigator.userAgent);\n  if (!matchedRule) {\n    return false;\n  }\n  const [name] = matchedRule;\n  if (name === \"searchbot\") {\n    return false;\n  }\n  return !!supportedBrowser.find(item => item === name);\n};\n\n// eslint-disable-next-line es-x/no-typed-arrays -- safe\nvar arrayBufferNative = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';\n\nvar NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;\nvar DESCRIPTORS$2 = descriptors;\nvar global$7 = global$t;\nvar isCallable$2 = isCallable$n;\nvar isObject$4 = isObject$d;\nvar hasOwn$1 = hasOwnProperty_1;\nvar classof$4 = classof$9;\nvar tryToString = tryToString$5;\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$8;\nvar defineBuiltIn$2 = defineBuiltIn$8;\nvar defineProperty$1 = objectDefineProperty.f;\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar getPrototypeOf$1 = objectGetPrototypeOf;\nvar setPrototypeOf$3 = objectSetPrototypeOf;\nvar wellKnownSymbol$2 = wellKnownSymbol$j;\nvar uid = uid$3;\nvar InternalStateModule$2 = internalState;\n\nvar enforceInternalState$1 = InternalStateModule$2.enforce;\nvar getInternalState$2 = InternalStateModule$2.get;\nvar Int8Array$4 = global$7.Int8Array;\nvar Int8ArrayPrototype$1 = Int8Array$4 && Int8Array$4.prototype;\nvar Uint8ClampedArray$1 = global$7.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray$1 && Uint8ClampedArray$1.prototype;\nvar TypedArray$1 = Int8Array$4 && getPrototypeOf$1(Int8Array$4);\nvar TypedArrayPrototype$1 = Int8ArrayPrototype$1 && getPrototypeOf$1(Int8ArrayPrototype$1);\nvar ObjectPrototype$1 = Object.prototype;\nvar TypeError$1 = global$7.TypeError;\n\nvar TO_STRING_TAG = wellKnownSymbol$2('toStringTag');\nvar TYPED_ARRAY_TAG$1 = uid('TYPED_ARRAY_TAG');\nvar TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';\n// Fixing native typed arrays in Opera Presto crashes the browser, see #595\nvar NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER$1 && !!setPrototypeOf$3 && classof$4(global$7.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQUIRED = false;\nvar NAME, Constructor, Prototype;\n\nvar TypedArrayConstructorsList = {\n  Int8Array: 1,\n  Uint8Array: 1,\n  Uint8ClampedArray: 1,\n  Int16Array: 2,\n  Uint16Array: 2,\n  Int32Array: 4,\n  Uint32Array: 4,\n  Float32Array: 4,\n  Float64Array: 8\n};\n\nvar BigIntArrayConstructorsList = {\n  BigInt64Array: 8,\n  BigUint64Array: 8\n};\n\nvar isView = function isView(it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return klass === 'DataView'\n    || hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar getTypedArrayConstructor = function (it) {\n  var proto = getPrototypeOf$1(it);\n  if (!isObject$4(proto)) return;\n  var state = getInternalState$2(proto);\n  return (state && hasOwn$1(state, TYPED_ARRAY_CONSTRUCTOR)) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n};\n\nvar isTypedArray$1 = function (it) {\n  if (!isObject$4(it)) return false;\n  var klass = classof$4(it);\n  return hasOwn$1(TypedArrayConstructorsList, klass)\n    || hasOwn$1(BigIntArrayConstructorsList, klass);\n};\n\nvar aTypedArray$4 = function (it) {\n  if (isTypedArray$1(it)) return it;\n  throw TypeError$1('Target is not a typed array');\n};\n\nvar aTypedArrayConstructor$2 = function (C) {\n  if (isCallable$2(C) && (!setPrototypeOf$3 || isPrototypeOf$1(TypedArray$1, C))) return C;\n  throw TypeError$1(tryToString(C) + ' is not a typed array constructor');\n};\n\nvar exportTypedArrayMethod$4 = function (KEY, property, forced, options) {\n  if (!DESCRIPTORS$2) return;\n  if (forced) for (var ARRAY in TypedArrayConstructorsList) {\n    var TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor.prototype, KEY)) try {\n      delete TypedArrayConstructor.prototype[KEY];\n    } catch (error) {\n      // old WebKit bug - some methods are non-configurable\n      try {\n        TypedArrayConstructor.prototype[KEY] = property;\n      } catch (error2) { /* empty */ }\n    }\n  }\n  if (!TypedArrayPrototype$1[KEY] || forced) {\n    defineBuiltIn$2(TypedArrayPrototype$1, KEY, forced ? property\n      : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype$1[KEY] || property, options);\n  }\n};\n\nvar exportTypedArrayStaticMethod$1 = function (KEY, property, forced) {\n  var ARRAY, TypedArrayConstructor;\n  if (!DESCRIPTORS$2) return;\n  if (setPrototypeOf$3) {\n    if (forced) for (ARRAY in TypedArrayConstructorsList) {\n      TypedArrayConstructor = global$7[ARRAY];\n      if (TypedArrayConstructor && hasOwn$1(TypedArrayConstructor, KEY)) try {\n        delete TypedArrayConstructor[KEY];\n      } catch (error) { /* empty */ }\n    }\n    if (!TypedArray$1[KEY] || forced) {\n      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable\n      try {\n        return defineBuiltIn$2(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && TypedArray$1[KEY] || property);\n      } catch (error) { /* empty */ }\n    } else return;\n  }\n  for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global$7[ARRAY];\n    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n      defineBuiltIn$2(TypedArrayConstructor, KEY, property);\n    }\n  }\n};\n\nfor (NAME in TypedArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n  else NATIVE_ARRAY_BUFFER_VIEWS$2 = false;\n}\n\nfor (NAME in BigIntArrayConstructorsList) {\n  Constructor = global$7[NAME];\n  Prototype = Constructor && Constructor.prototype;\n  if (Prototype) enforceInternalState$1(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n}\n\n// WebKit bug - typed arrays constructors prototype is Object.prototype\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !isCallable$2(TypedArray$1) || TypedArray$1 === Function.prototype) {\n  // eslint-disable-next-line no-shadow -- safe\n  TypedArray$1 = function TypedArray() {\n    throw TypeError$1('Incorrect invocation');\n  };\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME], TypedArray$1);\n  }\n}\n\nif (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype$1) {\n  TypedArrayPrototype$1 = TypedArray$1.prototype;\n  if (NATIVE_ARRAY_BUFFER_VIEWS$2) for (NAME in TypedArrayConstructorsList) {\n    if (global$7[NAME]) setPrototypeOf$3(global$7[NAME].prototype, TypedArrayPrototype$1);\n  }\n}\n\n// WebKit bug - one more object in Uint8ClampedArray prototype chain\nif (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf$1(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {\n  setPrototypeOf$3(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);\n}\n\nif (DESCRIPTORS$2 && !hasOwn$1(TypedArrayPrototype$1, TO_STRING_TAG)) {\n  TYPED_ARRAY_TAG_REQUIRED = true;\n  defineProperty$1(TypedArrayPrototype$1, TO_STRING_TAG, { get: function () {\n    return isObject$4(this) ? this[TYPED_ARRAY_TAG$1] : undefined;\n  } });\n  for (NAME in TypedArrayConstructorsList) if (global$7[NAME]) {\n    createNonEnumerableProperty$3(global$7[NAME], TYPED_ARRAY_TAG$1, NAME);\n  }\n}\n\nvar arrayBufferViewCore = {\n  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,\n  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG$1,\n  aTypedArray: aTypedArray$4,\n  aTypedArrayConstructor: aTypedArrayConstructor$2,\n  exportTypedArrayMethod: exportTypedArrayMethod$4,\n  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod$1,\n  getTypedArrayConstructor: getTypedArrayConstructor,\n  isView: isView,\n  isTypedArray: isTypedArray$1,\n  TypedArray: TypedArray$1,\n  TypedArrayPrototype: TypedArrayPrototype$1\n};\n\n/* eslint-disable no-new -- required for testing */\n\nvar global$6 = global$t;\nvar fails$8 = fails$s;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$2;\nvar NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;\n\nvar ArrayBuffer$3 = global$6.ArrayBuffer;\nvar Int8Array$3 = global$6.Int8Array;\n\nvar typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$8(function () {\n  Int8Array$3(1);\n}) || !fails$8(function () {\n  new Int8Array$3(-1);\n}) || !checkCorrectnessOfIteration(function (iterable) {\n  new Int8Array$3();\n  new Int8Array$3(null);\n  new Int8Array$3(1.5);\n  new Int8Array$3(iterable);\n}, true) || fails$8(function () {\n  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill\n  return new Int8Array$3(new ArrayBuffer$3(2), 1, undefined).length !== 1;\n});\n\nvar bind$1 = functionBindContext;\nvar call$5 = functionCall;\nvar aConstructor = aConstructor$2;\nvar toObject$2 = toObject$7;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$8;\nvar getIterator = getIterator$2;\nvar getIteratorMethod = getIteratorMethod$3;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;\n\nvar typedArrayFrom$2 = function from(source /* , mapfn, thisArg */) {\n  var C = aConstructor(this);\n  var O = toObject$2(source);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  var iteratorMethod = getIteratorMethod(O);\n  var i, length, result, step, iterator, next;\n  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {\n    iterator = getIterator(O, iteratorMethod);\n    next = iterator.next;\n    O = [];\n    while (!(step = call$5(next, iterator)).done) {\n      O.push(step.value);\n    }\n  }\n  if (mapping && argumentsLength > 2) {\n    mapfn = bind$1(mapfn, arguments[2]);\n  }\n  length = lengthOfArrayLike$4(O);\n  result = new (aTypedArrayConstructor$1(C))(length);\n  for (i = 0; length > i; i++) {\n    result[i] = mapping ? mapfn(O[i], i) : O[i];\n  }\n  return result;\n};\n\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1 = typedArrayConstructorsRequireWrappers;\nvar exportTypedArrayStaticMethod = arrayBufferViewCore.exportTypedArrayStaticMethod;\nvar typedArrayFrom$1 = typedArrayFrom$2;\n\n// `%TypedArray%.from` method\n// https://tc39.es/ecma262/#sec-%typedarray%.from\nexportTypedArrayStaticMethod('from', typedArrayFrom$1, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS$1);\n\nvar defineBuiltIn$1 = defineBuiltIn$8;\n\nvar defineBuiltIns$1 = function (target, src, options) {\n  for (var key in src) defineBuiltIn$1(target, key, src[key], options);\n  return target;\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$6;\nvar toLength$4 = toLength$6;\n\nvar $RangeError$2 = RangeError;\n\n// `ToIndex` abstract operation\n// https://tc39.es/ecma262/#sec-toindex\nvar toIndex$2 = function (it) {\n  if (it === undefined) return 0;\n  var number = toIntegerOrInfinity$3(it);\n  var length = toLength$4(number);\n  if (number !== length) throw $RangeError$2('Wrong length or index');\n  return length;\n};\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar $Array$2 = Array;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor$2 = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nvar pack = function (number, mantissaLength, bytes) {\n  var buffer = $Array$2(bytes);\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;\n  var index = 0;\n  var exponent, mantissa, c;\n  number = abs(number);\n  // eslint-disable-next-line no-self-compare -- NaN check\n  if (number != number || number === Infinity) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    mantissa = number != number ? 1 : 0;\n    exponent = eMax;\n  } else {\n    exponent = floor$2(log(number) / LN2);\n    c = pow(2, -exponent);\n    if (number * c < 1) {\n      exponent--;\n      c *= 2;\n    }\n    if (exponent + eBias >= 1) {\n      number += rt / c;\n    } else {\n      number += rt * pow(2, 1 - eBias);\n    }\n    if (number * c >= 2) {\n      exponent++;\n      c /= 2;\n    }\n    if (exponent + eBias >= eMax) {\n      mantissa = 0;\n      exponent = eMax;\n    } else if (exponent + eBias >= 1) {\n      mantissa = (number * c - 1) * pow(2, mantissaLength);\n      exponent = exponent + eBias;\n    } else {\n      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);\n      exponent = 0;\n    }\n  }\n  while (mantissaLength >= 8) {\n    buffer[index++] = mantissa & 255;\n    mantissa /= 256;\n    mantissaLength -= 8;\n  }\n  exponent = exponent << mantissaLength | mantissa;\n  exponentLength += mantissaLength;\n  while (exponentLength > 0) {\n    buffer[index++] = exponent & 255;\n    exponent /= 256;\n    exponentLength -= 8;\n  }\n  buffer[--index] |= sign * 128;\n  return buffer;\n};\n\nvar unpack = function (buffer, mantissaLength) {\n  var bytes = buffer.length;\n  var exponentLength = bytes * 8 - mantissaLength - 1;\n  var eMax = (1 << exponentLength) - 1;\n  var eBias = eMax >> 1;\n  var nBits = exponentLength - 7;\n  var index = bytes - 1;\n  var sign = buffer[index--];\n  var exponent = sign & 127;\n  var mantissa;\n  sign >>= 7;\n  while (nBits > 0) {\n    exponent = exponent * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  mantissa = exponent & (1 << -nBits) - 1;\n  exponent >>= -nBits;\n  nBits += mantissaLength;\n  while (nBits > 0) {\n    mantissa = mantissa * 256 + buffer[index--];\n    nBits -= 8;\n  }\n  if (exponent === 0) {\n    exponent = 1 - eBias;\n  } else if (exponent === eMax) {\n    return mantissa ? NaN : sign ? -Infinity : Infinity;\n  } else {\n    mantissa = mantissa + pow(2, mantissaLength);\n    exponent = exponent - eBias;\n  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);\n};\n\nvar ieee754 = {\n  pack: pack,\n  unpack: unpack\n};\n\nvar toObject$1 = toObject$7;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$8;\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nvar arrayFill$1 = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject$1(this);\n  var length = lengthOfArrayLike$3(O);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex$2(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex$2(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$1 = function (object, key, value) {\n  var propertyKey = toPropertyKey$1(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar toAbsoluteIndex$1 = toAbsoluteIndex$4;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$8;\nvar createProperty = createProperty$1;\n\nvar $Array$1 = Array;\nvar max = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$2(O);\n  var k = toAbsoluteIndex$1(start, length);\n  var fin = toAbsoluteIndex$1(end === undefined ? length : end, length);\n  var result = $Array$1(max(fin - k, 0));\n  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\nvar global$5 = global$t;\nvar uncurryThis$7 = functionUncurryThis;\nvar DESCRIPTORS$1 = descriptors;\nvar NATIVE_ARRAY_BUFFER = arrayBufferNative;\nvar FunctionName = functionName;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$8;\nvar defineBuiltIns = defineBuiltIns$1;\nvar fails$7 = fails$s;\nvar anInstance$1 = anInstance$3;\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$6;\nvar toLength$3 = toLength$6;\nvar toIndex$1 = toIndex$2;\nvar IEEE754 = ieee754;\nvar getPrototypeOf = objectGetPrototypeOf;\nvar setPrototypeOf$2 = objectSetPrototypeOf;\nvar getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar defineProperty = objectDefineProperty.f;\nvar arrayFill = arrayFill$1;\nvar arraySlice$3 = arraySliceSimple;\nvar setToStringTag = setToStringTag$4;\nvar InternalStateModule$1 = internalState;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nvar CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;\nvar getInternalState$1 = InternalStateModule$1.get;\nvar setInternalState$1 = InternalStateModule$1.set;\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH$1 = 'Wrong length';\nvar WRONG_INDEX = 'Wrong index';\nvar NativeArrayBuffer = global$5[ARRAY_BUFFER];\nvar $ArrayBuffer = NativeArrayBuffer;\nvar ArrayBufferPrototype$1 = $ArrayBuffer && $ArrayBuffer[PROTOTYPE];\nvar $DataView = global$5[DATA_VIEW];\nvar DataViewPrototype$1 = $DataView && $DataView[PROTOTYPE];\nvar ObjectPrototype = Object.prototype;\nvar Array$1 = global$5.Array;\nvar RangeError$3 = global$5.RangeError;\nvar fill = uncurryThis$7(arrayFill);\nvar reverse = uncurryThis$7([].reverse);\n\nvar packIEEE754 = IEEE754.pack;\nvar unpackIEEE754 = IEEE754.unpack;\n\nvar packInt8 = function (number) {\n  return [number & 0xFF];\n};\n\nvar packInt16 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF];\n};\n\nvar packInt32 = function (number) {\n  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];\n};\n\nvar unpackInt32 = function (buffer) {\n  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];\n};\n\nvar packFloat32 = function (number) {\n  return packIEEE754(number, 23, 4);\n};\n\nvar packFloat64 = function (number) {\n  return packIEEE754(number, 52, 8);\n};\n\nvar addGetter$1 = function (Constructor, key) {\n  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState$1(this)[key]; } });\n};\n\nvar get = function (view, count, index, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = arraySlice$3(bytes, start, start + count);\n  return isLittleEndian ? pack : reverse(pack);\n};\n\nvar set = function (view, count, index, conversion, value, isLittleEndian) {\n  var intIndex = toIndex$1(index);\n  var store = getInternalState$1(view);\n  if (intIndex + count > store.byteLength) throw RangeError$3(WRONG_INDEX);\n  var bytes = getInternalState$1(store.buffer).bytes;\n  var start = intIndex + store.byteOffset;\n  var pack = conversion(+value);\n  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];\n};\n\nif (!NATIVE_ARRAY_BUFFER) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance$1(this, ArrayBufferPrototype$1);\n    var byteLength = toIndex$1(length);\n    setInternalState$1(this, {\n      bytes: fill(Array$1(byteLength), 0),\n      byteLength: byteLength\n    });\n    if (!DESCRIPTORS$1) this.byteLength = byteLength;\n  };\n\n  ArrayBufferPrototype$1 = $ArrayBuffer[PROTOTYPE];\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance$1(this, DataViewPrototype$1);\n    anInstance$1(buffer, ArrayBufferPrototype$1);\n    var bufferLength = getInternalState$1(buffer).byteLength;\n    var offset = toIntegerOrInfinity$2(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError$3('Wrong offset');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength$3(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError$3(WRONG_LENGTH$1);\n    setInternalState$1(this, {\n      buffer: buffer,\n      byteLength: byteLength,\n      byteOffset: offset\n    });\n    if (!DESCRIPTORS$1) {\n      this.buffer = buffer;\n      this.byteLength = byteLength;\n      this.byteOffset = offset;\n    }\n  };\n\n  DataViewPrototype$1 = $DataView[PROTOTYPE];\n\n  if (DESCRIPTORS$1) {\n    addGetter$1($ArrayBuffer, 'byteLength');\n    addGetter$1($DataView, 'buffer');\n    addGetter$1($DataView, 'byteLength');\n    addGetter$1($DataView, 'byteOffset');\n  }\n\n  defineBuiltIns(DataViewPrototype$1, {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packInt8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);\n    }\n  });\n} else {\n  var INCORRECT_ARRAY_BUFFER_NAME = PROPER_FUNCTION_NAME && NativeArrayBuffer.name !== ARRAY_BUFFER;\n  /* eslint-disable no-new -- required for testing */\n  if (!fails$7(function () {\n    NativeArrayBuffer(1);\n  }) || !fails$7(function () {\n    new NativeArrayBuffer(-1);\n  }) || fails$7(function () {\n    new NativeArrayBuffer();\n    new NativeArrayBuffer(1.5);\n    new NativeArrayBuffer(NaN);\n    return INCORRECT_ARRAY_BUFFER_NAME && !CONFIGURABLE_FUNCTION_NAME;\n  })) {\n  /* eslint-enable no-new -- required for testing */\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance$1(this, ArrayBufferPrototype$1);\n      return new NativeArrayBuffer(toIndex$1(length));\n    };\n\n    $ArrayBuffer[PROTOTYPE] = ArrayBufferPrototype$1;\n\n    for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) {\n        createNonEnumerableProperty$2($ArrayBuffer, key, NativeArrayBuffer[key]);\n      }\n    }\n\n    ArrayBufferPrototype$1.constructor = $ArrayBuffer;\n  } else if (INCORRECT_ARRAY_BUFFER_NAME && CONFIGURABLE_FUNCTION_NAME) {\n    createNonEnumerableProperty$2(NativeArrayBuffer, 'name', ARRAY_BUFFER);\n  }\n\n  // WebKit bug - the same parent prototype for typed arrays and data view\n  if (setPrototypeOf$2 && getPrototypeOf(DataViewPrototype$1) !== ObjectPrototype) {\n    setPrototypeOf$2(DataViewPrototype$1, ObjectPrototype);\n  }\n\n  // iOS Safari 7.x bug\n  var testView = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = uncurryThis$7(DataViewPrototype$1.setInt8);\n  testView.setInt8(0, 2147483648);\n  testView.setInt8(1, 2147483649);\n  if (testView.getInt8(0) || !testView.getInt8(1)) defineBuiltIns(DataViewPrototype$1, {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8(this, byteOffset, value << 24 >> 24);\n    }\n  }, { unsafe: true });\n}\n\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\n\nvar arrayBuffer = {\n  ArrayBuffer: $ArrayBuffer,\n  DataView: $DataView\n};\n\nvar $$1 = _export;\nvar uncurryThis$6 = functionUncurryThis;\nvar fails$6 = fails$s;\nvar ArrayBufferModule$1 = arrayBuffer;\nvar anObject$2 = anObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$4;\nvar toLength$2 = toLength$6;\nvar speciesConstructor$1 = speciesConstructor$3;\n\nvar ArrayBuffer$2 = ArrayBufferModule$1.ArrayBuffer;\nvar DataView$2 = ArrayBufferModule$1.DataView;\nvar DataViewPrototype = DataView$2.prototype;\nvar un$ArrayBufferSlice = uncurryThis$6(ArrayBuffer$2.prototype.slice);\nvar getUint8 = uncurryThis$6(DataViewPrototype.getUint8);\nvar setUint8 = uncurryThis$6(DataViewPrototype.setUint8);\n\nvar INCORRECT_SLICE = fails$6(function () {\n  return !new ArrayBuffer$2(2).slice(1, undefined).byteLength;\n});\n\n// `ArrayBuffer.prototype.slice` method\n// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice\n$$1({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {\n  slice: function slice(start, end) {\n    if (un$ArrayBufferSlice && end === undefined) {\n      return un$ArrayBufferSlice(anObject$2(this), start); // FF fix\n    }\n    var length = anObject$2(this).byteLength;\n    var first = toAbsoluteIndex(start, length);\n    var fin = toAbsoluteIndex(end === undefined ? length : end, length);\n    var result = new (speciesConstructor$1(this, ArrayBuffer$2))(toLength$2(fin - first));\n    var viewSource = new DataView$2(this);\n    var viewTarget = new DataView$2(result);\n    var index = 0;\n    while (first < fin) {\n      setUint8(viewTarget, index++, getUint8(viewSource, first++));\n    } return result;\n  }\n});\n\nvar typedArrayConstructor = {exports: {}};\n\nvar isObject$3 = isObject$d;\n\nvar floor$1 = Math.floor;\n\n// `IsIntegralNumber` abstract operation\n// https://tc39.es/ecma262/#sec-isintegralnumber\n// eslint-disable-next-line es-x/no-number-isinteger -- safe\nvar isIntegralNumber$1 = Number.isInteger || function isInteger(it) {\n  return !isObject$3(it) && isFinite(it) && floor$1(it) === it;\n};\n\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$6;\n\nvar $RangeError$1 = RangeError;\n\nvar toPositiveInteger$1 = function (it) {\n  var result = toIntegerOrInfinity$1(it);\n  if (result < 0) throw $RangeError$1(\"The argument can't be less than 0\");\n  return result;\n};\n\nvar toPositiveInteger = toPositiveInteger$1;\n\nvar $RangeError = RangeError;\n\nvar toOffset$2 = function (it, BYTES) {\n  var offset = toPositiveInteger(it);\n  if (offset % BYTES) throw $RangeError('Wrong offset');\n  return offset;\n};\n\nvar classof$3 = classofRaw$1;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es-x/no-array-isarray -- safe\nvar isArray$1 = Array.isArray || function isArray(argument) {\n  return classof$3(argument) == 'Array';\n};\n\nvar isArray = isArray$1;\nvar isConstructor = isConstructor$2;\nvar isObject$2 = isObject$d;\nvar wellKnownSymbol$1 = wellKnownSymbol$j;\n\nvar SPECIES$1 = wellKnownSymbol$1('species');\nvar $Array = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;\n    else if (isObject$2(C)) {\n      C = C[SPECIES$1];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array : C;\n};\n\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$1 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\nvar bind = functionBindContext;\nvar uncurryThis$5 = functionUncurryThis;\nvar IndexedObject = indexedObject;\nvar toObject = toObject$7;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$8;\nvar arraySpeciesCreate = arraySpeciesCreate$1;\n\nvar push$1 = uncurryThis$5([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod$1 = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_REJECT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that);\n    var length = lengthOfArrayLike$1(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push$1(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push$1(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod$1(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod$1(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod$1(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod$1(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod$1(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod$1(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod$1(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod$1(7)\n};\n\nvar isCallable$1 = isCallable$n;\nvar isObject$1 = isObject$d;\nvar setPrototypeOf$1 = objectSetPrototypeOf;\n\n// makes subclassing work correct for wrapped built-ins\nvar inheritIfRequired$1 = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf$1 &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    isCallable$1(NewTarget = dummy.constructor) &&\n    NewTarget !== Wrapper &&\n    isObject$1(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf$1($this, NewTargetPrototype);\n  return $this;\n};\n\nvar $ = _export;\nvar global$4 = global$t;\nvar call$4 = functionCall;\nvar DESCRIPTORS = descriptors;\nvar TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;\nvar ArrayBufferViewCore$4 = arrayBufferViewCore;\nvar ArrayBufferModule = arrayBuffer;\nvar anInstance = anInstance$3;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$8;\nvar isIntegralNumber = isIntegralNumber$1;\nvar toLength$1 = toLength$6;\nvar toIndex = toIndex$2;\nvar toOffset$1 = toOffset$2;\nvar toPropertyKey = toPropertyKey$4;\nvar hasOwn = hasOwnProperty_1;\nvar classof$2 = classof$9;\nvar isObject = isObject$d;\nvar isSymbol = isSymbol$3;\nvar create = objectCreate;\nvar isPrototypeOf = objectIsPrototypeOf;\nvar setPrototypeOf = objectSetPrototypeOf;\nvar getOwnPropertyNames = objectGetOwnPropertyNames.f;\nvar typedArrayFrom = typedArrayFrom$2;\nvar forEach = arrayIteration.forEach;\nvar setSpecies = setSpecies$2;\nvar definePropertyModule = objectDefineProperty;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar InternalStateModule = internalState;\nvar inheritIfRequired = inheritIfRequired$1;\n\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar enforceInternalState = InternalStateModule.enforce;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar round = Math.round;\nvar RangeError$2 = global$4.RangeError;\nvar ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;\nvar ArrayBufferPrototype = ArrayBuffer$1.prototype;\nvar DataView$1 = ArrayBufferModule.DataView;\nvar NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;\nvar TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;\nvar TypedArray = ArrayBufferViewCore$4.TypedArray;\nvar TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;\nvar aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;\nvar isTypedArray = ArrayBufferViewCore$4.isTypedArray;\nvar BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\nvar WRONG_LENGTH = 'Wrong length';\n\nvar fromList = function (C, list) {\n  aTypedArrayConstructor(C);\n  var index = 0;\n  var length = list.length;\n  var result = new C(length);\n  while (length > index) result[index] = list[index++];\n  return result;\n};\n\nvar addGetter = function (it, key) {\n  nativeDefineProperty(it, key, { get: function () {\n    return getInternalState(this)[key];\n  } });\n};\n\nvar isArrayBuffer = function (it) {\n  var klass;\n  return isPrototypeOf(ArrayBufferPrototype, it) || (klass = classof$2(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';\n};\n\nvar isTypedArrayIndex = function (target, key) {\n  return isTypedArray(target)\n    && !isSymbol(key)\n    && key in target\n    && isIntegralNumber(+key)\n    && key >= 0;\n};\n\nvar wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {\n  key = toPropertyKey(key);\n  return isTypedArrayIndex(target, key)\n    ? createPropertyDescriptor(2, target[key])\n    : nativeGetOwnPropertyDescriptor(target, key);\n};\n\nvar wrappedDefineProperty = function defineProperty(target, key, descriptor) {\n  key = toPropertyKey(key);\n  if (isTypedArrayIndex(target, key)\n    && isObject(descriptor)\n    && hasOwn(descriptor, 'value')\n    && !hasOwn(descriptor, 'get')\n    && !hasOwn(descriptor, 'set')\n    // TODO: add validation descriptor w/o calling accessors\n    && !descriptor.configurable\n    && (!hasOwn(descriptor, 'writable') || descriptor.writable)\n    && (!hasOwn(descriptor, 'enumerable') || descriptor.enumerable)\n  ) {\n    target[key] = descriptor.value;\n    return target;\n  } return nativeDefineProperty(target, key, descriptor);\n};\n\nif (DESCRIPTORS) {\n  if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;\n    definePropertyModule.f = wrappedDefineProperty;\n    addGetter(TypedArrayPrototype, 'buffer');\n    addGetter(TypedArrayPrototype, 'byteOffset');\n    addGetter(TypedArrayPrototype, 'byteLength');\n    addGetter(TypedArrayPrototype, 'length');\n  }\n\n  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {\n    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,\n    defineProperty: wrappedDefineProperty\n  });\n\n  typedArrayConstructor.exports = function (TYPE, wrapper, CLAMPED) {\n    var BYTES = TYPE.match(/\\d+$/)[0] / 8;\n    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + TYPE;\n    var SETTER = 'set' + TYPE;\n    var NativeTypedArrayConstructor = global$4[CONSTRUCTOR_NAME];\n    var TypedArrayConstructor = NativeTypedArrayConstructor;\n    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;\n    var exported = {};\n\n    var getter = function (that, index) {\n      var data = getInternalState(that);\n      return data.view[GETTER](index * BYTES + data.byteOffset, true);\n    };\n\n    var setter = function (that, index, value) {\n      var data = getInternalState(that);\n      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;\n      data.view[SETTER](index * BYTES + data.byteOffset, value, true);\n    };\n\n    var addElement = function (that, index) {\n      nativeDefineProperty(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n\n    if (!NATIVE_ARRAY_BUFFER_VIEWS) {\n      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {\n        anInstance(that, TypedArrayConstructorPrototype);\n        var index = 0;\n        var byteOffset = 0;\n        var buffer, byteLength, length;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new ArrayBuffer$1(byteLength);\n        } else if (isArrayBuffer(data)) {\n          buffer = data;\n          byteOffset = toOffset$1(offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError$2(WRONG_LENGTH);\n            byteLength = $len - byteOffset;\n            if (byteLength < 0) throw RangeError$2(WRONG_LENGTH);\n          } else {\n            byteLength = toLength$1($length) * BYTES;\n            if (byteLength + byteOffset > $len) throw RangeError$2(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (isTypedArray(data)) {\n          return fromList(TypedArrayConstructor, data);\n        } else {\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }\n        setInternalState(that, {\n          buffer: buffer,\n          byteOffset: byteOffset,\n          byteLength: byteLength,\n          length: length,\n          view: new DataView$1(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);\n    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {\n      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {\n        anInstance(dummy, TypedArrayConstructorPrototype);\n        return inheritIfRequired(function () {\n          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));\n          if (isArrayBuffer(data)) return $length !== undefined\n            ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length)\n            : typedArrayOffset !== undefined\n              ? new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES))\n              : new NativeTypedArrayConstructor(data);\n          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);\n          return call$4(typedArrayFrom, TypedArrayConstructor, data);\n        }(), dummy, TypedArrayConstructor);\n      });\n\n      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);\n      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {\n        if (!(key in TypedArrayConstructor)) {\n          createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);\n        }\n      });\n      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;\n    }\n\n    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);\n    }\n\n    enforceInternalState(TypedArrayConstructorPrototype).TypedArrayConstructor = TypedArrayConstructor;\n\n    if (TYPED_ARRAY_TAG) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);\n    }\n\n    var FORCED = TypedArrayConstructor != NativeTypedArrayConstructor;\n\n    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;\n\n    $({ global: true, constructor: true, forced: FORCED, sham: !NATIVE_ARRAY_BUFFER_VIEWS }, exported);\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {\n      createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {\n      createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);\n    }\n\n    setSpecies(CONSTRUCTOR_NAME);\n  };\n} else typedArrayConstructor.exports = function () { /* empty */ };\n\nvar createTypedArrayConstructor = typedArrayConstructor.exports;\n\n// `Uint8Array` constructor\n// https://tc39.es/ecma262/#sec-typedarray-objects\ncreateTypedArrayConstructor('Uint8', function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n\nvar toPrimitive = toPrimitive$2;\n\nvar $TypeError$1 = TypeError;\n\n// `ToBigInt` abstract operation\n// https://tc39.es/ecma262/#sec-tobigint\nvar toBigInt$1 = function (argument) {\n  var prim = toPrimitive(argument, 'number');\n  if (typeof prim == 'number') throw $TypeError$1(\"Can't convert number to bigint\");\n  // eslint-disable-next-line es-x/no-bigint -- safe\n  return BigInt(prim);\n};\n\nvar ArrayBufferViewCore$3 = arrayBufferViewCore;\nvar $fill = arrayFill$1;\nvar toBigInt = toBigInt$1;\nvar classof$1 = classof$9;\nvar call$3 = functionCall;\nvar uncurryThis$4 = functionUncurryThis;\nvar fails$5 = fails$s;\n\nvar aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;\nvar exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;\nvar slice = uncurryThis$4(''.slice);\n\n// V8 ~ Chrome < 59, Safari < 14.1, FF < 55, Edge <=18\nvar CONVERSION_BUG = fails$5(function () {\n  var count = 0;\n  // eslint-disable-next-line es-x/no-typed-arrays -- safe\n  new Int8Array(2).fill({ valueOf: function () { return count++; } });\n  return count !== 1;\n});\n\n// `%TypedArray%.prototype.fill` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill\nexportTypedArrayMethod$3('fill', function fill(value /* , start, end */) {\n  var length = arguments.length;\n  aTypedArray$3(this);\n  var actualValue = slice(classof$1(this), 0, 3) === 'Big' ? toBigInt(value) : +value;\n  return call$3($fill, this, actualValue, length > 1 ? arguments[1] : undefined, length > 2 ? arguments[2] : undefined);\n}, CONVERSION_BUG);\n\nvar global$3 = global$t;\nvar call$2 = functionCall;\nvar ArrayBufferViewCore$2 = arrayBufferViewCore;\nvar lengthOfArrayLike = lengthOfArrayLike$8;\nvar toOffset = toOffset$2;\nvar toIndexedObject = toObject$7;\nvar fails$4 = fails$s;\n\nvar RangeError$1 = global$3.RangeError;\nvar Int8Array$2 = global$3.Int8Array;\nvar Int8ArrayPrototype = Int8Array$2 && Int8Array$2.prototype;\nvar $set = Int8ArrayPrototype && Int8ArrayPrototype.set;\nvar aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;\nvar exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;\n\nvar WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS = !fails$4(function () {\n  // eslint-disable-next-line es-x/no-typed-arrays -- required for testing\n  var array = new Uint8ClampedArray(2);\n  call$2($set, array, { length: 1, 0: 3 }, 1);\n  return array[1] !== 3;\n});\n\n// https://bugs.chromium.org/p/v8/issues/detail?id=11294 and other\nvar TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore$2.NATIVE_ARRAY_BUFFER_VIEWS && fails$4(function () {\n  var array = new Int8Array$2(2);\n  array.set(1);\n  array.set('2', 1);\n  return array[0] !== 0 || array[1] !== 2;\n});\n\n// `%TypedArray%.prototype.set` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set\nexportTypedArrayMethod$2('set', function set(arrayLike /* , offset */) {\n  aTypedArray$2(this);\n  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n  var src = toIndexedObject(arrayLike);\n  if (WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS) return call$2($set, this, src, offset);\n  var length = this.length;\n  var len = lengthOfArrayLike(src);\n  var index = 0;\n  if (len + offset > length) throw RangeError$1('Wrong length');\n  while (index < len) this[offset + index] = src[index++];\n}, !WORKS_WITH_OBJECTS_AND_GEERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);\n\nvar arraySlice$2 = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice$2(array, 0, middle), comparefn),\n    mergeSort(arraySlice$2(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar userAgent$1 = engineUserAgent;\n\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent = engineUserAgent;\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar global$2 = global$t;\nvar uncurryThis$3 = functionUncurryThis;\nvar fails$3 = fails$s;\nvar aCallable = aCallable$9;\nvar internalSort = arraySort;\nvar ArrayBufferViewCore$1 = arrayBufferViewCore;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;\nvar exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;\nvar Uint16Array = global$2.Uint16Array;\nvar un$Sort = Uint16Array && uncurryThis$3(Uint16Array.prototype.sort);\n\n// WebKit\nvar ACCEPT_INCORRECT_ARGUMENTS = !!un$Sort && !(fails$3(function () {\n  un$Sort(new Uint16Array(2), null);\n}) && fails$3(function () {\n  un$Sort(new Uint16Array(2), {});\n}));\n\nvar STABLE_SORT = !!un$Sort && !fails$3(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 74;\n  if (FF) return FF < 67;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 602;\n\n  var array = new Uint16Array(516);\n  var expected = Array(516);\n  var index, mod;\n\n  for (index = 0; index < 516; index++) {\n    mod = index % 4;\n    array[index] = 515 - index;\n    expected[index] = index - 2 * mod + 3;\n  }\n\n  un$Sort(array, function (a, b) {\n    return (a / 4 | 0) - (b / 4 | 0);\n  });\n\n  for (index = 0; index < 516; index++) {\n    if (array[index] !== expected[index]) return true;\n  }\n});\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (y !== y) return -1;\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (x !== x) return 1;\n    if (x === 0 && y === 0) return 1 / x > 0 && 1 / y < 0 ? 1 : -1;\n    return x > y;\n  };\n};\n\n// `%TypedArray%.prototype.sort` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort\nexportTypedArrayMethod$1('sort', function sort(comparefn) {\n  if (comparefn !== undefined) aCallable(comparefn);\n  if (STABLE_SORT) return un$Sort(this, comparefn);\n\n  return internalSort(aTypedArray$1(this), getSortCompare(comparefn));\n}, !STABLE_SORT || ACCEPT_INCORRECT_ARGUMENTS);\n\nvar global$1 = global$t;\nvar apply$1 = functionApply;\nvar ArrayBufferViewCore = arrayBufferViewCore;\nvar fails$2 = fails$s;\nvar arraySlice$1 = arraySlice$5;\n\nvar Int8Array$1 = global$1.Int8Array;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $toLocaleString = [].toLocaleString;\n\n// iOS Safari 6.x fails here\nvar TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails$2(function () {\n  $toLocaleString.call(new Int8Array$1(1));\n});\n\nvar FORCED = fails$2(function () {\n  return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();\n}) || !fails$2(function () {\n  Int8Array$1.prototype.toLocaleString.call([1, 2]);\n});\n\n// `%TypedArray%.prototype.toLocaleString` method\n// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring\nexportTypedArrayMethod('toLocaleString', function toLocaleString() {\n  return apply$1(\n    $toLocaleString,\n    TO_LOCALE_STRING_BUG ? arraySlice$1(aTypedArray(this)) : aTypedArray(this),\n    arraySlice$1(arguments)\n  );\n}, FORCED);\n\nclass Payload {\n  constructor(data) {\n    // The tag's value is a hardcoded value as per\n    // defined in the NEP [NEP413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)\n    this.tag = 2147484061;\n    this.message = data.message;\n    this.nonce = data.nonce;\n    this.recipient = data.recipient;\n    if (data.callbackUrl) {\n      this.callbackUrl = data.callbackUrl;\n    }\n  }\n}\nconst payloadSchema = new Map([[Payload, {\n  kind: \"struct\",\n  fields: [[\"tag\", \"u32\"], [\"message\", \"string\"], [\"nonce\", [32]], [\"recipient\", \"string\"], [\"callbackUrl\", {\n    kind: \"option\",\n    type: \"string\"\n  }]]\n}]]);\nconst serializeNep413 = signMessageParams => {\n  const payload = new Payload(Object.assign({}, signMessageParams));\n  return Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload));\n};\n\nconst verifySignature = ({\n  publicKey,\n  signature,\n  message,\n  nonce,\n  recipient,\n  callbackUrl\n}) => {\n  // Reconstruct the payload that was **actually signed**\n  const payload = new Payload({\n    message,\n    nonce,\n    recipient,\n    callbackUrl\n  });\n  // Serialize payload based on payloadSchema\n  const borshPayload = (0,borsh__WEBPACK_IMPORTED_MODULE_2__.serialize)(payloadSchema, payload);\n  // Hash the payload as in the NEP0413 referenced example\n  // https://github.com/near/NEPs/blob/master/neps/nep-0413.md#references\n  // https://github.com/gagdiez/near-login/blob/main/authenticate/wallet-authenticate.js#L21\n  const hashedPayload = Uint8Array.from(js_sha256__WEBPACK_IMPORTED_MODULE_3__.sha256.array(borshPayload));\n  // Convert real signature to buffer base64\n  const realSignature = Buffer.from(signature, \"base64\");\n  const pk = near_api_js__WEBPACK_IMPORTED_MODULE_0__.utils.PublicKey.from(publicKey);\n  // Verify the signature\n  return pk.verify(hashedPayload, realSignature);\n};\nconst fetchAllUserKeys = ({\n  accountId,\n  network,\n  publicKey\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const provider = new near_api_js__WEBPACK_IMPORTED_MODULE_0__.providers.JsonRpcProvider({\n    url: network.nodeUrl\n  });\n  const key = yield provider.query({\n    request_type: \"view_access_key\",\n    account_id: accountId,\n    finality: \"final\",\n    public_key: publicKey\n  });\n  return key;\n});\nconst verifyFullKeyBelongsToUser = ({\n  publicKey,\n  accountId,\n  network\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    permission\n  } = yield fetchAllUserKeys({\n    accountId,\n    network,\n    publicKey\n  });\n  return permission === \"FullAccess\";\n});\n\n// TODO: Remove from `core-js@4` since it's moved to entry points\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIn = defineBuiltIn$8;\nvar regexpExec$2 = regexpExec$3;\nvar fails$1 = fails$s;\nvar wellKnownSymbol = wellKnownSymbol$j;\nvar createNonEnumerableProperty = createNonEnumerableProperty$8;\n\nvar SPECIES = wellKnownSymbol('species');\nvar RegExpPrototype = RegExp.prototype;\n\nvar fixRegexpWellKnownSymbolLogic = function (KEY, exec, FORCED, SHAM) {\n  var SYMBOL = wellKnownSymbol(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails$1(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails$1(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n\n    if (KEY === 'split') {\n      // We can't use real regex here since it causes deoptimization\n      // and serious performance degradation in V8\n      // https://github.com/zloirock/core-js/issues/306\n      re = {};\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n      re.flags = '';\n      re[SYMBOL] = /./[SYMBOL];\n    }\n\n    re.exec = function () { execCalled = true; return null; };\n\n    re[SYMBOL]('');\n    return !execCalled;\n  });\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    FORCED\n  ) {\n    var uncurriedNativeRegExpMethod = uncurryThis$2(/./[SYMBOL]);\n    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {\n      var uncurriedNativeMethod = uncurryThis$2(nativeMethod);\n      var $exec = regexp.exec;\n      if ($exec === regexpExec$2 || $exec === RegExpPrototype.exec) {\n        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n          // The native String method already delegates to @@method (this\n          // polyfilled function), leasing to infinite recursion.\n          // We avoid it by directly calling the native @@method method.\n          return { done: true, value: uncurriedNativeRegExpMethod(regexp, str, arg2) };\n        }\n        return { done: true, value: uncurriedNativeMethod(str, regexp, arg2) };\n      }\n      return { done: false };\n    });\n\n    defineBuiltIn(String.prototype, KEY, methods[0]);\n    defineBuiltIn(RegExpPrototype, SYMBOL, methods[1]);\n  }\n\n  if (SHAM) createNonEnumerableProperty(RegExpPrototype[SYMBOL], 'sham', true);\n};\n\nvar uncurryThis$1 = functionUncurryThis;\nvar toIntegerOrInfinity = toIntegerOrInfinity$6;\nvar toString$1 = toString$5;\nvar requireObjectCoercible$1 = requireObjectCoercible$6;\n\nvar charAt$1 = uncurryThis$1(''.charAt);\nvar charCodeAt = uncurryThis$1(''.charCodeAt);\nvar stringSlice$1 = uncurryThis$1(''.slice);\n\nvar createMethod = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$1(requireObjectCoercible$1($this));\n    var position = toIntegerOrInfinity(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$1(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice$1(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod(true)\n};\n\nvar charAt = stringMultibyte.charAt;\n\n// `AdvanceStringIndex` abstract operation\n// https://tc39.es/ecma262/#sec-advancestringindex\nvar advanceStringIndex$1 = function (S, index, unicode) {\n  return index + (unicode ? charAt(S, index).length : 1);\n};\n\nvar call$1 = functionCall;\nvar anObject$1 = anObject$e;\nvar isCallable = isCallable$n;\nvar classof = classofRaw$1;\nvar regexpExec$1 = regexpExec$3;\n\nvar $TypeError = TypeError;\n\n// `RegExpExec` abstract operation\n// https://tc39.es/ecma262/#sec-regexpexec\nvar regexpExecAbstract = function (R, S) {\n  var exec = R.exec;\n  if (isCallable(exec)) {\n    var result = call$1(exec, R, S);\n    if (result !== null) anObject$1(result);\n    return result;\n  }\n  if (classof(R) === 'RegExp') return call$1(regexpExec$1, R, S);\n  throw $TypeError('RegExp#exec called on incompatible receiver');\n};\n\nvar apply = functionApply;\nvar call = functionCall;\nvar uncurryThis = functionUncurryThis;\nvar fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;\nvar isRegExp = isRegexp;\nvar anObject = anObject$e;\nvar requireObjectCoercible = requireObjectCoercible$6;\nvar speciesConstructor = speciesConstructor$3;\nvar advanceStringIndex = advanceStringIndex$1;\nvar toLength = toLength$6;\nvar toString = toString$5;\nvar getMethod = getMethod$4;\nvar arraySlice = arraySliceSimple;\nvar callRegExpExec = regexpExecAbstract;\nvar regexpExec = regexpExec$3;\nvar stickyHelpers = regexpStickyHelpers;\nvar fails = fails$s;\n\nvar UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;\nvar MAX_UINT32 = 0xFFFFFFFF;\nvar min = Math.min;\nvar $push = [].push;\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis($push);\nvar stringSlice = uncurryThis(''.slice);\n\n// Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n// Weex JS has frozen built-in prototypes, so use try / catch wrapper\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {\n  // eslint-disable-next-line regexp/no-empty-group -- required for testing\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';\n});\n\n// @@split logic\nfixRegExpWellKnownSymbolLogic('split', function (SPLIT, nativeSplit, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'.split(/(b)*/)[1] == 'c' ||\n    // eslint-disable-next-line regexp/no-empty-group -- required for testing\n    'test'.split(/(?:)/, -1).length != 4 ||\n    'ab'.split(/(?:ab)*/).length != 2 ||\n    '.'.split(/(.?)(.?)/).length != 4 ||\n    // eslint-disable-next-line regexp/no-empty-capturing-group, regexp/no-empty-group -- required for testing\n    '.'.split(/()()/).length > 1 ||\n    ''.split(/.?/).length\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = toString(requireObjectCoercible(this));\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (separator === undefined) return [string];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) {\n        return call(nativeSplit, string, separator, lim);\n      }\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = call(regexpExec, separatorCopy, string)) {\n        lastIndex = separatorCopy.lastIndex;\n        if (lastIndex > lastLastIndex) {\n          push(output, stringSlice(string, lastLastIndex, match.index));\n          if (match.length > 1 && match.index < string.length) apply($push, output, arraySlice(match, 1));\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= lim) break;\n        }\n        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string.length) {\n        if (lastLength || !exec(separatorCopy, '')) push(output, '');\n      } else push(output, stringSlice(string, lastLastIndex));\n      return output.length > lim ? arraySlice(output, 0, lim) : output;\n    };\n  // Chakra, V8\n  } else if ('0'.split(undefined, 0).length) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : call(nativeSplit, this, separator, limit);\n    };\n  } else internalSplit = nativeSplit;\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.es/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = requireObjectCoercible(this);\n      var splitter = separator == undefined ? undefined : getMethod(separator, SPLIT);\n      return splitter\n        ? call(splitter, separator, O, limit)\n        : call(internalSplit, toString(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (string, limit) {\n      var rx = anObject(this);\n      var S = toString(string);\n      var res = maybeCallNative(internalSplit, rx, S, limit, internalSplit !== nativeSplit);\n\n      if (res.done) return res.value;\n\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (UNSUPPORTED_Y ? 'g' : 'y');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;\n        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? stringSlice(S, q) : S);\n        var e;\n        if (\n          z === null ||\n          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          push(A, stringSlice(S, p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            push(A, z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      push(A, stringSlice(S, p));\n      return A;\n    }\n  ];\n}, !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC, UNSUPPORTED_Y);\n\nvar modal$b = {\n\twallet: {\n\t\tconnectYourWallet: \"Connect Your Wallet\",\n\t\twhatIsAWallet: \"What is a Wallet?\",\n\t\tsecureAndManage: \"Secure & Manage Your Digital Assets\",\n\t\tsafelyStore: \"Safely store and transfer your crypto and NFTs.\",\n\t\tlogInToAny: \"Log In to Any NEAR App\",\n\t\tnoNeedToCreate: \"No need to create new accounts or credentials. Connect your wallet and you are good to go!\",\n\t\tgetAWallet: \"Get a Wallet\",\n\t\tuseAWallet: \"Use a wallet to secure and manage your NEAR assets, and to log in to any NEAR app without the need for usernames and passwords.\",\n\t\tconnectionFailed: \"Connection Failed\",\n\t\tconnectionSuccessful: \"Connection Successful\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"Connecting to\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirm the connection in the extension window\",\n\t\t\tbrowser: \"Confirm the connection in the wallet after redirect\",\n\t\t\thardware: \"Confirm the connection in the ledger device\",\n\t\t\tbridge: \"Confirm the connection in the wallet\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Connect with Ledger\",\n\t\tmakeSureYourLedger: \"Make sure your Ledger is connected securely, and that the NEAR app is open on your device\",\n\t\t\"continue\": \"Continue\",\n\t\tspecifyHDPath: \"Specify HD Path\",\n\t\tenterYourPreferredHDPath: \"Enter your preferred HD path, then scan for any active accounts.\",\n\t\tscan: \"Scan\",\n\t\tretry: \"Retry\",\n\t\tledgerIsNotAvailable: \"Ledger is not available\",\n\t\taccessDeniedToUseLedgerDevice: \"Access denied to use Ledger device\",\n\t\tnoAccountsFound: \"No Accounts Found\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tconnecting1Account: \"Connecting 1 Account\",\n\t\tcantFindAnyAccount: \"Can't find any account associated with this Ledger. Please create a new NEAR account on\",\n\t\torConnectAnAnotherLedger: \"or connect an another Ledger.\",\n\t\tconnecting: \"Connecting\",\n\t\tofAccounts: \"of Accounts\",\n\t\tfailedToAutomatically: \"Failed to automatically find account id. Provide it manually:\",\n\t\toverviewTheListOfAuthorized: \"Overview the list of authorized account(s), complete sign in by clicking the button below.\",\n\t\tfinish: \"Finish\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"You'll need to install\",\n\t\ttoContinueAfterInstalling: \"to continue. After installing\",\n\t\trefreshThePage: \"refresh the page.\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copied to clipboard\",\n\t\tfailedToCopy: \"Failed to copy to clipboard\",\n\t\tscanWithYourMobile: \"Scan with Your Mobile Device\",\n\t\tcopyToClipboard: \" Copy to clipboard\",\n\t\tpreferTheOfficial: \"Prefer the official dialogue of\",\n\t\topen: \"Open\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Choose a Wallet\",\n\t\ttransferYourAccounts: \"Transfer Your Accounts\",\n\t\tselectAWallet: \"Select a wallet that fits your needs and supports your connected accounts.\",\n\t\tselectYourAccounts: \"Select Your Accounts\",\n\t\tafterDecide: \"After you decide on a wallet, you can select which accounts you want to transfer.\",\n\t\tdisclaimer: \"You wonât be able to transfer accounts that have never been funded or used on NEAR.\",\n\t\twarning: \"does not support account export at this time. Please select another wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Select Accounts to Transfer\",\n\t\t\tbutton: \"Continue\",\n\t\t\tdeselectAll: \"Deselect All\",\n\t\t\tselectAll: \"Select All\",\n\t\t\tunavailable: \"Transfer Unavailable\",\n\t\t\terror: \"Account does not exist\",\n\t\t\twarningLedger: \"Ledger support required\",\n\t\t\tnoBalance: \"Account not funded\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Copy Temporary Password\",\n\t\t\tdesc: \"Youâll need to enter this password when you begin exporting your accounts to a different wallet.\",\n\t\t\tbutton: \"Continue\",\n\t\t\ttransferButton: \"Transfer Accounts\",\n\t\t\tlabel: \"Click to Copy\",\n\t\t\tcheckLabel: \"I copied or wrote down the password\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"Complete the Transfer\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Once import part of process is completed from selected wallet, press button to complete the transfer process.\",\n\t\t\tstartOverButton: \"Start Over\",\n\t\t\tbutton: \"Complete\"\n\t\t}\n\t}\n};\nvar component$1 = {\n\tclickToCopy: {\n\t\tlabel: \"Copied\",\n\t\ttooltip: \"Click to copy\"\n\t}\n};\nvar en = {\n\tmodal: modal$b,\n\tcomponent: component$1\n};\n\nvar modal$a = {\n\twallet: {\n\t\tconnectYourWallet: \"Conecta Tu Billetera\",\n\t\twhatIsAWallet: \"Â¿Que es una Billetera?\",\n\t\tsecureAndManage: \"Resguarda y Administrar Tus Activos Digitales\",\n\t\tsafelyStore: \"Almacena de forma segura y transfiere tus cryptos y NFT's\",\n\t\tlogInToAny: \"Inicie sesiÃ³n en Cualquier Aplicacion NEAR\",\n\t\tnoNeedToCreate: \"No es necesario crear nuevas cuentas o credenciales, Â¡Conecta tu billetera y listo!\",\n\t\tgetAWallet: \"Obten una Billetera\",\n\t\tuseAWallet: \"Usa tu Billetera para resguardar y administrar tus activos en NEAR, e Iniciar sesiÃ³n en cualquier aplicacion NEAR sin la necesidad de nombres de usuarios y contraseÃ±as\",\n\t\tconnectionFailed: \"ConexiÃ³n Fallida\",\n\t\tconnectionSuccessful: \"ConexiÃ³n Existosa\",\n\t\tconnected: \"Conectado\",\n\t\tconnectingTo: \"Conectando a \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Confirme la conexiÃ³n en la ventana de extensiÃ³n\",\n\t\t\tbrowser: \"Confirme la conexiÃ³n en la billetera despuÃ©s de la redirecciÃ³n\",\n\t\t\thardware: \"Confirme la conexiÃ³n en el dispositivo de libro mayor\",\n\t\t\tbridge: \"Confirmar la conexiÃ³n en la billetera\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Conectar con Ledger\",\n\t\tmakeSureYourLedger: \"AsegÃºrese de que su ledger estÃ¡ conectada de forma segura y que la aplicacion NEAR estÃ© abierta en su dispositivo\",\n\t\t\"continue\": \"Continuar\",\n\t\tspecifyHDPath: \"Especifique la ruta HD\",\n\t\tenterYourPreferredHDPath: \"Ingrese su ruta HD prerida,y luego busque cualquier cuenta activa.\",\n\t\tscan: \"Escanear\",\n\t\tretry: \"Reintentar\",\n\t\tledgerIsNotAvailable: \"El Ledger no estÃ¡ disponible\",\n\t\taccessDeniedToUseLedgerDevice: \"Acceso denegado para usar el dispositivo ledger\",\n\t\tnoAccountsFound: \"No se encontraron cuentas\",\n\t\tselectYourAccounts: \"Selecciona tus cuentas\",\n\t\tconnecting1Account: \"Conectando a 1 cuenta\",\n\t\tcantFindAnyAccount: \"No se pudo encontrar ninguna cuenta asociada con este ledger,Por favor crea una nueva cuenta en NEAR\",\n\t\torConnectAnAnotherLedger: \"o conecta otro ledger\",\n\t\tconnecting: \"Conectando\",\n\t\tofAccounts: \"de Cuentas\",\n\t\tfailedToAutomatically: \"No se pudo encontrar automaticamente el id de la cuenta,Ingresalo manualmente:\",\n\t\toverviewTheListOfAuthorized: \"Revise la lista de las cuentas autorizadas,Complete el inicio de sesiÃ³n haciedo click a countinuacion.\",\n\t\tfinish: \"Finalizar\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"TendrÃ¡s que instalar\",\n\t\ttoContinueAfterInstalling: \"Para continuar, Despues de instalar\",\n\t\trefreshThePage: \"Recarga la pagina\",\n\t\topen: \"Abrir\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Copiado al Portapapeles\",\n\t\tfailedToCopy: \"FallÃ³ la copia al Portapapeles\",\n\t\tscanWithYourMobile: \"Busca con tu dispositivo movil\",\n\t\tcopyToClipboard: \" Copiar al Portapapeles\",\n\t\tpreferTheOfficial: \"Â¿Prefires el diÃ¡logo oficial de\",\n\t\topen: \"Abrir\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar es = {\n\tmodal: modal$a\n};\n\nvar modal$9 = {\n\twallet: {\n\t\tconnectYourWallet: \"è¿æ¥ä½ çé±å\",\n\t\twhatIsAWallet: \"ä»ä¹æ¯é±åï¼\",\n\t\tsecureAndManage: \"ä¿æ¤åç®¡çä½ çæ°å­èµäº§\",\n\t\tsafelyStore: \"å®å¨å­å¨åè½¬ç§»ä½ çå å¯è´§å¸åNFT\",\n\t\tlogInToAny: \"ç»å½ä»»ä½ NEAR åºç¨\",\n\t\tnoNeedToCreate: \"ä¸éè¦åå»ºæ°è´¦æ·æå¯ç ãè¿æ¥ä½ çé±åï¼å³å¯å¼å§ä½¿ç¨ï¼\",\n\t\tgetAWallet: \"è·åæ°è´¦æ·\",\n\t\tuseAWallet: \"ä½¿ç¨é±åæ¥ä¿æ¤åç®¡çä½ ç NEAR èµäº§ï¼æ éç¨æ·ååå¯ç å³å¯ç»å½ä»»ä½ NEAR åºç¨\",\n\t\tconnectionFailed: \"è¿æ¥å¤±è´¥\",\n\t\tconnectionSuccessful: \"è¿æ¥æå\",\n\t\tconnected: \"å·²è¿æ¥\",\n\t\tconnectingTo: \"æ­£å¨è¿æ¥\"\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"è¿æ¥ Ledger\",\n\t\tmakeSureYourLedger: \"ç¡®ä¿ä½ ç Ledger å·²ç»å®å¨è¿æ¥ï¼å¹¶ä¸ NEAR åºç¨å·²ç»å¨ä½ è®¾å¤ä¸æå¼\",\n\t\t\"continue\": \"ç»§ç»­\",\n\t\tspecifyHDPath: \"æå® HD è·¯å¾\",\n\t\tenterYourPreferredHDPath: \"è¾å¥ä½ åå¥½ç HD è·¯å¾ï¼ç¶åä¸ºä»»ææ´»è·è´¦æ·æ«ç \",\n\t\tscan: \"æ«ç \",\n\t\tretry: \"éè¯\",\n\t\tledgerIsNotAvailable: \"Ledger ä¸å¯ç¨\",\n\t\taccessDeniedToUseLedgerDevice: \"è®¿é® Ledger è®¾å¤è¢«æç»\",\n\t\tnoAccountsFound: \"æ²¡ææ¾å°è´¦æ·\",\n\t\tselectYourAccounts: \"éæ©ä½ çè´¦æ·\",\n\t\tconnecting1Account: \"æ­£å¨è¿æ¥1ä¸ªè´¦æ·\",\n\t\tcantFindAnyAccount: \"æ²¡ææ¾å°ä»»ä½ä¸è¿ä¸ª Ledger ç¸å³èçè´¦æ·ãè¯·åå»ºæ°è´¦æ·äº\",\n\t\t\"orConnectAnAnotherLedger.\": \"æè¿æ¥å¦ä¸ä¸ª Ledger\",\n\t\tconnecting: \"æ­£å¨è¿æ¥\",\n\t\tofAccounts: \"ä¸ªè´¦æ·\",\n\t\tfailedToAutomatically: \"æ æ³èªå¨æ¾å°è´¦æ·IDï¼è¯·ä¸»å¨æä¾ï¼\",\n\t\toverviewTheListOfAuthorized: \"è¯·æ¥çå·²ææçè´¦æ·åè¡¨ï¼ç¹å»ä»¥ä¸æé®å®æç»å½\",\n\t\tfinish: \"å®æ\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"ä½ å°éè¦å®è£\",\n\t\ttoContinueAfterInstalling: \"ä»¥ç»§ç»­ãå®è£å®\",\n\t\trefreshThePage: \"è¯·å·æ°é¡µé¢\",\n\t\topen: \"æå¼\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"å¤å¶å°äºåªè´´æ¿\",\n\t\tfailedToCopy: \"å¤å¶å°åªè´´æ¿å¤±è´¥\",\n\t\tscanWithYourMobile: \"ç¨ä½ çç§»å¨è®¾å¤æ«ç \",\n\t\tcopyToClipboard: \" å¤å¶å°åªè´´æ¿\",\n\t\tpreferTheOfficial: \"å¸æä½¿ç¨å®æ¹å¯¹è¯æ¡äº\",\n\t\topen: \"æå¼\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar zh = {\n\tmodal: modal$9\n};\n\nvar modal$8 = {\n\twallet: {\n\t\tconnectYourWallet: \"Ð¡Ð²ÑÑÐ¶ÐµÑÐµ Ð²Ð°ÑÐ¸Ñ ÐÐ¾ÑÑÑÐµÐ¹Ð»\",\n\t\twhatIsAWallet: \"ÐÐ°ÐºÐ²Ð¾ Ðµ ÐÐ¾ÑÑÑÐµÐ¹Ð»?\",\n\t\tsecureAndManage: \"ÐÐ°ÑÐ¸ÑÐµÑÐµ Ð¸ ÑÐ¿ÑÐ°Ð²Ð»ÑÐ²Ð°Ð¹ÑÐµ Ð´Ð¸Ð³Ð¸ÑÐ°Ð»Ð½Ð¸ÑÐµ ÑÐ¸ Ð°ÐºÑÐ¸Ð²Ð¸\",\n\t\tsafelyStore: \"Ð¡ÑÑÑÐ°Ð½ÑÐ²Ð°Ð¹ÑÐµ Ð¸ Ð¿ÑÐµÑÐ²ÑÑÐ»ÑÐ¹ÑÐµ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ Ð²Ð°ÑÐ¸ÑÐµ ÐºÑÐ¸Ð¿ÑÐ¾ Ð¸ NFT.\",\n\t\tlogInToAny: \"ÐÐ·Ð¿Ð¾Ð»Ð·Ð²Ð°Ð¹ÑÐµ Ð²ÑÑÐºÐ¾ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð½Ð° NEAR\",\n\t\tnoNeedToCreate: \"ÐÑÐ¼Ð° Ð½ÑÐ¶Ð´Ð° Ð´Ð° ÑÑÐ·Ð´Ð°Ð²Ð°ÑÐµ Ð½Ð¾Ð²Ð¸ Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸. Ð¡Ð²ÑÑÐ¶ÐµÑÐµ Ð¿Ð¾ÑÑÑÐµÐ¹Ð»Ð° ÑÐ¸ Ð¸ ÑÑÐµ Ð³Ð¾ÑÐ¾Ð²Ð¸!\",\n\t\tgetAWallet: \"Ð¡ÑÐ·Ð´Ð°Ð¹ÑÐµ ÐÐ¾ÑÑÑÐµÐ¹Ð»\",\n\t\tuseAWallet: \"ÐÐ·Ð¿Ð¾Ð»Ð·Ð²Ð°Ð¹ÑÐµ Ð¿Ð¾ÑÑÑÐµÐ¹Ð»Ð°, Ð·Ð° Ð´Ð° Ð·Ð°ÑÐ¸ÑÐ¸ÑÐµ Ð¸ ÑÐ¿ÑÐ°Ð²Ð»ÑÐ²Ð°ÑÐµ Ð°ÐºÑÐ¸Ð²Ð¸ÑÐµ ÑÐ¸ Ð½Ð° NEAR ÐºÐ°ÐºÑÐ¾ Ð¸ Ð´Ð° Ð¸Ð·Ð¿Ð¾Ð»Ð·Ð²Ð°ÑÐµ Ð²ÑÑÐºÐ¾ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð½Ð° NEAR Ð±ÐµÐ· Ð½ÑÐ¶Ð´Ð° Ð¾Ñ Ð¿Ð¾ÑÑÐµÐ±Ð¸ÑÐµÐ»ÑÐºÐ¸ Ð¸Ð¼ÐµÐ½Ð° Ð¸ Ð¿Ð°ÑÐ¾Ð»Ð¸.\",\n\t\tconnectionFailed: \"Ð¡Ð²ÑÑÐ·Ð²Ð°Ð½ÐµÑÐ¾ Ð½ÐµÑÑÐ¿ÐµÑÐ½Ð¾\",\n\t\tconnectionSuccessful: \"Ð¡Ð²ÑÑÐ·Ð²Ð°Ð½ÐµÑÐ¾ ÑÑÐ¿ÐµÑÐ½Ð¾\",\n\t\tconnected: \"Ð¡Ð²ÑÑÐ·Ð°Ð½\",\n\t\tconnectingTo: \"Ð¡Ð²ÑÑÐ·Ð²Ð°Ð½Ðµ ÐºÑÐ¼\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"ÐÐ¾ÑÐ²ÑÑÐ´ÐµÑÐµ ÑÐ²ÑÑÐ·Ð²Ð°Ð½ÐµÑÐ¾ Ð² Ð¿ÑÐ¾Ð·Ð¾ÑÐµÑÐ° Ð½Ð° ÑÐ°Ð·ÑÐ¸ÑÐµÐ½Ð¸ÐµÑÐ¾\",\n\t\t\tbrowser: \"ÐÐ¾ÑÐ²ÑÑÐ´ÐµÑÐµ ÑÐ²ÑÑÐ·Ð²Ð°Ð½ÐµÑÐ¾ Ð² Ð¿Ð¾ÑÑÑÐµÐ¹Ð»Ð° ÑÐ»ÐµÐ´ Ð¿ÑÐµÐ½Ð°ÑÐ¾ÑÐ²Ð°Ð½ÐµÑÐ¾\",\n\t\t\thardware: \"ÐÐ¾ÑÐ²ÑÑÐ´ÐµÑÐµ ÑÐ²ÑÑÐ·Ð²Ð°Ð½ÐµÑÐ¾ Ð² ÑÐ°ÑÐ´ÑÐµÑÐ½Ð¸Ñ Ð¿Ð¾ÑÑÑÐµÐ¹Ð»\",\n\t\t\tbridge: \"ÐÐ¾ÑÐ²ÑÑÐ´ÐµÑÐµ Ð²ÑÑÐ·ÐºÐ°ÑÐ° Ð² Ð¿Ð¾ÑÑÑÐµÐ¹Ð»Ð°\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Ð¡Ð²ÑÑÐ¶ÐµÑÐµ ÑÐµ Ñ Ledger\",\n\t\tmakeSureYourLedger: \"Ð£Ð²ÐµÑÐµÑÐµ ÑÐµ, ÑÐµ Ð²Ð°ÑÐ¸ÑÑ Ledger Ðµ ÑÐ²ÑÑÐ·Ð°Ð½ Ð¸ ÑÐµ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸ÐµÑÐ¾ NEAR Ðµ Ð¾ÑÐ²Ð¾ÑÐµÐ½Ð¾ Ð½a Ð½ÐµÐ³Ð¾.\",\n\t\t\"continue\": \"ÐÑÐ¾Ð´ÑÐ»Ð¶ÐµÑÐµ\",\n\t\tspecifyHDPath: \"ÐÐ¾ÑÐ¾ÑÐµÑÐµ HD Ð¿ÑÑ\",\n\t\tenterYourPreferredHDPath: \"ÐÑÐ²ÐµÐ´ÐµÑÐµ Ð¿ÑÐµÐ´Ð¿Ð¾ÑÐ¸ÑÐ°Ð½Ð¸Ñ HD Ð¿ÑÑ, ÑÐ»ÐµÐ´ ÐºÐ¾ÐµÑÐ¾ ÑÐºÐ°Ð½Ð¸ÑÐ°Ð¹ÑÐµ Ð·Ð° Ð°ÐºÑÐ¸Ð²Ð½Ð¸ Ð°ÐºÐ°ÑÐ½ÑÐ¸.\",\n\t\tscan: \"Ð¡ÐºÐ°Ð½Ð¸ÑÐ°Ð¹ÑÐµ\",\n\t\tretry: \"ÐÐ¿Ð¸ÑÐ°Ð¹ÑÐµ Ð¾ÑÐ½Ð¾Ð²Ð¾\",\n\t\tledgerIsNotAvailable: \"Ledger ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð¾ÑÐ¾ Ð½Ðµ Ðµ Ð´Ð¾ÑÑÑÐ¿Ð½Ð¾\",\n\t\taccessDeniedToUseLedgerDevice: \"ÐÐ¾ÑÑÑÐ¿ÑÑ Ð·Ð° Ð¸Ð·Ð¿Ð¾Ð»Ð·Ð²Ð°Ð½Ðµ Ð½Ð° Ledger Ðµ Ð¾ÑÐºÐ°Ð·Ð°Ð½\",\n\t\tnoAccountsFound: \"ÐÑÐ¼Ð° Ð½Ð°Ð¼ÐµÑÐµÐ½Ð¸ Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸\",\n\t\tselectYourAccounts: \"ÐÐ·Ð±ÐµÑÐµÑÐµ Ð²Ð°ÑÐ¸ÑÐµ Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸\",\n\t\tconnecting1Account: \"Ð¡Ð²ÑÑÐ·Ð²Ð°Ð½Ðµ Ð½Ð° 1 Ð¿ÑÐ¾ÑÐ¸Ð»\",\n\t\tcantFindAnyAccount: \"ÐÑÐ¼Ð° Ð½Ð°Ð¼ÐµÑÐµÐ½Ð¸ Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸, ÑÑÐ²ÑÐ·Ð°Ð½Ð¸ Ñ ÑÐ¾Ð·Ð¸ Ledger. ÐÐ¾Ð»Ñ, ÑÑÐ·Ð´Ð°Ð¹ÑÐµ Ð½Ð¾Ð² NEAR Ð¿ÑÐ¾ÑÐ¸Ð» Ð½Ð°\",\n\t\torConnectAnAnotherLedger: \"Ð¸Ð»Ð¸ ÑÐ²ÑÑÐ¶ÐµÑÐµ Ð´ÑÑÐ³ Ledger.\",\n\t\tconnecting: \"Ð¡Ð²ÑÑÐ·Ð²Ð°Ð½Ðµ\",\n\t\tofAccounts: \"Ð¾Ñ Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸\",\n\t\tfailedToAutomatically: \"ÐÐ²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐ½Ð¾ÑÐ¾ Ð½Ð°Ð¼Ð¸ÑÐ°Ð½Ðµ Ð½Ð° Ð¿ÑÐ¾ÑÐ¸Ð»Ð° Ð½Ðµ Ð±Ðµ ÑÑÐ¿ÐµÑÐ½Ð¾. ÐÑÐ²ÐµÐ´ÐµÑÐµ Ð³Ð¾ ÑÑÑÐ½Ð¾:\",\n\t\toverviewTheListOfAuthorized: \"ÐÑÐµÐ³Ð»ÐµÐ´Ð°Ð¹ÑÐµ ÑÐ¿Ð¸ÑÑÐºÐ° Ñ ÑÐ¿ÑÐ»Ð½Ð¾Ð¼Ð¾ÑÐµÐ½Ð¸ Ð¿ÑÐ¾ÑÐ¸Ð»Ð¸, Ð·Ð°Ð²ÑÑÑÐµÑÐµ Ð²Ð»Ð¸Ð·Ð°Ð½ÐµÑÐ¾, ÐºÐ°ÑÐ¾ ÑÑÐ°ÐºÐ½ÐµÑÐµ Ð²ÑÑÑÑ Ð±ÑÑÐ¾Ð½Ð° Ð¿Ð¾-Ð´Ð¾Ð»Ñ..\",\n\t\tfinish: \"ÐÐ°Ð²ÑÑÑÐµÑÐµ\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Ð©Ðµ ÑÑÑÐ±Ð²Ð° Ð´Ð° Ð¸Ð½ÑÑÐ°Ð»Ð¸ÑÐ°ÑÐµ\",\n\t\ttoContinueAfterInstalling: \"Ð·Ð° Ð´Ð° Ð¿ÑÐ¾Ð´ÑÐ»Ð¶Ð¸ÑÐµ. Ð¡Ð»ÐµÐ´ Ð¸Ð½ÑÑÐ°Ð»Ð¸ÑÐ°Ð½Ðµ\",\n\t\trefreshThePage: \"Ð¿ÑÐµÐ·Ð°ÑÐµÐ´ÐµÑÐµ ÑÑÑÐ°Ð½Ð¸ÑÐ°ÑÐ°.\",\n\t\topen: \"ÐÑÐ²Ð¾ÑÐµÑÐµ\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"ÐÐ¾Ð¿Ð¸ÑÐ°Ð½Ð¾ Ð² ÐºÐ»Ð¸Ð¿Ð±Ð¾ÑÐ´Ð°\",\n\t\tfailedToCopy: \"ÐÐµÑÑÐ¿ÐµÑÐ½Ð¾ ÐºÐ¾Ð¿Ð¸ÑÐ°Ð½Ðµ Ð² ÐºÐ»Ð¸Ð¿Ð±Ð¾ÑÐ´Ð°\",\n\t\tscanWithYourMobile: \" Ð¡ÐºÐ°Ð½Ð¸ÑÐ°Ð¹ÑÐµ Ñ Ð¼Ð¾Ð±Ð¸Ð»Ð½Ð¾ÑÐ¾ ÑÐ¸ ÑÑÑÑÐ¾Ð¹ÑÑÐ²Ð¾\",\n\t\tcopyToClipboard: \" ÐÐ¾Ð¿Ð¸ÑÐ°Ð¹ÑÐµ Ð² ÐºÐ»Ð¸Ð¿Ð±Ð¾ÑÐ´Ð°\",\n\t\tpreferTheOfficial: \"ÐÑÐµÐ´Ð¿Ð¾ÑÐ¸ÑÐ°Ð½ ÐµÐ·Ð¸Ðº Ð·Ð° ÐºÐ¾ÑÐµÑÐ¿Ð¾Ð½Ð´ÐµÐ½ÑÐ¸Ñ\",\n\t\topen: \"ÐÑÐ²Ð¾ÑÐµÑÐµ\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar bg = {\n\tmodal: modal$8\n};\n\nvar modal$7 = {\n\twallet: {\n\t\tconnectYourWallet: \"ì§ê° ì°ê²°íê¸°\",\n\t\twhatIsAWallet: \"ì§ê°ì ë¬´ì¨ ì­í ì íëì?\",\n\t\tsecureAndManage: \"ë¹ì ì ëì§í¸ ìì°ì ë³´í¸íê³  ê´ë¦¬í©ëë¤.\",\n\t\tsafelyStore: \"ìí¸ííì NFTë¥¼ ìì íê² ì ì¥íê³  ì ì¡í  ì ììµëë¤.\",\n\t\tlogInToAny: \"NEAR Appì ë¡ê·¸ì¸í©ëë¤.\",\n\t\tnoNeedToCreate: \"ìë¡ì´ ê³ì ì´ë ë¹ë°ë²í¸ë¥¼ ë§ë¤ íì ìì´ ì§ê°ì ì°ê²°í í ë°ë¡ ì¬ì©í  ì ììµëë¤.\",\n\t\tgetAWallet: \"ì§ê° ê°ì ¸ì¤ê¸°\",\n\t\tuseAWallet: \"ì§ê°ì ì¬ì©íì¬ NEAR ìì°ì ë³´í¸Â·ê´ë¦¬íê³ , ìì´ëì ë¹ë°ë²í¸ ìì´ NEAR ì±ì ë¡ê·¸ì¸í  ì ììµëë¤.\",\n\t\tconnectionFailed: \"ì°ê²° ì¤í¨\",\n\t\tconnectionSuccessful: \"ì°ê²° ì±ê³µ\",\n\t\tconnected: \"Connected\",\n\t\tconnectingTo: \"ì°ê²° ì¤: \",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"ìµì¤íì ì°½ìì ì°ê²°ì íì¸íì¸ì\",\n\t\t\tbrowser: \"ë¦¬ë¤ì´ë í¸ ë ì§ê°ìì ì°ê²°ì íì¸íì¸ì\",\n\t\t\thardware: \"Ledger ê¸°ê¸°ìì ì°ê²°ì íì¸íì¸ì\",\n\t\t\tbridge: \"ì§ê°ìì ì°ê²° íì¸\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Ledger ì°ê²°íê¸°\",\n\t\tmakeSureYourLedger: \"Ledgerê° ìì íê² ì°ê²°ëì´ ìê³ , NEAR ì±ì´ ì´ë ¤ ìë ì§ íì¸íì¸ì\",\n\t\t\"continue\": \"ê³ìíê¸°\",\n\t\tspecifyHDPath: \"HD Path ì§ì íê¸°\",\n\t\tenterYourPreferredHDPath: \"ìíë HD Pathë¥¼ ì ííê³ , íì±íë ê³ì ì´ ìë ì§ ê²ìíì¸ì\",\n\t\tscan: \"ê²ì\",\n\t\tretry: \"ë¤ì ìë\",\n\t\tledgerIsNotAvailable: \"Ledgerë¥¼ ì¬ì©í  ì ììµëë¤\",\n\t\taccessDeniedToUseLedgerDevice: \"Ledger ê¸°ê¸° ì ê·¼ ê¶íì´ ê±°ë¶ëììµëë¤\",\n\t\tnoAccountsFound: \"ê³ì ì ì°¾ì ì ììµëë¤\",\n\t\tselectYourAccounts: \"ê³ì  ì ííê¸°\",\n\t\tconnecting1Account: \"íëì ê³ì ì ì°ê²°\",\n\t\tcantFindAnyAccount: \"Ledgerì ì°ê²°ë ê³ì ì ì°¾ì ì ììµëë¤. ìë¡ì´ ê³ì ì ìì±íê±°ë \",\n\t\torConnectAnAnotherLedger: \"ë¤ë¥¸ Ledgerë¥¼ ì°ê²°íì¸ì\",\n\t\tconnecting: \"ê³ì  ì°ê²°íê¸°: \",\n\t\tofAccounts: \"ê° ê³ì ì ì°¾ììµëë¤\",\n\t\tfailedToAutomatically: \"ê³ì  IDë¥¼ ì°¾ì§ ëª»íìµëë¤. ìëì¼ë¡ ìë ¥í´ì£¼ì¸ì.\",\n\t\toverviewTheListOfAuthorized: \"ì¸ì¦ë ê³ì  ëª©ë¡ì íì¸í í ìë ë²í¼ì í´ë¦­íì¬ ë¡ê·¸ì¸ì ìë£íì¸ì\",\n\t\tfinish: \"ìë£\"\n\t},\n\twalletTypes: {\n\t\thardware: \"íëì¨ì´ ì§ê°\",\n\t\tbrowser: \"ë¸ë¼ì°ì  ì§ê°\",\n\t\tinjected: \"ì§ê° íì¥\",\n\t\tbridge: \"ë¸ë¦¬ì§ ì§ê°\",\n\t\tmobile: \"ëª¨ë°ì¼ ì§ê°\",\n\t\t\"instant-link\": \"ì¸ì¤í´í¸ ì§ê°\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"ë¤ì íì¥ íë¡ê·¸ë¨ì ì¤ì¹í´ì£¼ì¸ì:\",\n\t\ttoContinueAfterInstalling: \". ì¤ì¹ ìë£ í íì´ì§ ìë¡ ê³ ì¹¨ì´ íìí©ëë¤. \",\n\t\trefreshThePage: \"ìë¡ ê³ ì¹¨\",\n\t\topen: \"Open\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"í´ë¦½ë³´ëì ë³µì¬ ìë£\",\n\t\tfailedToCopy: \"í´ë¦½ë³´ëì ë³µì¬ ì¤í¨\",\n\t\tscanWithYourMobile: \"ëª¨ë°ì¼ ì¥ì¹ë¥¼ ì¬ì©íì¬ ì¤ìºí´ì£¼ì¸ì\",\n\t\tcopyToClipboard: \" í´ë¦½ë³´ëì ë³µì¬íê¸°\",\n\t\tpreferTheOfficial: \"ë¤ì íë¡ê·¸ë¨ìì ì ê³µíë ê³µì íë¡ì¸ì¤ë¥¼ ì í¸íì­ëê¹: \",\n\t\topen: \"Open\"\n\t}\n};\nvar ko = {\n\tmodal: modal$7\n};\n\nvar modal$6 = {\n\twallet: {\n\t\tconnectYourWallet: \"Káº¿t ná»i vÃ­ cá»§a báº¡n\",\n\t\twhatIsAWallet: \"VÃ­ lÃ  gÃ¬?\",\n\t\tsecureAndManage: \"Báº£o máº­t & Quáº£n lÃ½ tÃ i sáº£n sá» cá»§a báº¡n\",\n\t\tsafelyStore: \"LÆ°u trá»¯ vÃ  chuyá»n tiá»n Äiá»n tá»­ vÃ  NFT cá»§a báº¡n má»t cÃ¡ch an toÃ n.\",\n\t\tlogInToAny: \"ÄÄng nháº­p vÃ o báº¥t ká»³ á»©ng dá»¥ng trÃªn NEAR\",\n\t\tnoNeedToCreate: \"KhÃ´ng cáº§n táº¡o tÃ i khoáº£n hoáº·c thÃ´ng tin ÄÄng nháº­p má»i. Káº¿t ná»i vÃ­ cá»§a báº¡n vÃ  báº¯t Äáº§u!\",\n\t\tgetAWallet: \"Táº¡o VÃ­\",\n\t\tuseAWallet: \"Sá»­ dá»¥ng vÃ­ Äá» báº£o máº­t vÃ  quáº£n lÃ½ tÃ i sáº£n trÃªn NEAR cá»§a báº¡n vÃ  ÄÄng nháº­p vÃ o báº¥t ká»³ á»©ng dá»¥ng NEAR nÃ o, khÃ´ng cáº§n tÃªn ngÆ°á»i dÃ¹ng vÃ  máº­t kháº©u.\",\n\t\tconnectionFailed: \"Káº¿t ná»i tháº¥t báº¡i\",\n\t\tconnectionSuccessful: \"Káº¿t ná»i thÃ nh cÃ´ng\",\n\t\tconnected: \"ÄÃ£ káº¿t ná»i\",\n\t\tconnectingTo: \"Äang káº¿t ná»i tá»i\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"XÃ¡c nháº­n káº¿t ná»i trong cá»­a sá» tiá»n Ã­ch má» rá»ng\",\n\t\t\tbrowser: \"XÃ¡c nháº­n káº¿t ná»i trong vÃ­ sau khi ÄÆ°á»£c chuyá»n hÆ°á»ng\",\n\t\t\thardware: \"XÃ¡c nháº­n káº¿t ná»i vá»i vÃ­ láº¡nh\",\n\t\t\tbridge: \"XÃ¡c nháº­n káº¿t ná»i trong vÃ­\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Káº¿t ná»i vÃ­ Ledger\",\n\t\tmakeSureYourLedger: \"Äáº£m báº£o Ledger cá»§a báº¡n ÄÆ°á»£c káº¿t ná»i an toÃ n vÃ  á»©ng dá»¥ng NEAR Äang má» sáºµn trÃªn thiáº¿t bá»\",\n\t\t\"continue\": \"Tiáº¿p tá»¥c\",\n\t\tspecifyHDPath: \"Chá» Äá»nh HD Path\",\n\t\tenterYourPreferredHDPath: \"Nháº­p HD Path cá»§a báº¡n, sau ÄÃ³ quÃ©t tÃ¬m cÃ¡c tÃ i khoáº£n hoáº¡t Äá»ng\",\n\t\tscan: \"QuÃ©t\",\n\t\tretry: \"Thá»­ láº¡i\",\n\t\tledgerIsNotAvailable: \"Ledger khÃ´ng kháº£ dá»¥ng\",\n\t\taccessDeniedToUseLedgerDevice: \"Truy cáº­p Ledger bá» tá»« chá»i\",\n\t\tnoAccountsFound: \"KhÃ´ng tÃ¬m tháº¥y tÃ i khoáº£n\",\n\t\tselectYourAccounts: \"Chá»n tÃ i khoáº£n cá»§a báº¡n\",\n\t\tconnecting1Account: \"Äang káº¿t ná»i 1 tÃ i khoáº£n\",\n\t\tcantFindAnyAccount: \"KhÃ´ng thá» tÃ¬m tháº¥y báº¥t ká»³ tÃ i khoáº£n nÃ o ÄÆ°á»£c liÃªn káº¿t vá»i Ledger nÃ y. Vui lÃ²ng táº¡o má»t tÃ i khoáº£n NEAR má»i\",\n\t\torConnectAnAnotherLedger: \"hoáº·c káº¿t ná»i vá»i vÃ­ Ledger khÃ¡c.\",\n\t\tconnecting: \"Äang káº¿t ná»i\",\n\t\tofAccounts: \"cá»§a tÃ i khoáº£n\",\n\t\tfailedToAutomatically: \"KhÃ´ng thá» tá»± Äá»ng tÃ¬m id tÃ i khoáº£n. Nháº­p thá»§ cÃ´ng:\",\n\t\toverviewTheListOfAuthorized: \"Tá»ng quan danh sÃ¡ch cÃ¡c tÃ i khoáº£n ÄÆ°á»£c á»§y quyá»n, hoÃ n táº¥t ÄÄng nháº­p báº±ng cÃ¡ch báº¥m vÃ o nÃºt bÃªn dÆ°á»i.\",\n\t\tfinish: \"HoÃ n thÃ nh\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Báº¡n sáº½ cáº§n cÃ i Äáº·t\",\n\t\ttoContinueAfterInstalling: \"Äá» báº¯t Äáº§u. Sau khi cÃ i Äáº·t xong\",\n\t\trefreshThePage: \"Táº£i láº¡i trang.\",\n\t\topen: \"Má»\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"ÄÃ£ sao chÃ©p vÃ o báº£ng ghi táº¡m\",\n\t\tfailedToCopy: \"Sao chÃ©p vÃ o báº£ng ghi táº¡m tháº¥t báº¡i\",\n\t\tscanWithYourMobile: \"QuÃ©t vá»i Äiá»n thoáº¡i cá»§a báº¡n\",\n\t\tcopyToClipboard: \" Sao chÃ©p vÃ o báº£ng ghi táº¡m\",\n\t\tpreferTheOfficial: \"Dialogue chÃ­nh thá»©c cá»§a\",\n\t\topen: \"Má»\"\n\t},\n\twalletTypes: {\n\t\thardware: \"VÃ­ láº¡nh\",\n\t\tbrowser: \"VÃ­ trÃ¬nh duyá»t\",\n\t\tinjected: \"VÃ­ tiá»n Ã­ch má» rá»ng\",\n\t\tbridge: \"VÃ­ Cáº§u\",\n\t\tmobile: \"VÃ­ Mobile\",\n\t\t\"instant-link\": \"VÃ­ tá»©c thÃ¬\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Chá»n vÃ­\",\n\t\ttransferYourAccounts: \"Chuyá»n tÃ i khoáº£n\",\n\t\tselectAWallet: \"Chá»n vÃ­ phÃ¹ há»£p vá»i nhu cáº§u cá»§a báº¡n, vÃ­ ÄÆ°á»£c chá»n cáº§n há» trá»£ cÃ¡c tÃ i khoáº£n Äang sá»­ dá»¥ng.\",\n\t\tselectYourAccounts: \"Chá»n tÃ i khoáº£n\",\n\t\tafterDecide: \"Sau khi chá»n ÄÆ°á»£c tÃ i khoáº£n báº¡n cÃ³ chuyá»n.\",\n\t\tdisclaimer: \"Báº¡n khÃ´ng thá» chuyá»n tÃ i khoáº£n náº¿u tÃ i khoáº£n ÄÃ³ chÆ°a ÄÆ°á»£c nháº­n tiá»n hoáº·c chÆ°a phÃ¡t sinh giao dá»ch trÃªn NEAR.\",\n\t\twarning: \"khÃ´ng há» trá»£ xuáº¥t tÃ i khoáº£n. Vui lÃ²ng chá»n vÃ­ khÃ¡c.\",\n\t\twalletTypes: {\n\t\t\thardware: \"VÃ­ láº¡nh\",\n\t\t\tbrowser: \"VÃ­ trÃ¬nh duyá»t\",\n\t\t\tinjected: \"VÃ­ tiá»n Ã­ch má» rá»ng\",\n\t\t\tbridge: \"VÃ­ Cáº§u\",\n\t\t\tmobile: \"VÃ­ Mobile\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Chá»n tÃ i khoáº£n Äá» chuyá»n\",\n\t\t\tbutton: \"Láº¥y cá»¥m máº­t kháº©u\",\n\t\t\tdeselectAll: \"Bá» chá»n táº¥t cáº£\",\n\t\t\tselectAll: \"Chá»n táº¥t cáº£\",\n\t\t\tunavailable: \"Chuyá»n khÃ´ng kháº£ dá»¥ng\",\n\t\t\terror: \"TÃ i khoáº£n khÃ´ng tá»n táº¡i\",\n\t\t\twarningLedger: \"YÃªu cáº§u há» trá»£ Ledger\",\n\t\t\tnoBalance: \"TÃ i khoáº£n trá»ng\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Sao chÃ©p máº­t kháº©u táº¡m thá»i\",\n\t\t\tdesc: \"Báº¡n sáº½ cáº§n nháº­p máº­t kháº©u khi báº¯t Äáº§u xuáº¥t cÃ¡c khoáº£n tá»i vÃ­ khÃ¡c.\",\n\t\t\tbutton: \"Tiáº¿p tá»¥c\",\n\t\t\tlabel: \"Báº¥m Äá» sao chÃ©p\",\n\t\t\tcheckLabel: \"TÃ´i ÄÃ£ chÃ©p hoáº·c ghi láº¡i máº­t kháº©u\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"HoÃ n thÃ nh chuyá»n\",\n\t\t\tdescOne: \"Báº¡n sáº½ ÄÆ°á»£c chuyá»n hÆ°á»ng tá»i tÃ i khoáº£n ÄÃ£ chá»n Äá» hoÃ n táº¥t quÃ¡ trÃ¬nh.\",\n\t\t\tdescTwo: \"Sau khi nháº­p, nháº¥n nÃºt Äá» hoÃ n táº¥t quy trÃ¬nh chuyá»n.\",\n\t\t\tbutton: \"HoÃ n thÃ nh\"\n\t\t}\n\t}\n};\nvar component = {\n\tclickToCopy: {\n\t\tlabel: \"ÄÃ£ sao chÃ©p\",\n\t\ttooltip: \"Báº¥m Äá» sao chÃ©p\"\n\t}\n};\nvar vi = {\n\tmodal: modal$6,\n\tcomponent: component\n};\n\nvar modal$5 = {\n\twallet: {\n\t\tconnectYourWallet: \"à¤à¤ªà¤¨à¤¾ à¤µà¥à¤²à¥à¤ (Wallet) à¤à¤¨à¥à¤à¥à¤ à¤à¤°à¥à¤à¥¤\",\n\t\twhatIsAWallet: \"à¤µà¥à¤²à¥à¤ à¤à¥à¤¯à¤¾ à¤¹à¥?\",\n\t\tsecureAndManage: \"à¤¸à¥à¤°à¤à¥à¤·à¤¿à¤¤ à¤à¤° à¤ªà¥à¤°à¤¬à¤à¤§à¤¿à¤¤ à¤à¤°à¥à¤à¥¤\",\n\t\tsafelyStore: \"à¤à¤ªà¤¨à¥ à¤à¥à¤°à¤¿à¤ªà¥à¤à¥à¤à¤°à¥à¤à¤¸à¥ à¤à¤° à¤à¤¨à¤à¤«à¤à¥ à¤à¥ à¤¸à¥à¤°à¤à¥à¤·à¤¿à¤¤ à¤°à¥à¤ª à¤¸à¥ à¤¸à¥à¤à¥à¤° à¤à¤° à¤à¥à¤°à¤¾à¤à¤¸à¤«à¤° à¤à¤°à¥à¤à¥¤\",\n\t\tlogInToAny: \"NEAR à¤ªà¤° à¤à¤¿à¤¸à¥ à¤­à¥ à¤à¤ª à¤®à¥à¤ à¤¸à¤¾à¤à¤¨ à¤à¤¨ à¤à¤°à¥à¤à¥¤\",\n\t\tnoNeedToCreate: \"à¤¨à¤ à¤à¤¾à¤¤à¥ à¤¯à¤¾ à¤²à¥à¤à¤¿à¤¨ à¤¬à¤¨à¤¾à¤¨à¥ à¤à¥ à¤à¤µà¤¶à¥à¤¯à¤à¤¤à¤¾ à¤¨à¤¹à¥à¤ à¤¹à¥à¥¤ à¤à¤ªà¤¨à¤¾ à¤µà¥à¤²à¥à¤(NEAR Wallet)à¤à¤¨à¥à¤à¥à¤ à¤à¤°à¥à¤ à¤à¤° à¤à¤°à¤à¤­ à¤à¤°à¥à¤à¥¤\",\n\t\tgetAWallet: \"à¤à¤ à¤µà¥à¤²à¥à¤ à¤¬à¤¨à¤¾à¤à¤à¥¤\",\n\t\tuseAWallet: \"à¤à¤ªà¤¨à¥ NEAR à¤¸à¤à¤ªà¤¤à¥à¤¤à¤¿à¤¯à¥à¤ à¤à¥ à¤¸à¥à¤°à¤à¥à¤·à¤¿à¤¤ à¤à¤° à¤ªà¥à¤°à¤¬à¤à¤§à¤¿à¤¤ à¤à¤°à¤¨à¥ à¤à¥ à¤²à¤¿à¤ à¤µà¥à¤²à¥à¤ à¤à¤¾ à¤à¤ªà¤¯à¥à¤ à¤à¤°à¥à¤ à¤à¤° à¤à¤¿à¤¸à¥ à¤­à¥ NEAR à¤à¤ª (app) à¤®à¥à¤ à¤²à¥à¤ à¤à¤¨ à¤à¤°à¥à¤, à¤à¤¿à¤¸à¥ à¤à¤ªà¤¯à¥à¤à¤à¤°à¥à¤¤à¤¾ (user) à¤¨à¤¾à¤® à¤à¤° à¤ªà¤¾à¤¸à¤µà¤°à¥à¤¡ à¤à¥ à¤à¤µà¤¶à¥à¤¯à¤à¤¤à¤¾ à¤¨à¤¹à¥à¤ à¤¹à¥à¥¤\",\n\t\tconnectionFailed: \"à¤à¤¨à¥à¤à¥à¤¶à¤¨ à¤µà¤¿à¤«à¤²|\",\n\t\tconnectionSuccessful: \"à¤à¤¨à¥à¤à¥à¤¶à¤¨ à¤¸à¤«à¤²|\",\n\t\tconnected: \"à¤µà¥à¤²à¥à¤ à¤à¥à¥ à¤à¤¯à¤¾|\",\n\t\tconnectingTo: \"à¤µà¥à¤²à¥à¤ à¤à¥à¥ à¤°à¤¹à¤¾ à¤¹à¥|\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"à¤à¤à¥à¤¸à¤à¥à¤à¤¶à¤¨ à¤µà¤¿à¤à¤¡à¥ à¤®à¥à¤ à¤à¤¨à¥à¤à¥à¤¶à¤¨ à¤à¥ à¤ªà¥à¤·à¥à¤à¤¿ à¤à¤°à¥à¤|\",\n\t\t\tbrowser: \"à¤°à¥à¤¡à¤¾à¤¯à¤°à¥à¤à¥à¤ à¤¹à¥à¤¨à¥ à¤à¥ à¤¬à¤¾à¤¦ à¤µà¥à¤²à¥à¤ à¤®à¥à¤ à¤à¤¨à¥à¤à¥à¤¶à¤¨ à¤à¥ à¤ªà¥à¤·à¥à¤à¤¿ à¤à¤°à¥à¤|\",\n\t\t\thardware: \"à¤à¥à¤²à¥à¤¡ à¤µà¥à¤²à¥à¤ à¤à¥ à¤¸à¤¾à¤¥ à¤à¤¨à¥à¤à¥à¤¶à¤¨ à¤à¥ à¤ªà¥à¤·à¥à¤à¤¿ à¤à¤°à¥à¤|\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"à¤²à¥à¤à¤°(Ledger)à¤µà¥à¤²à¥à¤ à¤à¤¨à¥à¤à¥à¤ à¤à¤°à¥à¤|\",\n\t\tmakeSureYourLedger: \"à¤¸à¥à¤¨à¤¿à¤¶à¥à¤à¤¿à¤¤ à¤à¤°à¥à¤ à¤à¤¿ à¤à¤ªà¤à¤¾ à¤²à¥à¤à¤° à¤¸à¥à¤°à¤à¥à¤·à¤¿à¤¤ à¤°à¥à¤ª à¤¸à¥ à¤à¥à¤¡à¤¼à¤¾ à¤¹à¥à¤ à¤¹à¥ à¤à¤° NEAR à¤à¤ª à¤à¤ªà¤à¥ à¤¡à¤¿à¤µà¤¾à¤à¤¸ (Device)à¤ªà¤° à¤ªà¤¹à¤²à¥ à¤¸à¥ à¤¹à¥ à¤à¥à¤²à¤¾ à¤¹à¥|\",\n\t\t\"continue\": \"à¤à¤¾à¤°à¥ à¤°à¤à¥|\",\n\t\tspecifyHDPath: \"à¤¹à¤¾à¤°à¥à¤¡ à¤¡à¤¿à¤¸à¥à¤(Hard Disk)à¤ªà¤¥(Path)à¤¨à¤¿à¤°à¥à¤§à¤¾à¤°à¤¿à¤¤ à¤à¤°à¥|\",\n\t\tenterYourPreferredHDPath: \"à¤à¤ªà¤¨à¤¾ à¤à¤à¤¡à¥ à¤ªà¤¥ à¤¦à¤°à¥à¤ à¤à¤°à¥à¤, à¤«à¤¿à¤° à¤¸à¤à¥à¤°à¤¿à¤¯ à¤à¤¾à¤¤à¥à¤ à¤à¥ à¤²à¤¿à¤ à¤¸à¥à¤à¥à¤¨ à¤à¤°à¥à¤|\",\n\t\tscan: \"à¤¸à¥à¤à¥à¤¨ à¤à¤°à¥|\",\n\t\tretry: \"à¤¦à¥à¤¬à¤¾à¤°à¤¾ à¤ªà¥à¤°à¤¯à¤¾à¤¸ à¤à¤°à¥|\",\n\t\tledgerIsNotAvailable: \"à¤²à¥à¤à¤° à¤à¤ªà¤²à¤¬à¥à¤§ à¤¨à¤¹à¥à¤ à¤¹à¥|\",\n\t\taccessDeniedToUseLedgerDevice: \"à¤²à¥à¤à¤° à¤¡à¤¿à¤µà¤¾à¤à¤¸ à¤à¤¾ à¤à¤ªà¤¯à¥à¤ à¤à¤°à¤¨à¥ à¤à¥ à¤²à¤¿à¤ à¤ªà¥à¤°à¤µà¥à¤¶ à¤¨à¤¿à¤·à¥à¤§|\",\n\t\tnoAccountsFound: \"à¤à¤¾à¤¤à¤¾ à¤¨à¤¹à¥à¤ à¤®à¤¿à¤²à¤¾|\",\n\t\tselectYourAccounts: \"à¤à¤ªà¤¨à¥ à¤à¤¾à¤¤à¥ à¤à¥à¤¨à¥à¤|\",\n\t\tconnecting1Account: \"à¤à¤ à¤à¤¾à¤¤à¤¾ à¤à¤¨à¥à¤à¥à¤ à¤¹à¥ à¤°à¤¹à¤¾ à¤¹à¥|\",\n\t\tcantFindAnyAccount: \"à¤à¤¸ à¤²à¥à¤à¤° à¤¸à¥ à¤à¥à¤¡à¤¼à¤¾ à¤à¥à¤ à¤à¤¾à¤¤à¤¾ à¤¨à¤¹à¥à¤ à¤®à¤¿à¤²à¤¾à¥¤ à¤à¥à¤ªà¤¯à¤¾ à¤à¤ à¤¨à¤¯à¤¾ NEAR à¤à¤¾à¤¤à¤¾ à¤¬à¤¨à¤¾à¤à¤|\",\n\t\torConnectAnAnotherLedger: \"à¤à¤¥à¤µà¤¾ à¤¦à¥à¤¸à¤°à¥ à¤²à¥à¤à¤° à¤µà¥à¤²à¥à¤ à¤¸à¥ à¤à¤¨à¥à¤à¥à¤ à¤à¤°à¥à¤à¥¤\",\n\t\tconnecting: \"à¤à¥à¥ à¤°à¤¹à¤¾ à¤¹à¥|\",\n\t\tofAccounts: \"à¤à¤¾à¤¤à¤¾ à¤à¤¬ à¤à¥à¥à¤¾ à¤¨à¤¹à¥à¤ à¤¹à¥|\",\n\t\tfailedToAutomatically: \"à¤à¤¾à¤¤à¤¾ à¤à¤à¤¡à¥ à¤¸à¥à¤µà¤à¤¾à¤²à¤¿à¤¤ à¤°à¥à¤ª à¤¸à¥ à¤à¥à¤à¤¨à¥ à¤®à¥à¤ à¤à¤¸à¤®à¤°à¥à¤¥à¥¤ à¤®à¥à¤¨à¥à¤¯à¥à¤à¤² (Manuall) à¤°à¥à¤ª à¤¸à¥ à¤à¥à¤¶à¤¿à¤¶ à¤à¤°à¥à¤|\",\n\t\toverviewTheListOfAuthorized: \"à¤à¤µà¤²à¥à¤à¤¨ à¤à¤§à¤¿à¤à¥à¤¤ à¤à¥ à¤¸à¥à¤à¥, à¤¨à¥à¤à¥ à¤¦à¤¿à¤ à¤à¤ à¤¬à¤à¤¨ à¤ªà¤° à¤à¥à¤²à¤¿à¤ à¤à¤°à¤à¥ à¤²à¥à¤à¤¿à¤¨ à¤ªà¥à¤°à¤¾ à¤à¤°à¥à¤à¥¤\",\n\t\tfinish: \"à¤¸à¤®à¤¾à¤ªà¥à¤¤|\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"à¤à¤ªà¤à¥ à¤à¤à¤¸à¥à¤à¥à¤² à¤à¤°à¤¨à¤¾ à¤¹à¥à¤à¤¾|\",\n\t\ttoContinueAfterInstalling: \"à¤à¤à¤¸à¥à¤à¥à¤² à¤à¤°à¤¨à¥ à¤à¥ à¤¬à¤¾à¤¦ à¤à¤¾à¤°à¥ à¤°à¤à¥|\",\n\t\trefreshThePage: \"à¤ªà¥à¤¨: à¤²à¥à¤¡ à¤à¤°à¥à¤à¥¤\",\n\t\topen: \"à¤à¥à¤²à¥|\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"à¤à¥à¤²à¤¿à¤ªà¤¬à¥à¤°à¥à¤¡(Clipboard)à¤ªà¤° à¤à¥à¤ªà¥ à¤à¤¿à¤¯à¤¾ à¤à¤¯à¤¾|\",\n\t\tfailedToCopy: \"à¤à¥à¤²à¤¿à¤ªà¤¬à¥à¤°à¥à¤¡ à¤ªà¤° à¤à¥à¤ªà¥ à¤à¤°à¤¨à¤¾ à¤µà¤¿à¤«à¤² à¤°à¤¹à¤¾|\",\n\t\tscanWithYourMobile: \"à¤à¤ªà¤¨à¥ à¤«à¥à¤¨ (Mobile)à¤¸à¥ à¤¸à¥à¤à¥à¤¨ à¤à¤°à¥à¤|\",\n\t\tcopyToClipboard: \" à¤à¥à¤²à¤¿à¤ªà¤¬à¥à¤°à¥à¤¡ à¤ªà¤° à¤à¥à¤ªà¥ à¤à¤°à¥à¤|\",\n\t\tpreferTheOfficial: \"à¤à¤§à¤¿à¤à¤¾à¤°à¤¿à¤ à¤¸à¤à¤µà¤¾à¤¦ à¤à¥ à¤ªà¥à¤°à¤¾à¤¥à¤®à¤¿à¤à¤¤à¤¾ à¤¦à¥à¤|\",\n\t\topen: \"à¤à¥à¤²à¥|\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar hi = {\n\tmodal: modal$5\n};\n\nvar modal$4 = {\n\twallet: {\n\t\tconnectYourWallet: \"ØµÙ ÙØ­ÙØ¸ØªÙ\",\n\t\twhatIsAWallet: \"ÙØ§ ÙÙ Ø§ÙÙØ­ÙØ¸Ø©Ø\",\n\t\tsecureAndManage: \"ØªØ£ÙÙÙ ÙØ¥Ø¯Ø§Ø±Ø© Ø§ÙÙÙØªÙÙØ§Øª Ø§ÙØ±ÙÙÙØ© Ø§ÙØ®Ø§ØµØ© Ø¨Ù\",\n\t\tsafelyStore: \"ÙÙ Ø¨ØªØ®Ø²ÙÙ Ù Ø§Ø±Ø³Ø§Ù Ø¹ÙÙØ§ØªÙ Ù Ø£ØµÙÙÙ Ø§ÙØ±ÙÙÙØ© Ø¨Ø£ÙØ§Ù\",\n\t\tlogInToAny: \"Ø³Ø¬Ù Ø§ÙØ¯Ø®ÙÙ Ø¥ÙÙ Ø£Ù ØªØ·Ø¨ÙÙ ÙØ³ØªØ®Ø¯Ù ÙÙØ±\",\n\t\tnoNeedToCreate: \".ÙØ§ Ø¯Ø§Ø¹Ù ÙØ¥ÙØ´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ø¬Ø¯ÙØ¯. ÙÙØ· ÙÙ Ø¨ØªÙØµÙÙ ÙØ­ÙØ¸ØªÙ ÙØ§ÙØ·ÙÙ\",\n\t\tgetAWallet: \"Ø§Ø­ØµÙ Ø¹ÙÙ ÙØ­ÙØ¸Ø©\",\n\t\tuseAWallet: \"Ø§Ø³ØªØ®Ø¯Ù ÙØ­ÙØ¸Ø© ÙØªØ£ÙÙÙ ÙØ¥Ø¯Ø§Ø±Ø© Ø£ØµÙÙ ÙÙØ± Ø§ÙØ®Ø§ØµØ© Ø¨ÙØ ÙØ§Ø¯Ø®Ù ÙØ£Ù ØªØ·Ø¨ÙÙ ÙØ³ØªØ®Ø¯Ù ÙÙØ± Ø¯ÙÙ Ø§ÙØ­Ø§Ø¬Ø© Ø¥ÙÙ Ø§Ø³Ù Ø§ÙÙØ³ØªØ®Ø¯Ù ÙÙÙÙØ©Ø§ÙÙØ±ÙØ±\",\n\t\tconnectionFailed: \"Ø§ØªØµØ§Ù ÙØ§Ø´Ù\",\n\t\tconnectionSuccessful: \"Ø§ØªØµØ§Ù ÙØ§Ø¬Ø­\",\n\t\tconnected: \"ÙØªØµÙ\",\n\t\tconnectingTo: \"Ø¬Ø§Ø±Ù Ø§ÙØ§ØªØµØ§Ù Ø¨\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"ÙØ§ÙÙ Ø¹ÙÙ Ø§ÙØ§ØªØµØ§Ù ÙÙ ÙØ§ÙØ°Ø© Ø§ÙØ¥Ø¶Ø§ÙØ©\",\n\t\t\tbrowser: \"ÙØ§ÙÙ Ø¹ÙÙ Ø§ÙØ§ØªØµØ§Ù ÙÙ Ø§ÙÙØ­ÙØ¸Ø© Ø¨Ø¹Ø¯ Ø¥Ø¹Ø§Ø¯Ø© ØªÙØ¬ÙÙ\",\n\t\t\thardware: \"ÙØ§ÙÙ Ø¹ÙÙ Ø§ÙØ§ØªØµØ§Ù ÙÙ Ø¬ÙØ§Ø² ÙÙØ¯Ø¬Ø±\",\n\t\t\tbridge: \"ÙØ§ÙÙ Ø¹ÙÙ Ø§ÙØ§ØªØµØ§Ù ÙÙ Ø§ÙÙØ­ÙØ¸Ø©\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"Ø§ØªØµÙ ÙØ¹ ÙÙØ¯Ø¬Ø±\",\n\t\tmakeSureYourLedger: \"ØªØ£ÙØ¯ Ø£Ù ÙÙØ¯Ø¬Ø± ÙØªØµÙ Ø¨Ø£ÙØ§Ù, Ù Ø£Ù ØªØ·Ø¨ÙÙ ÙÙØ± ÙÙØªÙØ­ ÙÙ Ø¬ÙØ§Ø²Ù\",\n\t\t\"continue\": \"ØªØ§Ø¨Ø¹\",\n\t\tspecifyHDPath: \"Ø­Ø¯Ø¯ ÙØ³Ø§Ø± Ø§ÙØ­Ø³Ø§Ø¨\",\n\t\tenterYourPreferredHDPath: \"Ø£Ø¯Ø®Ù ÙØ³Ø§Ø± Ø§ÙØ­Ø³Ø§Ø¨ Ø§ÙÙÙØ¶ÙØ Ø«Ù Ø§Ø¨Ø­Ø« Ø¹Ù ÙÙ Ø§ÙØ­Ø³Ø§Ø¨Ø§Øª Ø§ÙÙØ´Ø·Ø©\",\n\t\tscan: \"ÙØ³Ø­\",\n\t\tretry: \"Ø£Ø¹Ø¯ Ø§ÙÙØ­Ø§ÙÙØ©\",\n\t\tledgerIsNotAvailable: \"ÙÙØ¯Ø¬Ø± ØºÙØ± ÙØªÙÙØ±\",\n\t\taccessDeniedToUseLedgerDevice: \"ØªÙ Ø±ÙØ¶ Ø§ÙØ§ØªØµØ§Ù Ø¨ÙÙØ¯Ø¬Ø±\",\n\t\tnoAccountsFound: \"ÙÙ ÙØªÙ Ø§ÙØ¹Ø«ÙØ± Ø¹ÙÙ Ø£Ù Ø­Ø³Ø§Ø¨Ø§Øª\",\n\t\tselectYourAccounts: \"Ø­Ø¯Ø¯ Ø­Ø³Ø§Ø¨Ø§ØªÙ\",\n\t\tconnecting1Account: \"Ø¬Ø§Ø±Ù Ø§ÙØ§ØªØµØ§Ù Ø¨Ø­Ø³Ø§Ø¨ ÙØ§Ø­Ø¯\",\n\t\tcantFindAnyAccount: \"ÙØ§ ÙÙÙÙ Ø§ÙØ¹Ø«ÙØ± Ø¹ÙÙ Ø£Ù Ø­Ø³Ø§Ø¨ ÙØ±ØªØ¨Ø· Ø¨ÙØ°Ø§ ÙÙØ¯Ø¬Ø± Ø§ÙØ±Ø¬Ø§Ø¡ Ø¥ÙØ´Ø§Ø¡ Ø­Ø³Ø§Ø¨ ÙÙØ± Ø¬Ø¯ÙØ¯ Ø¹ÙÙ\",\n\t\torConnectAnAnotherLedger: \"Ø§Ù Ø§Ø±Ø¨Ø· Ø¬ÙØ§Ø² ÙÙØ¯Ø¬Ø± Ø¢Ø®Ø±\",\n\t\tconnecting: \"Ø¬Ø§Ø±Ù Ø§ÙØ§ØªØµØ§Ù\",\n\t\tofAccounts: \"ÙÙ Ø§ÙØ­Ø³Ø§Ø¨Ø§Øª\",\n\t\tfailedToAutomatically: \"ÙØ´Ù ÙÙ Ø§ÙØ§ØªØµØ§Ù Ø¨Ø§ÙØ­Ø³Ø§Ø¨ ØªÙÙØ§Ø¦ÙØ§. ÙØ±Ø¬Ù Ø§ÙØ§ØªØµØ§Ù Ø¨Ø§ÙØ­Ø³Ø§Ø¨ ÙØ¯ÙÙØ§\",\n\t\toverviewTheListOfAuthorized: \"ÙØ§Ø¦Ø­Ø© Ø§ÙØ­Ø³Ø§Ø¨Ø§Øª Ø§ÙÙØµØ±Ø­ Ø¨ÙØ§, Ø£ÙÙÙ ØªØ³Ø¬ÙÙ Ø§ÙØ¯Ø®ÙÙ Ø¨Ø§ÙÙÙØ± Ø¹ÙÙ Ø§ÙØ²Ø± Ø£Ø¯ÙØ§Ù\",\n\t\tfinish: \"Ø¥ÙÙØ§Ø¡\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Ø³ØªØ­ØªØ§Ø¬ ÙØªØ«Ø¨ÙØª\",\n\t\ttoContinueAfterInstalling: \"ÙÙØ§Ø³ØªÙÙØ§Ù. Ø¨Ø¹Ø¯ Ø§ÙØªØ«Ø¨ÙØª\",\n\t\trefreshThePage: \"ÙÙ Ø¨ØªØ­Ø¯ÙØ« Ø§ÙØµÙØ­Ø©\",\n\t\topen: \"Ø§ÙØªØ­\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"ØªÙ Ø§ÙÙØ³Ø®\",\n\t\tfailedToCopy: \"ÙØ´Ù Ø§ÙÙØ³Ø®\",\n\t\tscanWithYourMobile: \"Ø§ÙØ³Ø­ Ø¨Ø¬ÙØ§Ø²Ù Ø§ÙÙØ­ÙÙÙ\",\n\t\tcopyToClipboard: \"ÙØ³Ø®\",\n\t\tpreferTheOfficial: \"ØªÙØ¶Ù Ø§ÙØ­ÙØ§Ø± Ø§ÙØ±Ø³ÙÙ Ù\",\n\t\topen: \"ÙØªØ­\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t}\n};\nvar ar = {\n\tmodal: modal$4\n};\n\nvar modal$3 = {\n\twallet: {\n\t\tconnectYourWallet: \"Spojite crypto novÄanik!\",\n\t\twhatIsAWallet: \"Å to je to crypto novÄanik?\",\n\t\tsecureAndManage: \"Osigurajte i upravljajte svojom digitalnom imovinom.\",\n\t\tsafelyStore: \"Sigurno pohranite i prebacite svoj crypto i NFT-eve.\",\n\t\tlogInToAny: \" Prijavite se u bilo koju NEAR aplikaciju\",\n\t\tnoNeedToCreate: \"Nema potrebe za stvaranjem novih naloga ili korisniÄkih podataka. Spojite svoj crypto novÄanik i spremni ste!\",\n\t\tgetAWallet: \"Otvorite crypto novÄanik\",\n\t\tuseAWallet: \"Koristite crypto novÄanik da biste osigurali i upravljali svojom NEAR imovinom, te se prijavite u bilo koju NEAR aplikaciju bez korisniÄkog imena i lozinke.\",\n\t\tconnectionFailed: \"NeuspjeÅ¡no povezivanje.\",\n\t\tconnectionSuccessful: \"UspjeÅ¡no povezivanje.\",\n\t\tconnected: \"Povezano.\",\n\t\tconnectingTo: \"Povezivanje u tijeku\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potvrdite vezu u eksternom prozoru\",\n\t\t\tbrowser: \"Nakon redirekcije, potvrdite vezu u novÄaniku\",\n\t\t\thardware: \"Potvrdite vezu sa novÄanikom\",\n\t\t\tbridge: \"Potvrdite vezu u novÄaniku\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"PoveÅ¾ite se hardverskim novÄanikom\",\n\t\tmakeSureYourLedger: \"Osigurajte sigurnu vezu s hardverskim novÄanikom, te da je NEAR aplikacija otvorena na vaÅ¡em ureÄaju\",\n\t\t\"continue\": \"Nastavite\",\n\t\tspecifyHDPath: \"Specificirajte HD putanju\",\n\t\tenterYourPreferredHDPath: \"UpiÅ¡ite preferiranu HD putanju, zatim skenirajte aktivne naloge\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"PokuÅ¡ajte ponovno\",\n\t\tledgerIsNotAvailable: \"Hardverski novÄanik nije dostupan.\",\n\t\taccessDeniedToUseLedgerDevice: \"Odbijen pristup za koriÅ¡tenjem hardverskog novÄanika\",\n\t\tnoAccountsFound: \"Nalozi nisu pronaÄeni\",\n\t\tselectYourAccounts: \"Odaberite svoje naloge\",\n\t\tconnecting1Account: \"Povezivanje 1 naloga\",\n\t\tcantFindAnyAccount: \"Nije moguÄe pronaÄi niti jedan nalog povezan s ovim hardverskim novÄanikom. Molimo vas, kreirajte novi NEAR nalog\",\n\t\torConnectAnAnotherLedger: \"Ili poveÅ¾ite drugi hardverski novÄanik.\",\n\t\tconnecting: \"Povezivanje\",\n\t\tofAccounts: \"naloga\",\n\t\tfailedToAutomatically: \"NeuspjeÅ¡no automatsko pronalaÅ¾enje ID naloga. Unesite ruÄno:\",\n\t\toverviewTheListOfAuthorized: \"Pregledajte popis odobrenih naloga, zavrÅ¡ite prijavu pritiskom na niÅ¾e prikazani gumb.\",\n\t\tfinish: \"ZavrÅ¡ite\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \" Potrebno je instalirati modal\",\n\t\ttoContinueAfterInstalling: \"za nastavak. Nakon instalacije\",\n\t\trefreshThePage: \"osvjeÅ¾ite stranicu.\",\n\t\topen: \"Otvorite QR modal\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano u meÄuspremnik\",\n\t\tfailedToCopy: \"NeupsjeÅ¡no kopiranje u meÄuspremnik\",\n\t\tscanWithYourMobile: \"Skenirajte svojim mobilnim ureÄajem\",\n\t\tcopyToClipboard: \" Kopirajte u meÄuspremnik\",\n\t\tpreferTheOfficial: \"Odaberite sluÅ¾beni dijalog\",\n\t\topen: \"Otvorite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hardware Wallet\",\n\t\tbrowser: \"Browser Wallet\",\n\t\tinjected: \"Wallet Extension\",\n\t\tbridge: \"Bridge Wallet\",\n\t\tmobile: \"Mobile Wallet\",\n\t\t\"instant-link\": \"Instant Wallet\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Odaberi Wallet\",\n\t\ttransferYourAccounts: \"Prenesi svoje naloge\",\n\t\tselectAWallet: \"Odaberite wallet koji odgovara vaÅ¡im potrebama i podrÅ¾ava vaÅ¡e povezane naloge.\",\n\t\tselectYourAccounts: \"Odaberi svoje naloge\",\n\t\tafterDecide: \"Nakon Å¡to odluÄite koji wallet koristite, moÅ¾ete odabrati koje raÄune Å¾elite prebaciti.\",\n\t\tdisclaimer: \"NeÄete moÄi prebaciti naloge koji nisu nikada bili koriÅ¡teni na NEAR-u.\",\n\t\twarning: \"ne podrÅ¾ava izvoz naloga u ovom trenutku. Molimo odaberite drugi wallet.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hardware Wallet\",\n\t\t\tbrowser: \"Browser Wallet\",\n\t\t\tinjected: \"Wallet Extension\",\n\t\t\tbridge: \"Bridge Wallet\",\n\t\t\tmobile: \"Mobile Wallet\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Odaberi naloge za prijenos\",\n\t\t\tbutton: \"Generiraj lozinku\",\n\t\t\tdeselectAll: \"Makni odabir sa svih\",\n\t\t\tselectAll: \"Odaberi sve\",\n\t\t\tunavailable: \"Prijenos nije dostupan\",\n\t\t\terror: \"Nalog ne postoji\",\n\t\t\twarningLedger: \"Potrebna ledger podrÅ¡ka\",\n\t\t\tnoBalance: \"Nalog nema sredstava\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj privremenu lozinku\",\n\t\t\tdesc: \"Bit Äe potrebno unijeti ovu lozinku na poÄetku izvoza naloga na drugi wallet.\",\n\t\t\tbutton: \"Nastavi\",\n\t\t\tlabel: \"Klikni za kopiju\",\n\t\t\tcheckLabel: \"Kopirao sam ili zapisao lozinku\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"ZavrÅ¡i prijenos\",\n\t\t\tdescOne: \"You will now be redirected to the wallet you selected to complete the transfer.\",\n\t\t\tdescTwo: \"Kada je unos s odabranog walleta zavrÅ¡en, pritisnite gumb da biste zavrÅ¡ili prijenos.\",\n\t\t\tbutton: \"ZavrÅ¡i\"\n\t\t}\n\t}\n};\nvar hr = {\n\tmodal: modal$3\n};\n\nvar modal$2 = {\n\twallet: {\n\t\tconnectYourWallet: \"ÐÐ¾Ð²ÑÐ·ÐµÑÐµ Ð³Ð¾ Ð²Ð°ÑÐ¸Ð¾Ñ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº!\",\n\t\twhatIsAWallet: \"Ð¨ÑÐ¾ Ðµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº?\",\n\t\tsecureAndManage: \"ÐÐ°ÑÑÐ¸ÑÐµÑÐµ Ð³Ð¸ Ð¸ ÑÐ¿ÑÐ°Ð²ÑÐ²Ð°ÑÑÐµ ÑÐ¾ Ð²Ð°ÑÐ¸ÑÐµ Ð´Ð¸Ð³Ð¸ÑÐ°Ð»Ð½Ð¸ ÑÑÐµÐ´ÑÑÐ²Ð°.\",\n\t\tsafelyStore: \"ÐÐµÐ·Ð±ÐµÐ´Ð½Ð¾ ÑÐºÐ»Ð°Ð´Ð¸ÑÐ°ÑÑÐµ Ð¸ Ð¸Ð·Ð²ÑÑÑÐ²Ð°ÑÑÐµ ÑÑÐ°Ð½ÑÐ°ÐºÑÐ¸Ð¸ ÑÐ¾ Ð²Ð°ÑÐ¸ÑÐµ ÐºÑÐ¸Ð¿ÑÐ¾ Ð¸ NFT.\",\n\t\tlogInToAny: \"ÐÐ°ÑÐ°Ð²ÐµÑÐµ ÑÐµ Ð½Ð° ÐºÐ¾ÑÐ° Ð±Ð¸Ð»Ð¾ NEAR Ð°Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸ÑÐ°\",\n\t\tnoNeedToCreate: \"ÐÐµÐ¼Ð° Ð¿Ð¾ÑÑÐµÐ±Ð° Ð´Ð° ÐºÑÐµÐ¸ÑÐ°ÑÐµ Ð½Ð¾Ð²Ð¸ ÑÐ¼ÐµÑÐºÐ¸ Ð¸Ð»Ð¸ Ð¸Ð½Ð³ÐµÑÐµÐ½ÑÐ¸Ð¸. ÐÐ¾Ð²ÑÐ·ÐµÑÐµ Ð³Ð¾ Ð²Ð°ÑÐ¸Ð¾Ñ Ð¿Ð°ÑÐ¸ÑÐ½Ð¸Ðº Ð¸ ÑÑÐµ Ð¿Ð¾Ð´Ð³Ð¾ÑÐ²ÐµÐ½Ð¸!\",\n\t\tgetAWallet: \"ÐÐ°Ð¿ÑÐ°Ð²ÐµÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\tuseAWallet: \"ÐÐ¾ÑÐ¸ÑÑÐµÑÐµ Ð¿Ð°ÑÐ¸ÑÐ½Ð¸Ðº Ð·Ð° Ð´Ð° Ð³Ð¸ Ð·Ð°ÑÑÐ¸ÑÐ¸ÑÐµ Ð¸ ÑÐ¿ÑÐ°Ð²ÑÐ²Ð°ÑÐµ Ð²Ð°ÑÐ¸ÑÐµ NEAR ÑÑÐµÐ´ÑÑÐ²Ð° Ð¸ Ð´Ð° ÑÐµ Ð½Ð°ÑÐ°Ð²Ð¸ÑÐµ Ð½Ð° ÐºÐ¾ÑÐ° Ð±Ð¸Ð»Ð¾ NEAR Ð°Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸ÑÐ° Ð±ÐµÐ· Ð¿Ð¾ÑÑÐµÐ±Ð° Ð¾Ð´ ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ Ð¸Ð¼Ð¸ÑÐ° Ð¸ Ð»Ð¾Ð·Ð¸Ð½ÐºÐ¸.\",\n\t\tconnectionFailed: \"ÐÐ¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµÑÐ¾ Ð½Ðµ Ð±ÐµÑÐµ ÑÑÐ¿ÐµÑÐ½Ð¾.\",\n\t\tconnectionSuccessful: \"Ð£ÑÐ¿ÐµÑÐ½Ð¾ Ð¿Ð¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµ.\",\n\t\tconnected: \"ÐÐ¾Ð²ÑÐ·Ð°Ð½Ð¾.\",\n\t\tconnectingTo: \"ÐÐ¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµ ÑÐ¾\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"ÐÐ¾ÑÐ²ÑÐ´ÐµÑÐµ Ð³Ð¾ Ð¿Ð¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµÑÐ¾ Ð²Ð¾ ÐµÐºÑÑÐµÑÐ½Ð¸Ð¾Ñ Ð¿ÑÐ¾Ð·Ð¾ÑÐµÑ\",\n\t\t\tbrowser: \"ÐÐ¾ Ð¿ÑÐµÑÑÐ¼ÐµÑÑÐ²Ð°ÑÐµÑÐ¾, Ð¿Ð¾ÑÐ²ÑÐ´ÐµÑÐµ Ð³Ð¾ Ð¿Ð¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµÑÐ¾ Ð¾Ð´ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ð¾ÐºÑ\",\n\t\t\thardware: \"ÐÐ¾ÑÐ²ÑÐ´ÐµÑÐµ Ð³Ð¾ Ð¿Ð¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµÑÐ¾ ÑÐ¾ Ð»Ð°Ð´ÐµÐ½ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\tbridge: \"ÐÐ¾ÑÐ²ÑÐ´ÐµÑÐµ ÑÐ° Ð²ÑÑÐºÐ°ÑÐ° Ð²Ð¾ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸ÐºÐ¾Ñ\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"ÐÐ¾Ð²ÑÐ·ÐµÑÐµ ÑÐµ ÑÐ¾ ÐÐµÑÐµÑ\",\n\t\tmakeSureYourLedger: \"ÐÑÐ¸Ð³ÑÑÐ°ÑÑÐµ ÑÐµ Ð´ÐµÐºÐ° Ð²Ð°ÑÐ¸Ð¾Ñ ÐÐµÑÐµÑ Ðµ Ð¿Ð¾Ð²ÑÐ·Ð°Ð½ Ð±ÐµÐ·Ð±ÐµÐ´Ð½Ð¾, Ð¸ Ð´ÐµÐºÐ° NEAR Ð°Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸ÑÐ°ÑÐ° Ðµ Ð¾ÑÐ²Ð¾ÑÐµÐ½Ð° Ð½Ð° Ð²Ð°ÑÐ¸Ð¾Ñ ÑÑÐµÐ´\",\n\t\t\"continue\": \"ÐÑÐ¾Ð´Ð¾Ð»Ð¶ÐµÑÐµ\",\n\t\tspecifyHDPath: \"ÐÐ°Ð²ÐµÐ´ÐµÑÐµ Ð¥Ð Ð»Ð¾ÐºÐ°ÑÐ¸ÑÐ°\",\n\t\tenterYourPreferredHDPath: \"ÐÐ½ÐµÑÐµÑÐµ ÑÐ° Ð²Ð°ÑÐ°ÑÐ° Ð¿ÑÐµÑÐµÑÐ¸ÑÐ°Ð½Ð° Ð¥Ð Ð»Ð¾ÐºÐ°ÑÐ¸ÑÐ°, Ð° Ð¿Ð¾ÑÐ¾Ð° ÑÐºÐµÐ½Ð¸ÑÐ°ÑÑÐµ Ð´Ð° Ð³Ð¸ Ð½Ð°ÑÐ´ÐµÑÐµ Ð°ÐºÑÐ¸Ð²Ð½Ð¸ÑÐµ ÑÐ¼ÐµÑÐºÐ¸.\",\n\t\tscan: \"Ð¡ÐºÐµÐ½Ð¸ÑÐ°ÑÑÐµ\",\n\t\tretry: \"ÐÐ±Ð¸Ð´ÐµÑÐµ ÑÐµ Ð¿Ð¾Ð²ÑÐ¾ÑÐ½Ð¾\",\n\t\tledgerIsNotAvailable: \"ÐÐµÑÐµÑÐ¾Ñ Ð½Ðµ Ðµ Ð´Ð¾ÑÑÐ°Ð¿ÐµÐ½.\",\n\t\taccessDeniedToUseLedgerDevice: \"ÐÑÐ¸ÑÑÐ°Ð¿Ð¾Ñ Ð·Ð° ÐºÐ¾ÑÐ¸ÑÑÐµÑÐµ Ð½Ð° ÐÐµÑÐµÑ ÑÑÐµÐ´ Ðµ Ð¾Ð´Ð±Ð¸ÐµÐ½\",\n\t\tnoAccountsFound: \"ÐÐµÐ¼Ð° Ð½Ð°ÑÐ´ÐµÐ½Ð¸ ÑÐ¼ÐµÑÐºÐ¸\",\n\t\tselectYourAccounts: \"ÐÐ·Ð±ÐµÑÐµÑÐµ Ð³Ð¸ Ð²Ð°ÑÐ¸ÑÐµ ÑÐ¼ÐµÑÐºÐ¸\",\n\t\tconnecting1Account: \"ÐÐ¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµ Ð½Ð° ÐµÐ´Ð½Ð° ÑÐ¼ÐµÑÐºÐ°\",\n\t\tcantFindAnyAccount: \"ÐÐµ ÑÐµ Ð½Ð°ÑÐ´ÐµÐ½Ð¸ ÑÐ¼ÐµÑÐºÐ¸ Ð¿Ð¾Ð²ÑÐ·Ð°Ð½Ð¸ ÑÐ¾ Ð¾Ð²Ð¾Ñ ÐÐµÑÐµÑ. ÐÐµ Ð¼Ð¾Ð»Ð¸Ð¼Ðµ ÐºÑÐµÐ¸ÑÐ°ÑÑÐµ Ð½Ð¾Ð²Ð° NEAR ÑÐ¼ÐµÑÐºÐ° \",\n\t\torConnectAnAnotherLedger: \"Ð¸Ð»Ð¸ Ð¿Ð¾Ð²ÑÐ·ÐµÑÐµ Ð´ÑÑÐ³ ÐÐµÑÐµÑ.\",\n\t\tconnecting: \"ÐÐ¾Ð²ÑÐ·ÑÐ²Ð°ÑÐµ\",\n\t\tofAccounts: \"Ð½Ð° ÑÐ¼ÐµÑÐºÐ¸\",\n\t\tfailedToAutomatically: \"ÐÐµÑÑÐ¿ÐµÑÐ½Ð¾ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÑÐºÐ¾ Ð±Ð°ÑÐ°ÑÐµ Ð½Ð° ÐÐ Ð½Ð° ÑÐ¼ÐµÑÐºÐ°ÑÐ°. ÐÐ½ÐµÑÐµÑÐµ Ð³Ð¾ ÑÐ°ÑÐ½Ð¾:\",\n\t\toverviewTheListOfAuthorized: \"ÐÑÐµÐ³Ð»ÐµÐ´ Ð½Ð° Ð»Ð¸ÑÑÐ°ÑÐ° Ð½Ð° Ð¾Ð²Ð»Ð°ÑÑÐµÐ½Ð¸ ÑÐ¼ÐµÑÐºÐ¸, Ð·Ð°Ð²ÑÑÐµÑÐµ ÑÐµ Ð½Ð°ÑÐ°Ð²Ð°ÑÐ° ÑÐ¾ ÐºÐ»Ð¸ÐºÐ½ÑÐ²Ð°ÑÐµ Ð½Ð° ÐºÐ¾Ð¿ÑÐµÑÐ¾ Ð¿Ð¾Ð´Ð¾Ð»Ñ.\",\n\t\tfinish: \"ÐÐ°Ð²ÑÑÐµÑÐµ\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Ð¢ÑÐµÐ±Ð° Ð´Ð° Ð¸Ð½ÑÑÐ°Ð»Ð¸ÑÐ°ÑÐµ\",\n\t\ttoContinueAfterInstalling: \"Ð·Ð° Ð´Ð° Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶Ð¸ÑÐµ. ÐÐ¾ Ð¸Ð½ÑÑÐ°Ð»Ð¸ÑÐ°ÑÐµÑÐ¾\",\n\t\trefreshThePage: \"ÐÑÐ²ÐµÐ¶ÐµÑÐµ ÑÐ° ÑÑÑÐ°Ð½Ð°ÑÐ°.\",\n\t\topen: \"ÐÑÐ²Ð¾ÑÐµÑÐµ\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"ÐÐ¾Ð¿Ð¸ÑÐ°Ð½Ð¾ Ð½Ð° ÐºÐ»Ð¸Ð¿Ð±Ð¾ÑÐ´Ð¾Ñ\",\n\t\tfailedToCopy: \"ÐÐµÑÑÐ¿ÐµÑÐ½Ð¾ ÐºÐ¾Ð¿Ð¸ÑÐ°ÑÐµ Ð½Ð° ÐºÐ»Ð¸Ð¿Ð±Ð¾ÑÐ´\",\n\t\tscanWithYourMobile: \"Ð¡ÐºÐµÐ½Ð¸ÑÐ°ÑÑÐµ ÑÐ¾ Ð²Ð°ÑÐ¸Ð¾Ñ ÑÐµÐ»ÐµÑÐ¾Ð½ÑÐºÐ¸ ÑÑÐµÐ´\",\n\t\tcopyToClipboard: \"ÐÐ¾Ð¿Ð¸ÑÐ°ÑÑÐµ Ð½Ð° ÐºÐ»Ð¸Ð¿Ð±Ð¾ÑÐ´\",\n\t\tpreferTheOfficial: \"ÐÑÐµÑÐµÑÐ¸ÑÐ°ÑÑÐµ Ð¾ÑÐ¸ÑÐ¸ÑÐ°Ð»ÐµÐ½ Ð´Ð¸Ð°Ð»Ð¾Ð³ Ð½Ð°\",\n\t\topen: \"ÐÑÐ²Ð¾ÑÐµÑÐµ\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Ð¥Ð°ÑÐ´Ð²ÐµÑÑÐºÐ¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\tbrowser: \"ÐÐ¾Ð²ÑÐ°Ð½Ð¸Ðº Ð½Ð° Ð¸Ð½ÑÐµÑÐ½ÐµÑ Ð¿ÑÐµÐ»Ð¸ÑÑÑÐ²Ð°Ñ\",\n\t\tinjected: \"ÐÐºÑÑÐµÐ½Ð·Ð¸ÑÐ° Ð·Ð° Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\tbridge: \"Bridge Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\tmobile: \"ÐÐ¾Ð±Ð¸Ð»ÐµÐ½ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\"instant-link\": \"ÐÐ½ÑÑÐ°Ð½Ñ Ð¿Ð°ÑÐ¸ÑÐ½Ð¸Ðº\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"ÐÐ´Ð±ÐµÑÐµÑÐµ Ð¿Ð°ÑÐ¸ÑÐ½Ð¸Ðº\",\n\t\ttransferYourAccounts: \"ÐÑÐµÑÑÐ»ÐµÑÐµ Ð³Ð¸ Ð²Ð°ÑÐ¸ÑÐµ ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ ÑÐ¼ÐµÑÐºÐ¸\",\n\t\tselectAWallet: \"ÐÐ·Ð±ÐµÑÐµÑÐµÐ½ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº ÐºÐ¾Ñ Ð³Ð¸ Ð·Ð°Ð´Ð¾Ð²Ð¾Ð»ÑÐ²Ð° Ð²Ð°ÑÐ¸ÑÐµ Ð±Ð°ÑÐ°Ð½ÑÐ° Ð¸ Ð³Ð¸ Ð¿Ð¾Ð´Ð´ÑÐ¶ÑÐ²Ð° Ð²Ð°ÑÐ¸ÑÐµ Ð¿Ð¾Ð²ÑÐ·Ð°Ð½Ð¸ ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ ÑÐ¼ÐµÑÐºÐ¸.\",\n\t\tselectYourAccounts: \"ÐÐ·Ð±ÐµÑÐµÑÐµ Ð³Ð¸ Ð²Ð°ÑÐ¸ÑÐµ ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ ÑÐ¼ÐµÑÐºÐ¸\",\n\t\tafterDecide: \"ÐÐ´ÐºÐ°ÐºÐ¾ ÑÐµ Ð¸Ð·Ð±ÐµÑÐµÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº, Ð¼Ð¾Ð¶ÐµÑÐµ Ð´Ð° Ð¸Ð·Ð±ÐµÑÐµÑÐµ ÐºÐ¾Ð¸ ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ ÑÐ¼ÐµÑÐºÐ¸ ÑÐ°ÐºÐ°ÑÐµ Ð´Ð° Ð³Ð¸ Ð¿ÑÐµÑÑÐ»Ð¸ÑÐµ.\",\n\t\tdisclaimer: \"ÐÐµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð´Ð° Ð¿ÑÑÑÐ»Ð°ÑÐµ ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ ÑÐ¼ÐµÑÐºÐ¸ ÐºÐ¾Ð¸ Ð½Ð¸ÐºÐ¾Ð³Ð°Ñ Ð½Ðµ Ð±Ð¸Ð»Ðµ Ð½Ð°Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð°ÑÐ¸ Ð¸Ð»Ð¸ ÐºÐ¾ÑÐ¸ÑÑÐµÐ½Ð¸ Ð½Ð° NEAR.\",\n\t\twarning: \"Ð½Ðµ Ð¿Ð¾Ð´Ð´ÑÐ¶ÑÐ²Ð° Ð¸Ð·Ð²ÐµÐ·ÑÐ²Ð°ÑÐµ Ð½Ð° ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ ÑÐ¼ÐµÑÐºÐ¸ Ð²Ð¾ Ð¾Ð²Ð¾Ñ Ð¼Ð¾Ð¼ÐµÐ½Ñ. ÐÐµ Ð¼Ð¾Ð»Ð¸Ð¼Ðµ Ð¸Ð·Ð±ÐµÑÐµÑÐµ Ð´ÑÑÐ³ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Ð¥Ð°ÑÐ´Ð²ÐµÑÑÐºÐ¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\tbrowser: \"ÐÐ¾Ð²ÑÐ°Ð½Ð¸Ðº Ð½Ð° Ð¸Ð½ÑÐµÑÐ½ÐµÑ Ð¿ÑÐµÐ»Ð¸ÑÑÑÐ²Ð°Ñ\",\n\t\t\tinjected: \"ÐÐºÑÑÐµÐ½Ð·Ð¸ÑÐ° Ð·Ð° Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\tbridge: \"Bridge Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\tmobile: \"ÐÐ¾Ð±Ð¸Ð»ÐµÐ½ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"ÐÐ·Ð±ÐµÑÐµÑÐµ Ð³Ð¸ ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸ÑÐµ ÑÐ¼ÐµÑÐºÐ¸ Ð·Ð° Ð´Ð° Ð³Ð¸ Ð¿ÑÐµÑÑÐ»Ð¸ÑÐµ.\",\n\t\t\tbutton: \"ÐÐ¾Ð±Ð¸ÑÑÐµ Ð»Ð¾Ð·Ð¸Ð½ÐºÐ°\",\n\t\t\tdeselectAll: \"ÐÑÑÐµÐ»ÐµÐºÑÐ¸ÑÐ°ÑÑÐµ ÑÐµ\",\n\t\t\tselectAll: \"ÐÐ·Ð±ÐµÑÐµÑÐµ ÑÐµ\",\n\t\t\tunavailable: \"Ð¢ÑÐ°Ð½ÑÑÐµÑÐ¾Ñ Ðµ Ð½ÐµÐ´Ð¾ÑÑÐ°Ð¿ÐµÐ½\",\n\t\t\terror: \"ÐÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ°ÑÐ° ÑÐ¼ÐµÑÐºÐ° Ð½Ðµ Ð¿Ð¾ÑÑÐ¾Ð¸\",\n\t\t\twarningLedger: \"ÐÐ¾ÑÑÐµÐ±Ð½Ð° Ðµ Ð¿Ð¾Ð´Ð´ÑÑÐºÐ° Ð¾Ð´ ÐÐµÑÐµÑ\",\n\t\t\tnoBalance: \"Ð¡Ð¼ÐµÑÐºÐ°ÑÐ° Ð½Ðµ Ðµ ÑÐ¸Ð½Ð°Ð½ÑÐ¸ÑÐ°Ð½Ð°\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"ÐÐ¾Ð¿Ð¸ÑÐ°ÑÑÐµ ÑÐ° Ð¿ÑÐ¸Ð²ÑÐµÐ¼ÐµÐ½Ð°ÑÐ° Ð»Ð¾Ð·Ð¸Ð½ÐºÐ°\",\n\t\t\tdesc: \"ÐÐµ ÑÑÐµÐ±Ð° Ð´Ð° ÑÐ° Ð²Ð½ÐµÑÐµÑÐµ Ð¾Ð²Ð°Ð° Ð»Ð¾Ð·Ð¸Ð½ÐºÐ° ÐºÐ¾Ð³Ð° ÑÐµ Ð·Ð°Ð¿Ð¾ÑÐ½ÐµÑÐµ Ð´Ð° Ð³Ð¸ Ð¸Ð·Ð²ÐµÐ·ÑÐ²Ð°ÑÐµ Ð²Ð°ÑÐ¸ÑÐµ ÑÐ¼ÐµÑÐºÐ¸ Ð½Ð° Ð´ÑÑÐ³ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº.\",\n\t\t\tbutton: \"ÐÑÐ¾Ð´Ð¾Ð»Ð¶ÐµÑÐµ\",\n\t\t\tlabel: \"ÐÐ»Ð¸ÐºÐ½ÐµÑÐµ Ð·Ð° Ð´Ð° ÐºÐ¾Ð¿Ð¸ÑÐ°ÑÐµ\",\n\t\t\tcheckLabel: \"ÐÐ° ÐºÐ¾Ð¿Ð¸ÑÐ°Ð² Ð¸Ð»Ð¸ Ð·Ð°Ð¿Ð¸ÑÐ°Ð² Ð»Ð¾Ð·Ð¸Ð½ÐºÐ°ÑÐ°\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"ÐÐ°Ð²ÑÑÐµÑÐµ Ð³Ð¾ Ð¿ÑÐµÐ½Ð¾ÑÐ¾Ñ\",\n\t\t\tdescOne: \"Ð¡ÐµÐ³Ð° ÑÐµ Ð±Ð¸Ð´ÐµÑÐµ Ð¿ÑÐµÐ½Ð°ÑÐ¾ÑÐµÐ½Ð¸ Ð½Ð° Ð¸Ð·Ð±ÑÐ°Ð½Ð¸Ð¾Ñ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº Ð·Ð° Ð·Ð°Ð²ÑÑÑÐ²Ð°ÑÐµ Ð½Ð° Ð¿ÑÐµÐ½Ð¾ÑÐ¾Ñ.\",\n\t\t\tdescTwo: \"ÐÑÐºÐ°ÐºÐ¾ ÑÐµ Ð·Ð°Ð²ÑÑÐ¸ ÑÐ²Ð¾Ð·Ð¾Ñ Ð¾Ð´ Ð¸Ð·Ð±ÑÐ°Ð½Ð¸Ð¾Ñ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº, Ð¿ÑÐ¸ÑÐ¸ÑÐ½ÐµÑÐµ Ð³Ð¾ ÐºÐ¾Ð¿ÑÐµÑÐ¾ Ð·Ð° Ð´Ð° Ð³Ð¾ Ð·Ð°Ð²ÑÑÐ¸ÑÐµ Ð¿ÑÐµÐ½Ð¾ÑÐ¾Ñ.\",\n\t\t\tbutton: \"ÐÐ°Ð²ÑÑÐµÑÐµ\"\n\t\t}\n\t}\n};\nvar mk = {\n\tmodal: modal$2\n};\n\nvar modal$1 = {\n\twallet: {\n\t\tconnectYourWallet: \"PoveÅ¾ite svojo denarnico!\",\n\t\twhatIsAWallet: \"Kaj je denarnica?\",\n\t\tsecureAndManage: \"Zavarujte in upravljajte svoja digitalna sredstva.\",\n\t\tsafelyStore: \"Varno shranjujte in prenaÅ¡ajte svoje kriptovalute in NFTje.\",\n\t\tlogInToAny: \"Prijavite se v katero koli aplikacijo na NEAR\",\n\t\tnoNeedToCreate: \"Ni vam treba ustvarjati novih raÄunov. PoveÅ¾ite svojo denarnico in zaÄnite!\",\n\t\tgetAWallet: \"Ustvarite denarnico\",\n\t\tuseAWallet: \"Uporabite denarnico, da bi zavarovali in upravljali s svoja NEAR digitalna sredstva, in se prijavite v katero koli aplikacijo ekosistema NEAR\",\n\t\tconnectionFailed: \"Povezava ni bila uspeÅ¡na.\",\n\t\tconnectionSuccessful: \"Povezava je bila uspeÅ¡na.\",\n\t\tconnected: \"VaÅ¡a denarnica je povezana.\",\n\t\tconnectingTo: \"Povezovanje z\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"Potrdite povezavo v oknu razÅ¡iritve\",\n\t\t\tbrowser: \"Po preusmeritvi potrdite povezavo v denarnici\",\n\t\t\thardware: \"Potrdite povezavo s hladno denarnico\",\n\t\t\tbridge: \"Potrdite povezavo v denarnici\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"PoveÅ¾ite se z Ledger\",\n\t\tmakeSureYourLedger: \"PrepriÄajte se, da je vaÅ¡ Ledger varno povezan in da je aplikacija NEAR odprta v vaÅ¡i napravi\",\n\t\t\"continue\": \"Nadaljuj\",\n\t\tspecifyHDPath: \"DoloÄite HD pot\",\n\t\tenterYourPreferredHDPath: \"Vnesite Å¾eleno HD pot, nato poiÅ¡Äite vse aktivne raÄune.\",\n\t\tscan: \"Skenirajte\",\n\t\tretry: \"Poskusite znova\",\n\t\tledgerIsNotAvailable: \"Ledger ni na voljo\",\n\t\taccessDeniedToUseLedgerDevice: \"Dostop za uporabo naprave Ledger zavrnjen\",\n\t\tnoAccountsFound: \"Ni najdenih raÄunov\",\n\t\tselectYourAccounts: \"Izberite VaÅ¡i raÄuni\",\n\t\tconnecting1Account: \"Povezovanje enega raÄuna\",\n\t\tcantFindAnyAccount: \"Ni mogoÄe najti nobenega raÄuna, povezanega s tem Ledgerjem. Ustvarite nov NEAR raÄun \",\n\t\torConnectAnAnotherLedger: \"ali poveÅ¾ite drug Ledger..\",\n\t\tconnecting: \"Povezovanje\",\n\t\tofAccounts: \"raÄunov\",\n\t\tfailedToAutomatically: \"ID-ja raÄuna ni bilo mogoÄe samodejno najti. Zagotovite ga roÄno:\",\n\t\toverviewTheListOfAuthorized: \"Oglejte si seznam pooblaÅ¡Äenih raÄunov, dokonÄajte prijavo s klikom na spodnji gumb.\",\n\t\tfinish: \"KonÄajte\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"Morali ga boste namestiti\",\n\t\ttoContinueAfterInstalling: \"nadaljevati. Po namestitvi\",\n\t\trefreshThePage: \"OsveÅ¾ite stran.\",\n\t\topen: \"Odprite\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"Kopirano v podloÅ¾ni mapi\",\n\t\tfailedToCopy: \"Kopiranje v podloÅ¾ni mapi ni uspelo\",\n\t\tscanWithYourMobile: \"Skenirajte s svojo mobilno napravo\",\n\t\tcopyToClipboard: \" Kopirajte v podloÅ¾ni mapi\",\n\t\tpreferTheOfficial: \"Preferirajte uradno pogovorno okno\",\n\t\topen: \"Odprite\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Hladna denarnica\",\n\t\tbrowser: \"Denarnica brskalnika\",\n\t\tinjected: \"RazÅ¡iritev za denarnico\",\n\t\tbridge: \"Bridge denarnica\",\n\t\tmobile: \"Mobilna denarnica\",\n\t\t\"instant-link\": \"TakojÅ¡nja denarnica\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"Izberite denarnico\",\n\t\ttransferYourAccounts: \"Prenesite svoje raÄune\",\n\t\tselectAWallet: \"Izberite denarnico, ki ustreza vaÅ¡im potrebam in podpira vaÅ¡e povezane raÄune.\",\n\t\tselectYourAccounts: \"Izberite vaÅ¡i raÄuni\",\n\t\tafterDecide: \"Ko se odloÄite za denarnico, lahko izberete, katere raÄune Å¾elite prenesti.\",\n\t\tdisclaimer: \"Ne boste mogli prenesti RaÄunov, ki nikoli niso bili financirani ali uporabljeni na NEAR.\",\n\t\twarning: \"trenutno ne podpira izvoza raÄuna. Izberite drugo denarnico\",\n\t\twalletTypes: {\n\t\t\thardware: \"Hladna denarnica\",\n\t\t\tbrowser: \"Denarnica brskalnika\",\n\t\t\tinjected: \"RazÅ¡iritev za denarnico\",\n\t\t\tbridge: \"Bridge denarnica\",\n\t\t\tmobile: \"Mobilna denarnica\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"Izberite raÄuni za prenos.\",\n\t\t\tbutton: \"Pridobite geslo\",\n\t\t\tdeselectAll: \"PrekliÄi izbiro vseh\",\n\t\t\tselectAll: \"Izberi vse\",\n\t\t\tunavailable: \"Prenos ni na voljo\",\n\t\t\terror: \"RaÄun ne obstaja\",\n\t\t\twarningLedger: \"Potrebna je podpora za Ledger\",\n\t\t\tnoBalance: \"RaÄun ni financiran\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"Kopiraj zaÄasno geslo\",\n\t\t\tdesc: \"To geslo boste morali vnesti, ko boste zaÄeli izvaÅ¾ati svoje raÄune v drugo denarnico.\",\n\t\t\tbutton: \"Nadaljujte\",\n\t\t\tlabel: \"Kliknite za kopiranje\",\n\t\t\tcheckLabel: \"Geslo sem kopiral ali zapisal\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"DokonÄajte prenos\",\n\t\t\tdescOne: \"Zdaj boste preusmerjeni v denarnico, ki ste jo izbrali za dokonÄanje prenosa.\",\n\t\t\tdescTwo: \"Ko je uvozni del postopka konÄan iz izbrane denarnice, pritisnite gumb za dokonÄanje postopka prenosa.\",\n\t\t\tbutton: \"KonÄajte\"\n\t\t}\n\t}\n};\nvar sl = {\n\tmodal: modal$1\n};\n\nvar modal = {\n\twallet: {\n\t\tconnectYourWallet: \"ÐÐ¾Ð²ÐµÐ¶Ð¸ÑÐµ ÑÐ²Ð¾Ñ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº!\",\n\t\twhatIsAWallet: \"Ð¨ÑÐ° ÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº?\",\n\t\tsecureAndManage: \"ÐÐ±ÐµÐ·Ð±ÐµÐ´Ð¸ÑÐµ Ð¸ ÑÐ¿ÑÐ°Ð²ÑÐ°ÑÑÐµ ÑÐ²Ð¾ÑÐ¾Ð¼ Ð´Ð¸Ð³Ð¸ÑÐ°Ð»Ð½Ð¾Ð¼ Ð¸Ð¼Ð¾Ð²Ð¸Ð½Ð¾Ð¼.\",\n\t\tsafelyStore: \"ÐÐµÐ·Ð±ÐµÐ´Ð½Ð¾ ÑÑÐ²Ð°ÑÑÐµ Ð¸ Ð¿ÑÐµÐ½Ð¾ÑÐ¸ÑÐµ ÑÐ²Ð¾ÑÐµ ÐºÑÐ¸Ð¿ÑÐ¾Ð²Ð°Ð»ÑÑÐµ Ð¸ NFT.\",\n\t\tlogInToAny: \"ÐÑÐ¸ÑÐ°Ð²Ð¸ÑÐµ ÑÐµ Ð½Ð° Ð±Ð¸Ð»Ð¾ ÐºÐ¾ÑÑ Ð°Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸ÑÑ NEAR\",\n\t\tnoNeedToCreate: \"ÐÐµÐ¼Ð° Ð¿Ð¾ÑÑÐµÐ±Ðµ Ð´Ð° ÐºÑÐµÐ¸ÑÐ°ÑÐµ Ð½Ð¾Ð²Ðµ Ð½Ð°Ð»Ð¾Ð³Ðµ Ð¸Ð»Ð¸ Ð°ÐºÑÐµÐ´Ð¸ÑÐ¸Ð²Ðµ. ÐÐ¾Ð²ÐµÐ¶Ð¸ÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº Ð¸ ÑÐ¿ÑÐµÐ¼Ð½Ð¸ ÑÑe!\",\n\t\tgetAWallet: \"ÐÐ°Ð±Ð°Ð²Ð¸ÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\tuseAWallet: \"ÐÐ¾ÑÐ¸ÑÑÐ¸ÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº Ð´Ð° Ð¾Ð±ÐµÐ·Ð±ÐµÐ´Ð¸ÑÐµ Ð¸ ÑÐ¿ÑÐ°Ð²ÑÐ°ÑÐµ ÑÐ²Ð¾ÑÐ¸Ð¼ NEAR ÑÑÐµÐ´ÑÑÐ²Ð¸Ð¼Ð° Ð¸ Ð´Ð° ÑÐµ Ð¿ÑÐ¸ÑÐ°Ð²Ð¸ÑÐµ Ñ Ð±Ð¸Ð»Ð¾ ÐºÐ¾ÑÑ Ð°Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸ÑÑ NEAR Ð±ÐµÐ· Ð¿Ð¾ÑÑÐµÐ±Ðµ Ð·Ð° ÐºÐ¾ÑÐ¸ÑÐ½Ð¸ÑÐºÐ¸Ð¼ Ð¸Ð¼ÐµÐ½Ð¸Ð¼Ð° Ð¸ Ð»Ð¾Ð·Ð¸Ð½ÐºÐ°Ð¼Ð°.\",\n\t\tconnectionFailed: \"ÐÐµÐ·Ð° Ð½Ð¸ÑÐµ ÑÑÐ¿Ð¾ÑÑÐ°Ð²ÑÐµÐ½Ð°.\",\n\t\tconnectionSuccessful: \"ÐÐµÐ·Ð° ÑÐµ ÑÑÐ¿ÐµÐ»Ð°.\",\n\t\tconnected: \"ÐÐ¾Ð²ÐµÐ·Ð°Ð½.\",\n\t\tconnectingTo: \"ÐÐ¾Ð²ÐµÐ·Ð¸Ð²Ð°ÑÐµ Ð½Ð°\",\n\t\tconnectingMessage: {\n\t\t\tinjected: \"ÐÐ¾ÑÐ²ÑÐ´Ð¸ÑÐµ Ð²ÐµÐ·Ñ Ñ ÑÐ¿Ð¾ÑÐ½Ð¾Ð¼ Ð¿ÑÐ¾Ð·Ð¾ÑÑ\",\n\t\t\tbrowser: \"ÐÐ°ÐºÐ¾Ð½ Ð¿ÑÐµÑÑÐ¼ÐµÑÐ°Ð²Ð°ÑÐ°, Ð¿Ð¾ÑÐ²ÑÐ´Ð¸ÑÐµ Ð²ÐµÐ·Ñ Ñ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸ÐºÑ\",\n\t\t\thardware: \"ÐÐ¾ÑÐ²ÑÐ´Ð¸ÑÐµ Ð²ÐµÐ·Ñ ÑÐ° ÑÐ»Ð°Ð´Ð½Ð¸Ð¼ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸ÐºÐ¾Ð¼\",\n\t\t\tbridge: \"ÐÐ¾ÑÐ²ÑÐ´Ð¸ÑÐµ Ð²ÐµÐ·Ñ ÑÐ° Ð½Ð¾Ð²ÑÐ°Ð½Ð¸ÐºÐ¾Ð¼\"\n\t\t}\n\t},\n\tledger: {\n\t\tconnectWithLedger: \"ÐÐ¾Ð²ÐµÐ¶Ð¸ÑÐµ ÑÐµ ÑÐ° Ledger\",\n\t\tmakeSureYourLedger: \"Ð£Ð²ÐµÑÐ¸ÑÐµ ÑÐµ Ð´Ð° ÑÐµ Ð²Ð°Ñ Ledger Ð±ÐµÐ·Ð±ÐµÐ´Ð½Ð¾ Ð¿Ð¾Ð²ÐµÐ·Ð°Ð½ Ð¸ Ð´Ð° ÑÐµ Ð°Ð¿Ð»Ð¸ÐºÐ°ÑÐ¸ÑÐ° NEAR Ð¾ÑÐ²Ð¾ÑÐµÐ½Ð° Ð½Ð° Ð²Ð°ÑÐµÐ¼ ÑÑÐµÑÐ°ÑÑ\",\n\t\t\"continue\": \"ÐÐ°ÑÑÐ°Ð²Ð¸\",\n\t\tspecifyHDPath: \"ÐÐ°Ð²ÐµÐ´Ð¸ÑÐµ Ð¥Ð Ð¿ÑÑÐ°ÑÑ\",\n\t\tenterYourPreferredHDPath: \"Ð£Ð½ÐµÑÐ¸ÑÐµ Ð¶ÐµÑÐµÐ½Ñ Ð¶ÐµÑÐµÐ½Ñ Ð¥Ð Ð¿ÑÑÐ°ÑÑ, Ð° Ð·Ð°ÑÐ¸Ð¼ ÑÐºÐµÐ½Ð¸ÑÐ°ÑÑÐµ ÑÐ²Ðµ Ð°ÐºÑÐ¸Ð²Ð½Ðµ Ð½Ð°Ð»Ð¾Ð³Ðµ.\",\n\t\tscan: \"Ð¡ÐºÐµÐ½Ð¸ÑÐ°ÑÑÐµ\",\n\t\tretry: \"ÐÐ¾ÐºÑÑÐ°Ñ Ð¿Ð¾Ð½Ð¾Ð²Ð¾\",\n\t\tledgerIsNotAvailable: \"Ledger Ð½Ð¸ÑÐµ Ð´Ð¾ÑÑÑÐ¿Ð°Ð½.\",\n\t\taccessDeniedToUseLedgerDevice: \"ÐÑÐ¸ÑÑÑÐ¿ ÑÐµ Ð¾Ð´Ð±Ð¸ÑÐµÐ½ Ð·Ð° ÐºÐ¾ÑÐ¸ÑÑÐµÑÐµ Ledger ÑÑÐµÑÐ°ÑÐ°\",\n\t\tnoAccountsFound: \"ÐÐ°lÐ¾Ð·Ð¸ Ð½Ð¸ÑÑ Ð¿ÑÐ¾Ð½Ð°ÑÐµÐ½Ð¸\",\n\t\tselectYourAccounts: \"ÐÐ·Ð°Ð±ÐµÑÐ¸ÑÐµ ÐÐ°Ñ Ð½Ð°lÐ¾Ð³\",\n\t\tconnecting1Account: \"ÐÐ¾Ð²ÐµÐ·Ð°ÑÐ¸ 1 Ð½Ð°lÐ¾Ð³\",\n\t\tcantFindAnyAccount: \"ÐÐ¸ÑÐµ Ð¼Ð¾Ð³ÑÑÐµ Ð¿ÑÐ¾Ð½Ð°ÑÐ¸ Ð½Ð¸ÑÐµÐ´Ð°Ð½ Ð½Ð°lÐ¾Ð³ Ð¿Ð¾Ð²ÐµÐ·Ð°Ð½ ÑÐ° Ð¾Ð²Ð¸Ð¼ Ledger-Ð¾Ð¼. ÐÐ°Ð¿ÑÐ°Ð²Ð¸ÑÐµ Ð½Ð¾Ð²Ð¸ NEAR Ð½Ð°lÐ¾Ð³\",\n\t\torConnectAnAnotherLedger: \"Ð¸Ð»Ð¸ Ð¿Ð¾Ð²ÐµÐ¶Ð¸ÑÐµ Ð´ÑÑÐ³Ð¸ Ledger.\",\n\t\tconnecting: \"ÐÐ¾Ð²ÐµÐ·Ð¸Ð²Ð°ÑÐµ\",\n\t\tofAccounts: \"Ð½Ð°lÐ¾Ð³Ð°\",\n\t\tfailedToAutomatically: \"ÐÑÑÐ¾Ð¼Ð°ÑÑÐºÐ¾ Ð¿ÑÐ¾Ð½Ð°Ð»Ð°Ð¶ÐµÑÐµ ID-a Ð½Ð°lÐ¾Ð³Ð° Ð½Ð¸ÑÐµ ÑÑÐ¿ÐµÐ»Ð¾. ÐÐ°Ð²ÐµÐ´Ð¸ÑÐµ Ð³Ð° ÑÑÑÐ½Ð¾:\",\n\t\toverviewTheListOfAuthorized: \"ÐÑÐµÐ³Ð»ÐµÐ´Ð°ÑÑÐµ Ð»Ð¸ÑÑÑ Ð¾Ð²Ð»Ð°ÑÑÐµÐ½Ð¸Ñ ÑÐ°ÑÑÐ½Ð°, Ð·Ð°Ð²ÑÑÐ¸ÑÐµ Ð¿ÑÐ¸ÑÐ°Ð²Ñ ÐºÐ»Ð¸ÐºÐ¾Ð¼ Ð½Ð° Ð´ÑÐ³Ð¼Ðµ Ð¸ÑÐ¿Ð¾Ð´.\",\n\t\tfinish: \"ÐÐ°Ð²ÑÑÐ¸\"\n\t},\n\tinstall: {\n\t\tyoullNeedToInstall: \"ÐÐ¾ÑÐ°ÑÐµÑÐµ Ð´Ð° Ð¸Ð½ÑÑÐ°Ð»Ð¸ÑÐ°ÑÐµ\",\n\t\ttoContinueAfterInstalling: \"Ð·Ð° Ð½Ð°ÑÑÐ°Ð²Ð°Ðº. ÐÐ°ÐºÐ¾Ð½ Ð¸Ð½ÑÑÐ°Ð»Ð¸ÑÐ°ÑÐ°\",\n\t\trefreshThePage: \"Ð¿Ð¾Ð½Ð¾Ð²Ð¾ ÑÑÐ¸ÑÐ°ÑÐ¸ ÑÑÑÐ°Ð½Ð¸ÑÑ.\",\n\t\topen: \"ÐÑÐ²Ð¾ÑÐ¸\"\n\t},\n\tqr: {\n\t\tcopiedToClipboard: \"ÐÐ¾Ð¿Ð¸ÑÐ°Ð½Ð¾ Ñ Ð¼ÐµÑÑÑÐ¿ÑÐµÐ¼Ð½Ð¸Ðº\",\n\t\tfailedToCopy: \"ÐÐ¾Ð¿Ð¸ÑÐ°ÑÐµ Ñ Ð¼ÐµÑÑÑÐ¿ÑÐµÐ¼Ð½Ð¸Ðº Ð½Ð¸ÑÐµ ÑÑÐ¿ÐµÐ»Ð¾\",\n\t\tscanWithYourMobile: \"Ð¡ÐºÐµÐ½Ð¸ÑÐ°ÑÑÐµ Ð¿Ð¾Ð¼Ð¾ÑÑ Ð¼Ð¾Ð±Ð¸Ð»Ð½Ð¾Ð³ ÑÑÐµÑÐ°ÑÐ°\",\n\t\tcopyToClipboard: \" ÐÐ¾Ð¿Ð¸ÑÐ°Ñ Ñ Ð¼ÐµÑÑÑÐ¿ÑÐµÐ¼Ð½Ð¸Ðº\",\n\t\tpreferTheOfficial: \"ÐÑÐµÑÐµÑÐ¸ÑÐ°ÑÐµ Ð·Ð²Ð°Ð½Ð¸ÑÐ½Ð¸ Ð´Ð¸ÑÐ°Ð»Ð¾Ð³ Ð¾Ð´\",\n\t\topen: \"ÐÑÐ²Ð¾ÑÐ¸\"\n\t},\n\twalletTypes: {\n\t\thardware: \"Ð¥Ð°ÑÐ´Ð²ÐµÑÑÐºÐ¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\tbrowser: \"ÐÐ¾Ð²ÑÐ°Ð½Ð¸Ðº Ð¿ÑÐµÑÑÐ°Ð¶Ð¸Ð²Ð°ÑÐ°,\",\n\t\tinjected: \"ÐÐ¾Ð´Ð°ÑÐ°Ðº Ð·Ð° Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº,\",\n\t\tbridge: \"Bridge Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\tmobile: \"ÐÐ¾Ð±Ð¸Ð»Ð½Ð¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\"instant-link\": \"ÐÐ½ÑÑÐ°Ð½Ñ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\"\n\t},\n\texportAccounts: {\n\t\tchooseAWallet: \"ÐÐ·Ð°Ð±ÐµÑÐ¸ÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\ttransferYourAccounts: \"ÐÑÐµÐ½ÐµÑÐ¸ÑÐµ ÑÐ²Ð¾ÑÐµ Ð½Ð°Ð»Ð¾Ð³Ðµ\",\n\t\tselectAWallet: \"ÐÐ·Ð°Ð±ÐµÑÐ¸ÑÐµ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº ÐºÐ¾ÑÐ¸ Ð¾Ð´Ð³Ð¾Ð²Ð°ÑÐ° Ð²Ð°ÑÐ¸Ð¼ Ð¿Ð¾ÑÑÐµÐ±Ð°Ð¼Ð° Ð¸ ÐºÐ¾ÑÐ¸ Ð¿Ð¾Ð´ÑÐ¶Ð°Ð²Ð° Ð²Ð°ÑÐµ Ð¿Ð¾Ð²ÐµÐ·Ð°Ð½Ðµ Ð½Ð°Ð»Ð¾Ð³Ðµ.\",\n\t\tselectYourAccounts: \"ÐÐ·Ð°Ð±ÐµÑÐ¸ÑÐµ Ð²Ð°ÑÐµ Ð½Ð°Ð»Ð¾Ð³Ðµ\",\n\t\tafterDecide: \"ÐÐ°ÐºÐ¾Ð½ ÑÑÐ¾ ÑÐµ Ð¾Ð´Ð»ÑÑÐ¸ÑÐµ Ð·Ð° Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº, Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸Ð·Ð°Ð±ÑÐ°ÑÐ¸ ÐºÐ¾ÑÐµ Ð½Ð°Ð»Ð¾Ð³Ðµ Ð¶ÐµÐ»Ð¸ÑÐµ Ð´Ð° Ð¿ÑÐµÐ½ÐµÑÐµÑÐµ.\",\n\t\tdisclaimer: \"ÐÐµÑÐµÑÐµ Ð¼Ð¾ÑÐ¸ Ð´Ð° Ð¿ÑÐµÐ½ÐµÑÐµÑÐµ Ð½Ð°Ð»Ð¾Ð³Ðµ ÐºÐ¾ÑÐ¸ Ð½Ð¸ÐºÐ°Ð´Ð° Ð½Ð¸ÑÑ Ð±Ð¸Ð»Ð¸ ÑÐ¸Ð½Ð°Ð½ÑÐ¸ÑÐ°Ð½Ð¸ Ð¸Ð»Ð¸ ÐºÐ¾ÑÐ¸ÑÑÐµÐ½Ð¸ Ð½Ð°  NEAR.\",\n\t\twarning: \"ÑÑÐµÐ½ÑÑÐ½Ð¾ Ð½Ðµ Ð¿Ð¾Ð´ÑÐ¶Ð°Ð²Ð° Ð¸Ð·Ð²Ð¾Ð· Ð½Ð°Ð»Ð¾Ð³Ð°. ÐÐ·Ð°Ð±ÐµÑÐ¸ÑÐµ Ð´ÑÑÐ³Ð¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº.\",\n\t\twalletTypes: {\n\t\t\thardware: \"Ð¥Ð°ÑÐ´Ð²ÐµÑÑÐºÐ¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\tbrowser: \"ÐÐ¾Ð²ÑÐ°Ð½Ð¸Ðº Ð¿ÑÐµÑÑÐ°Ð¶Ð¸Ð²Ð°ÑÐ°,\",\n\t\t\tinjected: \"ÐÐ¾Ð´Ð°ÑÐ°Ðº Ð·Ð° Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº,\",\n\t\t\tbridge: \"Bridge Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\",\n\t\t\tmobile: \"ÐÐ¾Ð±Ð¸Ð»Ð½Ð¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº\"\n\t\t},\n\t\tselectAccounts: {\n\t\t\ttitle: \"ÐÐ·Ð°Ð±ÐµÑÐ¸ÑÐµ Ð½Ð°Ð»Ð¾Ð³Ðµ Ð·Ð° Ð¿ÑÐµÐ½Ð¾Ñ.\",\n\t\t\tbutton: \"ÐÐ¾Ð±Ð¸ÑÑÐµ Ð¿ÑÐ¸ÑÑÑÐ¿Ð½Ñ ÑÑÐ°Ð·Ñ\",\n\t\t\tdeselectAll: \"ÐÐ¾Ð½Ð¸ÑÑÐ¸ÑÐµ Ð¸Ð·Ð±Ð¾Ñ\",\n\t\t\tselectAll: \"ÐÐ·Ð°Ð±ÐµÑÐ¸ÑÐµ ÑÐ²Ðµ\",\n\t\t\tunavailable: \"Ð¢ÑÐ°Ð½ÑÑÐµÑ Ð½Ð¸ÑÐµ Ð´Ð¾ÑÑÑÐ¿Ð°Ð½\",\n\t\t\terror: \"ÐÐ°Ð»Ð¾Ð³ Ð½Ðµ Ð¿Ð¾ÑÑÐ¾ÑÐ¸\",\n\t\t\twarningLedger: \"ÐÐ¾ÑÑÐµÐ±Ð½Ð° Ð¿Ð¾Ð´ÑÑÐºÐ° Ð·Ð° Ledger\",\n\t\t\tnoBalance: \"ÐÐ°Ð»Ð¾Ð³ Ð½Ð¸ÑÐµ ÑÐ¸Ð½Ð°Ð½ÑÐ¸ÑÐ°Ð½\"\n\t\t},\n\t\tgetPassphrase: {\n\t\t\ttitle: \"ÐÐ¾Ð¿Ð¸ÑÐ°Ñ Ð¿ÑÐ¸Ð²ÑÐµÐ¼ÐµÐ½Ñ Ð»Ð¾Ð·Ð¸Ð½ÐºÑ\",\n\t\t\tdesc: \"ÐÐ¾ÑÐ°ÑÐµÑÐµ Ð´Ð° ÑÐ½ÐµÑÐµÑÐµ Ð¾Ð²Ñ Ð»Ð¾Ð·Ð¸Ð½ÐºÑ ÐºÐ°Ð´Ð° Ð¿Ð¾ÑÐ½ÐµÑÐµ Ð´Ð° Ð¸Ð·Ð²Ð¾Ð·Ð¸ÑÐµ ÑÐ²Ð¾ÑÐµ Ð½Ð°Ð»Ð¾Ð³Ðµ Ñ Ð´ÑÑÐ³Ð¸ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº.\",\n\t\t\tbutton: \"ÐÐ°ÑÑÐ°Ð²Ð¸ÑÐµ\",\n\t\t\tlabel: \"ÐÐ»Ð¸ÐºÐ½Ð¸ÑÐµ Ð´Ð° Ð±Ð¸ÑÑÐµ ÐºÐ¾Ð¿Ð¸ÑÐ°Ð»Ð¸\",\n\t\t\tcheckLabel: \"ÐÐ¾Ð¿Ð¸ÑÐ°Ð¾ ÑÐ°Ð¼ Ð¸Ð»Ð¸ Ð·Ð°Ð¿Ð¸ÑÐ°Ð¾ Ð»Ð¾Ð·Ð¸Ð½ÐºÑ\"\n\t\t},\n\t\tcomplete: {\n\t\t\ttitle: \"ÐÐ¾Ð²ÑÑÐ¸ÑÐµ ÑÑÐ°Ð½ÑÑÐµÑ\",\n\t\t\tdescOne: \"Ð¡Ð°Ð´Ð° ÑÐµÑÐµ Ð±Ð¸ÑÐ¸ Ð¿ÑÐµÑÑÐ¼ÐµÑÐµÐ½Ð¸ Ð½Ð° Ð½Ð¾Ð²ÑÐ°Ð½Ð¸Ðº ÐºÐ¾ÑÐ¸ ÑÑÐµ Ð¸Ð·Ð°Ð±ÑÐ°Ð»Ð¸ Ð´Ð° Ð·Ð°Ð²ÑÑÐ¸ÑÐµ ÑÑÐ°Ð½ÑÑÐµÑ.\",\n\t\t\tdescTwo: \"ÐÐ°Ð´Ð° ÑÐµ Ð´ÐµÐ¾ Ð¿ÑÐ¾ÑÐµÑÐ° ÑÐ²Ð¾Ð·Ð° Ð·Ð°Ð²ÑÑÐ¸ Ð¸Ð· Ð¸Ð·Ð°Ð±ÑÐ°Ð½Ð¾Ð³ Ð½Ð¾Ð²ÑÐ°Ð½Ð¸ÐºÐ°, Ð¿ÑÐ¸ÑÐ¸ÑÐ½Ð¸ÑÐµ Ð´ÑÐ³Ð¼Ðµ Ð´Ð° Ð·Ð°Ð²ÑÑÐ¸ÑÐµ Ð¿ÑÐ¾ÑÐµÑ Ð¿ÑÐµÐ½Ð¾ÑÐ°.\",\n\t\t\tbutton: \"ÐÐ°Ð²ÑÑÐ¸ÑÐµ\"\n\t\t}\n\t}\n};\nvar sr = {\n\tmodal: modal\n};\n\nconst getLanguage = languageCode => {\n  switch (languageCode) {\n    case \"en\":\n      return en;\n    case \"es\":\n      return es;\n    case \"zh\":\n      return zh;\n    case \"bg\":\n      return bg;\n    case \"ko\":\n      return ko;\n    case \"vi\":\n      return vi;\n    case \"hi\":\n      return hi;\n    case \"ar\":\n      return ar;\n    case \"hr\":\n      return hr;\n    case \"mk\":\n      return mk;\n    case \"sl\":\n      return sl;\n    case \"sr\":\n      return sr;\n    default:\n      return en;\n  }\n};\nlet chosenLang;\nconst allowOnlyLanguage = langCode => {\n  chosenLang = langCode;\n};\n// (i.e en-CA returns just en)\nconst shortenLanguageCode = lang => {\n  return lang.indexOf(\"-\") !== -1 ? lang.split(\"-\")[0] : lang.split(\"_\")[0];\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst findObjectPropByStringPath = (obj, prop) => {\n  if (!obj) {\n    return \"\";\n  }\n  const _index = prop.indexOf(\".\");\n  if (_index > -1) {\n    const currentProp = prop.substring(0, _index);\n    const nextProp = prop.substring(_index + 1);\n    return findObjectPropByStringPath(obj[currentProp], nextProp);\n  }\n  return obj[prop];\n};\nconst translate = path => {\n  let browserLang = window.navigator.languages ? window.navigator.languages[0] : null;\n  browserLang = browserLang || window.navigator.language;\n  const languageCode = shortenLanguageCode(chosenLang || browserLang);\n  const selectedLanguage = getLanguage(languageCode);\n  const text = findObjectPropByStringPath(selectedLanguage, path);\n  return text && typeof text === \"string\" ? text : path;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItd2FsbGV0LXNlbGVjdG9yK2NvcmVAOC45LjdfbmVhci1hcGktanNAMy4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLXdhbGxldC1zZWxlY3Rvci9jb3JlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ1E7QUFDUztBQUNGO0FBQ3BCO0FBQ0M7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQWlCO0FBQ3pDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0EsOEVBQThFLE1BQU07O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEM7O0FBRTFDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjs7QUFFaEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLGtEQUFrRDtBQUN4RixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1FQUFtRTs7QUFFbkU7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUU7QUFDekUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGFBQWE7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLGFBQWEsY0FBYyxVQUFVO0FBQzdFLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsaUNBQWlDO0FBQzFGO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQjtBQUNqRjtBQUNBLE1BQU07QUFDTixJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQkFBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxnQkFBZ0I7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0VBQWdFO0FBQ2hFLElBQUk7QUFDSixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdDQUFnQztBQUNoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELG1CQUFtQjs7QUFFcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxxQkFBcUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0osYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGFBQWE7QUFDakY7QUFDQSx1QkFBdUIsYUFBYSxnQkFBZ0IsYUFBYTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGVBQWU7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTyxJQUFJLGNBQWM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnQkFBZ0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLG1GQUFtRjtBQUN6RjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RCxFQUFFLGdCQUFnQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEYsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw4RUFBOEU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGtGQUFrRjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGNBQWM7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw0RUFBNEU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxxRUFBcUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU0sbUVBQW1FO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0Esa0VBQWtFLDJEQUEyRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw4Q0FBOEM7QUFDOUMsZ0RBQWdEO0FBQ2hELE1BQU0scUJBQXFCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFdBQVcsb0ZBQW9GO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQSxzRUFBc0UsZUFBZTtBQUNyRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsK0JBQStCO0FBQy9CLGlDQUFpQztBQUNqQyxXQUFXO0FBQ1gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLGlCQUFpQjtBQUN0RCxFQUFFLGdCQUFnQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxNQUFNLHdEQUF3RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBaUI7QUFDdkIsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSwwRUFBMEU7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHVFQUF1RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU0sNkJBQTZCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHLEtBQUssTUFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0QsbUJBQW1CLDBDQUEwQztBQUM3RCxDQUFDLHNDQUFzQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMEVBQTBFO0FBQ2hGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxVQUFVO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrRUFBa0UscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCLEtBQUssUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxzQkFBc0IseUJBQXlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNULDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCw2Q0FBNkM7QUFDN0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLCtDQUErQztBQUMvQztBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsNkNBQTZDO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQWU7QUFDcEMsdUJBQXVCLHlDQUFPO0FBQzlCLGdCQUFnQiwwQ0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdDQUF3QztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxvRUFBb0U7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw0REFBNEQ7QUFDbEU7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLG83QkFBbzdCLDRDQUE0Qyx5SkFBeUosNkRBQTZEO0FBQ3RyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxtQkFBbUIseUNBQXlDO0FBQzVHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBFQUEwRSxnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSxjQUFjO0FBQ3JCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLE1BQU0sMkVBQTJFO0FBQ2pGO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxDQUFDOztBQUVELDZCQUE2Qjs7QUFFN0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLGtFQUFrRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLFVBQVU7QUFDViw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSxrRUFBa0U7QUFDeEU7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxRQUFRLG1GQUFtRjs7QUFFM0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxtREFBbUQ7O0FBRXJEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCLG1CQUFtQjtBQUNwRTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDO0FBQ2hDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsOENBQThDO0FBQzlDLHFCQUFxQixnREFBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx1QkFBdUIsZ0RBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZDQUFNO0FBQzlDO0FBQ0E7QUFDQSxhQUFhLDhDQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QixrREFBUztBQUNoQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLG1CQUFtQjs7QUFFL0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZixLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci13YWxsZXQtc2VsZWN0b3IrY29yZUA4LjkuN19uZWFyLWFwaS1qc0AzLjAuNC9ub2RlX21vZHVsZXMvQG5lYXItd2FsbGV0LXNlbGVjdG9yL2NvcmUvaW5kZXguanM/ZDNkZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBuZWFyQVBJIGZyb20gJ25lYXItYXBpLWpzJztcbmltcG9ydCB7IHV0aWxzLCBwcm92aWRlcnMgfSBmcm9tICduZWFyLWFwaS1qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgYXMgRXZlbnRFbWl0dGVyJDEgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJqZWN0LCBzY2FuIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzZXJpYWxpemUgfSBmcm9tICdib3JzaCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdqcy1zaGEyNTYnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jbGFzcyBQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCkge1xuICAgIHRoaXMucHJvdmlkZXIgPSBuZXcgbmVhckFQSS5wcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICAgIHVybFxuICAgIH0pO1xuICB9XG4gIHF1ZXJ5KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnF1ZXJ5KHBhcmFtcyk7XG4gIH1cbiAgdmlld0FjY2Vzc0tleSh7XG4gICAgYWNjb3VudElkLFxuICAgIHB1YmxpY0tleVxuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnkoe1xuICAgICAgcmVxdWVzdF90eXBlOiBcInZpZXdfYWNjZXNzX2tleVwiLFxuICAgICAgZmluYWxpdHk6IFwiZmluYWxcIixcbiAgICAgIGFjY291bnRfaWQ6IGFjY291bnRJZCxcbiAgICAgIHB1YmxpY19rZXk6IHB1YmxpY0tleVxuICAgIH0pO1xuICB9XG4gIGJsb2NrKHJlZmVyZW5jZSkge1xuICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmJsb2NrKHJlZmVyZW5jZSk7XG4gIH1cbiAgc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uKHNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgfVxufVxuXG5jb25zdCBLRVlfREVMSU1JVEVSID0gXCI6XCI7XG5jbGFzcyBKc29uU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIG5hbWVzcGFjZSkge1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgdGhpcy5uYW1lc3BhY2UgPSBBcnJheS5pc0FycmF5KG5hbWVzcGFjZSkgPyBuYW1lc3BhY2Uuam9pbihLRVlfREVMSU1JVEVSKSA6IG5hbWVzcGFjZTtcbiAgfVxuICByZXNvbHZlS2V5KGtleSkge1xuICAgIHJldHVybiBbdGhpcy5uYW1lc3BhY2UsIGtleV0uam9pbihLRVlfREVMSU1JVEVSKTtcbiAgfVxuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSkudGhlbihpdGVtID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2UoaXRlbSkgOiBudWxsO1xuICAgIH0pO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgfVxuICByZW1vdmVJdGVtKGtleSkge1xuICAgIHJldHVybiB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnJlc29sdmVLZXkoa2V5KSk7XG4gIH1cbn1cblxudmFyIGNvbW1vbmpzR2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgJiYgaXQuTWF0aCA9PSBNYXRoICYmIGl0O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwkdCA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0ge307XG5cbnZhciBmYWlscyRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbnZhciBmYWlscyRyID0gZmFpbHMkcztcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbnZhciBkZXNjcmlwdG9ycyA9ICFmYWlscyRyKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxudmFyIGZhaWxzJHEgPSBmYWlscyRzO1xuXG52YXIgZnVuY3Rpb25CaW5kTmF0aXZlID0gIWZhaWxzJHEoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDMgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBjYWxsJGwgPSBGdW5jdGlvbi5wcm90b3R5cGUuY2FsbDtcblxudmFyIGZ1bmN0aW9uQ2FsbCA9IE5BVElWRV9CSU5EJDMgPyBjYWxsJGwuYmluZChjYWxsJGwpIDogZnVuY3Rpb24gKCkge1xuICByZXR1cm4gY2FsbCRsLmFwcGx5KGNhbGwkbCwgYXJndW1lbnRzKTtcbn07XG5cbnZhciBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9O1xuXG52YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1ID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMiA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBiaW5kJDcgPSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQ7XG52YXIgY2FsbCRrID0gRnVuY3Rpb25Qcm90b3R5cGUkMi5jYWxsO1xudmFyIHVuY3VycnlUaGlzJHAgPSBOQVRJVkVfQklORCQyICYmIGJpbmQkNy5iaW5kKGNhbGwkaywgY2FsbCRrKTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQyID8gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmbiAmJiB1bmN1cnJ5VGhpcyRwKGZuKTtcbn0gOiBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZuICYmIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2FsbCRrLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJG8gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgdG9TdHJpbmckNyA9IHVuY3VycnlUaGlzJG8oe30udG9TdHJpbmcpO1xudmFyIHN0cmluZ1NsaWNlJDMgPSB1bmN1cnJ5VGhpcyRvKCcnLnNsaWNlKTtcblxudmFyIGNsYXNzb2ZSYXckMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gc3RyaW5nU2xpY2UkMyh0b1N0cmluZyQ3KGl0KSwgOCwgLTEpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJG4gPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJHAgPSBmYWlscyRzO1xudmFyIGNsYXNzb2YkYiA9IGNsYXNzb2ZSYXckMTtcblxudmFyICRPYmplY3QkNCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJG4oJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyRwKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDQoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJGIoaXQpID09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QkNChpdCk7XG59IDogJE9iamVjdCQ0O1xuXG52YXIgJFR5cGVFcnJvciRmID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgJFR5cGVFcnJvciRmKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCQzID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkNiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNShpdCkpO1xufTtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG52YXIgaXNDYWxsYWJsZSRuID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBpc0NhbGxhYmxlJG0gPSBpc0NhbGxhYmxlJG47XG5cbnZhciBpc09iamVjdCRkID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkbShpdCk7XG59O1xuXG52YXIgZ2xvYmFsJHMgPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJGwgPSBpc0NhbGxhYmxlJG47XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkbChhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDggPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbCRzW25hbWVzcGFjZV0pIDogZ2xvYmFsJHNbbmFtZXNwYWNlXSAmJiBnbG9iYWwkc1tuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBvYmplY3RJc1Byb3RvdHlwZU9mID0gdW5jdXJyeVRoaXMkbSh7fS5pc1Byb3RvdHlwZU9mKTtcblxudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kODtcblxudmFyIGVuZ2luZVVzZXJBZ2VudCA9IGdldEJ1aWx0SW4kNygnbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG52YXIgZ2xvYmFsJHIgPSBnbG9iYWwkdDtcbnZhciB1c2VyQWdlbnQkNSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHByb2Nlc3MkMyA9IGdsb2JhbCRyLnByb2Nlc3M7XG52YXIgRGVubyQxID0gZ2xvYmFsJHIuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MkMyAmJiBwcm9jZXNzJDMudmVyc2lvbnMgfHwgRGVubyQxICYmIERlbm8kMS52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5cbmlmICh2OCkge1xuICBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gIC8vIGluIG9sZCBDaHJvbWUsIHZlcnNpb25zIG9mIFY4IGlzbid0IFY4ID0gQ2hyb21lIC8gMTBcbiAgLy8gYnV0IHRoZWlyIGNvcnJlY3QgdmVyc2lvbnMgYXJlIG5vdCBpbnRlcmVzdGluZyBmb3IgdXNcbiAgdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cblxuLy8gQnJvd3NlckZTIE5vZGVKUyBgcHJvY2Vzc2AgcG9seWZpbGwgaW5jb3JyZWN0bHkgc2V0IGAudjhgIHRvIGAwLjBgXG4vLyBzbyBjaGVjayBgdXNlckFnZW50YCBldmVuIGlmIGAudjhgIGV4aXN0cywgYnV0IDBcbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQkNSkge1xuICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9FZGdlXFwvKFxcZCspLyk7XG4gIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgICBtYXRjaCA9IHVzZXJBZ2VudCQ1Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSArbWF0Y2hbMV07XG4gIH1cbn1cblxudmFyIGVuZ2luZVY4VmVyc2lvbiA9IHZlcnNpb247XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG5cbnZhciBWOF9WRVJTSU9OJDEgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkbyA9IGZhaWxzJHM7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBuYXRpdmVTeW1ib2wgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzJG8oZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIC8vIENocm9tZSAzOCBTeW1ib2wgaGFzIGluY29ycmVjdCB0b1N0cmluZyBjb252ZXJzaW9uXG4gIC8vIGBnZXQtb3duLXByb3BlcnR5LXN5bWJvbHNgIHBvbHlmaWxsIHN5bWJvbHMgY29udmVydGVkIHRvIG9iamVjdCBhcmUgbm90IFN5bWJvbCBpbnN0YW5jZXNcbiAgcmV0dXJuICFTdHJpbmcoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMSAmJiBWOF9WRVJTSU9OJDEgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy14L25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgTkFUSVZFX1NZTUJPTCQxID0gbmF0aXZlU3ltYm9sO1xuXG52YXIgdXNlU3ltYm9sQXNVaWQgPSBOQVRJVkVfU1lNQk9MJDFcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbnZhciBnZXRCdWlsdEluJDYgPSBnZXRCdWlsdEluJDg7XG52YXIgaXNDYWxsYWJsZSRrID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzUHJvdG90eXBlT2YkNCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQkMSA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgJE9iamVjdCQzID0gT2JqZWN0O1xuXG52YXIgaXNTeW1ib2wkMyA9IFVTRV9TWU1CT0xfQVNfVUlEJDEgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyICRTeW1ib2wgPSBnZXRCdWlsdEluJDYoJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSRrKCRTeW1ib2wpICYmIGlzUHJvdG90eXBlT2YkNCgkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdCQzKGl0KSk7XG59O1xuXG52YXIgJFN0cmluZyQzID0gU3RyaW5nO1xuXG52YXIgdHJ5VG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiAkU3RyaW5nJDMoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxudmFyIGlzQ2FsbGFibGUkaiA9IGlzQ2FsbGFibGUkbjtcbnZhciB0cnlUb1N0cmluZyQ0ID0gdHJ5VG9TdHJpbmckNTtcblxudmFyICRUeXBlRXJyb3IkZSA9IFR5cGVFcnJvcjtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbnZhciBhQ2FsbGFibGUkOSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZSRqKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGUodHJ5VG9TdHJpbmckNChhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG52YXIgYUNhbGxhYmxlJDggPSBhQ2FsbGFibGUkOTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxudmFyIGdldE1ldGhvZCQ0ID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDgoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRqID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkaSA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc09iamVjdCRjID0gaXNPYmplY3QkZDtcblxudmFyICRUeXBlRXJyb3IkZCA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRpKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRjKHZhbCA9IGNhbGwkaihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCRjKHZhbCA9IGNhbGwkaihmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkaShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkYyh2YWwgPSBjYWxsJGooZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93ICRUeXBlRXJyb3IkZChcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cbnZhciBzaGFyZWQkNCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBnbG9iYWwkcSA9IGdsb2JhbCR0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxudmFyIGRlZmluZVByb3BlcnR5JDcgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBkZWZpbmVQcm9wZXJ0eSQ3KGdsb2JhbCRxLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbCRxW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgZ2xvYmFsJHAgPSBnbG9iYWwkdDtcbnZhciBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQyID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMztcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkcFtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5JDIoU0hBUkVELCB7fSk7XG5cbnZhciBzaGFyZWRTdG9yZSA9IHN0b3JlJDM7XG5cbnZhciBzdG9yZSQyID0gc2hhcmVkU3RvcmU7XG5cbihzaGFyZWQkNC5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlJDJba2V5XSB8fCAoc3RvcmUkMltrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4yMy4zJyxcbiAgbW9kZTogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjIzLjMvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG52YXIgdG9PYmplY3QkNyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gJE9iamVjdCQyKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNChhcmd1bWVudCkpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGwgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvT2JqZWN0JDYgPSB0b09iamVjdCQ3O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyRsKHt9Lmhhc093blByb3BlcnR5KTtcblxuLy8gYEhhc093blByb3BlcnR5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaGFzb3ducHJvcGVydHlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCQ2KGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRrID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyQ2ID0gdW5jdXJyeVRoaXMkaygxLjAudG9TdHJpbmcpO1xuXG52YXIgdWlkJDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcgKyAoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgdG9TdHJpbmckNigrK2lkICsgcG9zdGZpeCwgMzYpO1xufTtcblxudmFyIGdsb2JhbCRvID0gZ2xvYmFsJHQ7XG52YXIgc2hhcmVkJDMgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGhhc093biRiID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB1aWQkMiA9IHVpZCQzO1xudmFyIE5BVElWRV9TWU1CT0wgPSBuYXRpdmVTeW1ib2w7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCQzKCd3a3MnKTtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCRvLlN5bWJvbDtcbnZhciBzeW1ib2xGb3IgPSBTeW1ib2wkMSAmJiBTeW1ib2wkMVsnZm9yJ107XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkMSA6IFN5bWJvbCQxICYmIFN5bWJvbCQxLndpdGhvdXRTZXR0ZXIgfHwgdWlkJDI7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkaiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGlmICghaGFzT3duJGIoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICB2YXIgZGVzY3JpcHRpb24gPSAnU3ltYm9sLicgKyBuYW1lO1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhc093biRiKFN5bWJvbCQxLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sJDFbbmFtZV07XG4gICAgfSBlbHNlIGlmIChVU0VfU1lNQk9MX0FTX1VJRCAmJiBzeW1ib2xGb3IpIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IHN5bWJvbEZvcihkZXNjcmlwdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG52YXIgY2FsbCRpID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JGIgPSBpc09iamVjdCRkO1xudmFyIGlzU3ltYm9sJDIgPSBpc1N5bWJvbCQzO1xudmFyIGdldE1ldGhvZCQzID0gZ2V0TWV0aG9kJDQ7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IG9yZGluYXJ5VG9QcmltaXRpdmUkMTtcbnZhciB3ZWxsS25vd25TeW1ib2wkaSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgJFR5cGVFcnJvciRjID0gVHlwZUVycm9yO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCRpKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxudmFyIHRvUHJpbWl0aXZlJDIgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdCRiKGlucHV0KSB8fCBpc1N5bWJvbCQyKGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZXhvdGljVG9QcmltID0gZ2V0TWV0aG9kJDMoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGNhbGwkaShleG90aWNUb1ByaW0sIGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0JGIocmVzdWx0KSB8fCBpc1N5bWJvbCQyKHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgdGhyb3cgJFR5cGVFcnJvciRjKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xuICB9XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnbnVtYmVyJztcbiAgcmV0dXJuIG9yZGluYXJ5VG9QcmltaXRpdmUoaW5wdXQsIHByZWYpO1xufTtcblxudmFyIHRvUHJpbWl0aXZlJDEgPSB0b1ByaW1pdGl2ZSQyO1xudmFyIGlzU3ltYm9sJDEgPSBpc1N5bWJvbCQzO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbnZhciB0b1Byb3BlcnR5S2V5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlJDEoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sJDEoa2V5KSA/IGtleSA6IGtleSArICcnO1xufTtcblxudmFyIGdsb2JhbCRuID0gZ2xvYmFsJHQ7XG52YXIgaXNPYmplY3QkYSA9IGlzT2JqZWN0JGQ7XG5cbnZhciBkb2N1bWVudCQzID0gZ2xvYmFsJG4uZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMkMSA9IGlzT2JqZWN0JGEoZG9jdW1lbnQkMykgJiYgaXNPYmplY3QkYShkb2N1bWVudCQzLmNyZWF0ZUVsZW1lbnQpO1xuXG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50JDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIEVYSVNUUyQxID8gZG9jdW1lbnQkMy5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxudmFyIERFU0NSSVBUT1JTJGQgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRuID0gZmFpbHMkcztcbnZhciBjcmVhdGVFbGVtZW50JDEgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMjtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJGQgJiYgIWZhaWxzJG4oZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50JDEoJ2RpdicpLCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH1cbiAgfSkuYSAhPSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG52YXIgY2FsbCRoID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biRhID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3Jcbm9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mID0gREVTQ1JJUFRPUlMkYyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0luZGV4ZWRPYmplY3QkNShPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMyhQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FJDEpIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzT3duJGEoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCghY2FsbCRoKHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZiwgTywgUCksIE9bUF0pO1xufTtcblxudmFyIG9iamVjdERlZmluZVByb3BlcnR5ID0ge307XG5cbnZhciBERVNDUklQVE9SUyRiID0gZGVzY3JpcHRvcnM7XG52YXIgZmFpbHMkbSA9IGZhaWxzJHM7XG5cbi8vIFY4IH4gQ2hyb21lIDM2LVxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzMzNFxudmFyIHY4UHJvdG90eXBlRGVmaW5lQnVnID0gREVTQ1JJUFRPUlMkYiAmJiBmYWlscyRtKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9IDQyO1xufSk7XG5cbnZhciBpc09iamVjdCQ5ID0gaXNPYmplY3QkZDtcblxudmFyICRTdHJpbmckMiA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJGIgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbnZhciBhbk9iamVjdCRlID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdCQ5KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyAkVHlwZUVycm9yJGIoJFN0cmluZyQyKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJGEgPSBkZXNjcmlwdG9ycztcbnZhciBJRThfRE9NX0RFRklORSA9IGllOERvbURlZmluZTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyQxID0gdjhQcm90b3R5cGVEZWZpbmVCdWc7XG52YXIgYW5PYmplY3QkZCA9IGFuT2JqZWN0JGU7XG52YXIgdG9Qcm9wZXJ0eUtleSQyID0gdG9Qcm9wZXJ0eUtleSQ0O1xuXG52YXIgJFR5cGVFcnJvciRhID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBFTlVNRVJBQkxFID0gJ2VudW1lcmFibGUnO1xudmFyIENPTkZJR1VSQUJMRSQxID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5vYmplY3REZWZpbmVQcm9wZXJ0eS5mID0gREVTQ1JJUFRPUlMkYSA/IFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGQoQXR0cmlidXRlcyk7XG4gIGlmICh0eXBlb2YgTyA9PT0gJ2Z1bmN0aW9uJyAmJiBQID09PSAncHJvdG90eXBlJyAmJiAndmFsdWUnIGluIEF0dHJpYnV0ZXMgJiYgV1JJVEFCTEUgaW4gQXR0cmlidXRlcyAmJiAhQXR0cmlidXRlc1tXUklUQUJMRV0pIHtcbiAgICB2YXIgY3VycmVudCA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCk7XG4gICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgICAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgICAgQXR0cmlidXRlcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiBDT05GSUdVUkFCTEUkMSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEUkMV0gOiBjdXJyZW50W0NPTkZJR1VSQUJMRSQxXSxcbiAgICAgICAgZW51bWVyYWJsZTogRU5VTUVSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tFTlVNRVJBQkxFXSA6IGN1cnJlbnRbRU5VTUVSQUJMRV0sXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gIH0gcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0JGQoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDIoUCk7XG4gIGFuT2JqZWN0JGQoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93ICRUeXBlRXJyb3IkYSgnQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDkgPSBkZXNjcmlwdG9ycztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ2ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4ID0gREVTQ1JJUFRPUlMkOSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlJDYuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDMoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgbWFrZUJ1aWx0SW4kMiA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBERVNDUklQVE9SUyQ4ID0gZGVzY3JpcHRvcnM7XG52YXIgaGFzT3duJDkgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyQ4ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbnZhciBFWElTVFMgPSBoYXNPd24kOShGdW5jdGlvblByb3RvdHlwZSQxLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyQ4IHx8IChERVNDUklQVE9SUyQ4ICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxudmFyIGZ1bmN0aW9uTmFtZSA9IHtcbiAgRVhJU1RTOiBFWElTVFMsXG4gIFBST1BFUjogUFJPUEVSLFxuICBDT05GSUdVUkFCTEU6IENPTkZJR1VSQUJMRVxufTtcblxudmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkaCA9IGlzQ2FsbGFibGUkbjtcbnZhciBzdG9yZSQxID0gc2hhcmVkU3RvcmU7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gdW5jdXJyeVRoaXMkaihGdW5jdGlvbi50b1N0cmluZyk7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZSRoKHN0b3JlJDEuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUkMS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQ0ID0gc3RvcmUkMS5pbnNwZWN0U291cmNlO1xuXG52YXIgZ2xvYmFsJG0gPSBnbG9iYWwkdDtcbnZhciBpc0NhbGxhYmxlJGcgPSBpc0NhbGxhYmxlJG47XG52YXIgaW5zcGVjdFNvdXJjZSQzID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgV2Vha01hcCQxID0gZ2xvYmFsJG0uV2Vha01hcDtcblxudmFyIG5hdGl2ZVdlYWtNYXAgPSBpc0NhbGxhYmxlJGcoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZSQzKFdlYWtNYXAkMSkpO1xuXG52YXIgc2hhcmVkJDIgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIHVpZCQxID0gdWlkJDM7XG5cbnZhciBrZXlzJDEgPSBzaGFyZWQkMigna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzJDFba2V5XSB8fCAoa2V5cyQxW2tleV0gPSB1aWQkMShrZXkpKTtcbn07XG5cbnZhciBoaWRkZW5LZXlzJDQgPSB7fTtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IG5hdGl2ZVdlYWtNYXA7XG52YXIgZ2xvYmFsJGwgPSBnbG9iYWwkdDtcbnZhciB1bmN1cnJ5VGhpcyRpID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBpc09iamVjdCQ4ID0gaXNPYmplY3QkZDtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNyA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZFN0b3JlO1xudmFyIHNoYXJlZEtleSQyID0gc2hhcmVkS2V5JDM7XG52YXIgaGlkZGVuS2V5cyQzID0gaGlkZGVuS2V5cyQ0O1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFR5cGVFcnJvciQzID0gZ2xvYmFsJGwuVHlwZUVycm9yO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwkbC5XZWFrTWFwO1xudmFyIHNldCQyLCBnZXQkMSwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldCQxKGl0KSA6IHNldCQyKGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0JDgoaXQpIHx8IChzdGF0ZSA9IGdldCQxKGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yJDMoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZCQxLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZCQxLnN0YXRlIHx8IChzaGFyZWQkMS5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSB1bmN1cnJ5VGhpcyRpKHN0b3JlLmdldCk7XG4gIHZhciB3bWhhcyA9IHVuY3VycnlUaGlzJGkoc3RvcmUuaGFzKTtcbiAgdmFyIHdtc2V0ID0gdW5jdXJyeVRoaXMkaShzdG9yZS5zZXQpO1xuICBzZXQkMiA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQzKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0KHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcyhzdG9yZSwgaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5JDIoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkM1tTVEFURV0gPSB0cnVlO1xuICBzZXQkMiA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJDgoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciQzKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNyhpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQxID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ4KGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biQ4KGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCQyLFxuICBnZXQ6IGdldCQxLFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBmYWlscyRsID0gZmFpbHMkcztcbnZhciBpc0NhbGxhYmxlJGYgPSBpc0NhbGxhYmxlJG47XG52YXIgaGFzT3duJDcgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIERFU0NSSVBUT1JTJDcgPSBkZXNjcmlwdG9ycztcbnZhciBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSQyID0gZnVuY3Rpb25OYW1lLkNPTkZJR1VSQUJMRTtcbnZhciBpbnNwZWN0U291cmNlJDIgPSBpbnNwZWN0U291cmNlJDQ7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1ID0gaW50ZXJuYWxTdGF0ZTtcblxudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlJDUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDUuZ2V0O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG52YXIgQ09ORklHVVJBQkxFX0xFTkdUSCA9IERFU0NSSVBUT1JTJDcgJiYgIWZhaWxzJGwoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHkkNihmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0sICdsZW5ndGgnLCB7IHZhbHVlOiA4IH0pLmxlbmd0aCAhPT0gODtcbn0pO1xuXG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbnZhciBtYWtlQnVpbHRJbiQxID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBuYW1lLCBvcHRpb25zKSB7XG4gIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgIG5hbWUgPSAnWycgKyBTdHJpbmcobmFtZSkucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLCAnJDEnKSArICddJztcbiAgfVxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcikgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2V0dGVyKSBuYW1lID0gJ3NldCAnICsgbmFtZTtcbiAgaWYgKCFoYXNPd24kNyh2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUkMiAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgIGlmIChERVNDUklQVE9SUyQ3KSBkZWZpbmVQcm9wZXJ0eSQ2KHZhbHVlLCAnbmFtZScsIHsgdmFsdWU6IG5hbWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICBlbHNlIHZhbHVlLm5hbWUgPSBuYW1lO1xuICB9XG4gIGlmIChDT05GSUdVUkFCTEVfTEVOR1RIICYmIG9wdGlvbnMgJiYgaGFzT3duJDcob3B0aW9ucywgJ2FyaXR5JykgJiYgdmFsdWUubGVuZ3RoICE9PSBvcHRpb25zLmFyaXR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNih2YWx1ZSwgJ2xlbmd0aCcsIHsgdmFsdWU6IG9wdGlvbnMuYXJpdHkgfSk7XG4gIH1cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiBoYXNPd24kNyhvcHRpb25zLCAnY29uc3RydWN0b3InKSAmJiBvcHRpb25zLmNvbnN0cnVjdG9yKSB7XG4gICAgICBpZiAoREVTQ1JJUFRPUlMkNykgZGVmaW5lUHJvcGVydHkkNih2YWx1ZSwgJ3Byb3RvdHlwZScsIHsgd3JpdGFibGU6IGZhbHNlIH0pO1xuICAgIC8vIGluIFY4IH4gQ2hyb21lIDUzLCBwcm90b3R5cGVzIG9mIHNvbWUgbWV0aG9kcywgbGlrZSBgQXJyYXkucHJvdG90eXBlLnZhbHVlc2AsIGFyZSBub24td3JpdGFibGVcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnByb3RvdHlwZSkgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlJDIodmFsdWUpO1xuICBpZiAoIWhhc093biQ3KHN0YXRlLCAnc291cmNlJykpIHtcbiAgICBzdGF0ZS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRlbmQtbmF0aXZlIC0tIHJlcXVpcmVkXG5GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBtYWtlQnVpbHRJbiQxKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSRmKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUkNSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSQyKHRoaXMpO1xufSwgJ3RvU3RyaW5nJyk7XG5cbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJG47XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkNSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIG1ha2VCdWlsdEluID0gbWFrZUJ1aWx0SW4kMi5leHBvcnRzO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xuXG52YXIgZGVmaW5lQnVpbHRJbiQ4ID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zLmVudW1lcmFibGU7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIGlmIChpc0NhbGxhYmxlJGUodmFsdWUpKSBtYWtlQnVpbHRJbih2YWx1ZSwgbmFtZSwgb3B0aW9ucyk7XG4gIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICAgIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICAgIGVsc2UgZGVmaW5lR2xvYmFsUHJvcGVydHkkMShrZXksIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFvcHRpb25zLnVuc2FmZSkgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGVsc2UgaWYgKE9ba2V5XSkgc2ltcGxlID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ1LmYoTywga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgICAgd3JpdGFibGU6ICFvcHRpb25zLm5vbldyaXRhYmxlXG4gICAgfSk7XG4gIH0gcmV0dXJuIE87XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcyA9IHt9O1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciQzID0gTWF0aC5mbG9vcjtcblxuLy8gYE1hdGgudHJ1bmNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1tYXRoLXRydW5jIC0tIHNhZmVcbnZhciBtYXRoVHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiAgdmFyIG4gPSAreDtcbiAgcmV0dXJuIChuID4gMCA/IGZsb29yJDMgOiBjZWlsKShuKTtcbn07XG5cbnZhciB0cnVuYyA9IG1hdGhUcnVuYztcblxuLy8gYFRvSW50ZWdlck9ySW5maW5pdHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJvcmluZmluaXR5XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQ2ID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBudW1iZXIgPSArYXJndW1lbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5JDUgPSB0b0ludGVnZXJPckluZmluaXR5JDY7XG5cbnZhciBtYXgkMSA9IE1hdGgubWF4O1xudmFyIG1pbiQyID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4oaW50ZWdlciwgbGVuZ3RoKS5cbnZhciB0b0Fic29sdXRlSW5kZXgkNCA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ1KGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4JDEoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4kMihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkNCA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcblxudmFyIG1pbiQxID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG52YXIgdG9MZW5ndGgkNiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluJDEodG9JbnRlZ2VyT3JJbmZpbml0eSQ0KGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG52YXIgdG9MZW5ndGgkNSA9IHRvTGVuZ3RoJDY7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoJDUob2JqLmxlbmd0aCk7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDQgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciB0b0Fic29sdXRlSW5kZXgkMyA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDcgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgaW5kZXhPZiwgaW5jbHVkZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQ0ID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQ0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNyhPKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMyhmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDQodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDQoZmFsc2UpXG59O1xuXG52YXIgdW5jdXJyeVRoaXMkaCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGFzT3duJDYgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHRvSW5kZXhlZE9iamVjdCQzID0gdG9JbmRleGVkT2JqZWN0JDY7XG52YXIgaW5kZXhPZiQxID0gYXJyYXlJbmNsdWRlcy5pbmRleE9mO1xudmFyIGhpZGRlbktleXMkMiA9IGhpZGRlbktleXMkNDtcblxudmFyIHB1c2gkMiA9IHVuY3VycnlUaGlzJGgoW10ucHVzaCk7XG5cbnZhciBvYmplY3RLZXlzSW50ZXJuYWwgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQzKG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzT3duJDYoaGlkZGVuS2V5cyQyLCBrZXkpICYmIGhhc093biQ2KE8sIGtleSkgJiYgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhc093biQ2KE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmluZGV4T2YkMShyZXN1bHQsIGtleSkgfHwgcHVzaCQyKHJlc3VsdCwga2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG52YXIgZW51bUJ1Z0tleXMkMyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMkMSA9IG9iamVjdEtleXNJbnRlcm5hbDtcbnZhciBlbnVtQnVnS2V5cyQyID0gZW51bUJ1Z0tleXMkMztcblxudmFyIGhpZGRlbktleXMkMSA9IGVudW1CdWdLZXlzJDIuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGhpZGRlbktleXMkMSk7XG59O1xuXG52YXIgb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiQ4O1xudmFyIHVuY3VycnlUaGlzJGcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGFuT2JqZWN0JGMgPSBhbk9iamVjdCRlO1xuXG52YXIgY29uY2F0JDEgPSB1bmN1cnJ5VGhpcyRnKFtdLmNvbmNhdCk7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbnZhciBvd25LZXlzJDEgPSBnZXRCdWlsdEluJDUoJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QkYyhpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZjtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQxKGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBoYXNPd24kNSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgb3duS2V5cyA9IG93bktleXMkMTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UsIGV4Y2VwdGlvbnMpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlJDQuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxLmY7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgIGlmICghaGFzT3duJDUodGFyZ2V0LCBrZXkpICYmICEoZXhjZXB0aW9ucyAmJiBoYXNPd24kNShleGNlcHRpb25zLCBrZXkpKSkge1xuICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIGZhaWxzJGsgPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkbjtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkJDIgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkZChkZXRlY3Rpb24pID8gZmFpbHMkayhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMi5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMi5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQyLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDI7XG5cbnZhciBnbG9iYWwkayA9IGdsb2JhbCR0O1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDYgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBkZWZpbmVCdWlsdEluJDcgPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBkZWZpbmVHbG9iYWxQcm9wZXJ0eSQzO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzJDE7XG52YXIgaXNGb3JjZWQkMSA9IGlzRm9yY2VkXzE7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gIGlmIChHTE9CQUwpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwkaztcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWwka1tUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldCA9IChnbG9iYWwka1tUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkJDEoR0xPQkFMID8ga2V5IDogVEFSR0VUICsgKFNUQVRJQyA/ICcuJyA6ICcjJykgKyBrZXksIG9wdGlvbnMuZm9yY2VkKTtcbiAgICAvLyBjb250YWluZWQgaW4gdGFyZ2V0XG4gICAgaWYgKCFGT1JDRUQgJiYgdGFyZ2V0UHJvcGVydHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICBkZWZpbmVCdWlsdEluJDcodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGNsYXNzb2YkYSA9IGNsYXNzb2ZSYXckMTtcbnZhciBnbG9iYWwkaiA9IGdsb2JhbCR0O1xuXG52YXIgZW5naW5lSXNOb2RlID0gY2xhc3NvZiRhKGdsb2JhbCRqLnByb2Nlc3MpID09ICdwcm9jZXNzJztcblxudmFyIGlzQ2FsbGFibGUkYyA9IGlzQ2FsbGFibGUkbjtcblxudmFyICRTdHJpbmckMSA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yJDkgPSBUeXBlRXJyb3I7XG5cbnZhciBhUG9zc2libGVQcm90b3R5cGUkMSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUkYyhhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgJFR5cGVFcnJvciQ5KFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cblxudmFyIHVuY3VycnlUaGlzJGYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGFuT2JqZWN0JGIgPSBhbk9iamVjdCRlO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1zZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbiAgICBzZXR0ZXIgPSB1bmN1cnJ5VGhpcyRmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCk7XG4gICAgc2V0dGVyKHRlc3QsIFtdKTtcbiAgICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICBhbk9iamVjdCRiKE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIoTywgcHJvdG8pO1xuICAgIGVsc2UgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICByZXR1cm4gTztcbiAgfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBoYXNPd24kNCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgd2VsbEtub3duU3ltYm9sJGggPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckNCA9IHdlbGxLbm93blN5bWJvbCRoKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckNCA9IGZ1bmN0aW9uICh0YXJnZXQsIFRBRywgU1RBVElDKSB7XG4gIGlmICh0YXJnZXQgJiYgIVNUQVRJQykgdGFyZ2V0ID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgaWYgKHRhcmdldCAmJiAhaGFzT3duJDQodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDQpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkkNSh0YXJnZXQsIFRPX1NUUklOR19UQUckNCwgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiBUQUcgfSk7XG4gIH1cbn07XG5cbnZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJDg7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUkMyA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIHdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgREVTQ1JJUFRPUlMkNiA9IGRlc2NyaXB0b3JzO1xuXG52YXIgU1BFQ0lFUyQ0ID0gd2VsbEtub3duU3ltYm9sJGcoJ3NwZWNpZXMnKTtcblxudmFyIHNldFNwZWNpZXMkMiA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gIHZhciBDb25zdHJ1Y3RvciA9IGdldEJ1aWx0SW4kNChDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mO1xuXG4gIGlmIChERVNDUklQVE9SUyQ2ICYmIENvbnN0cnVjdG9yICYmICFDb25zdHJ1Y3RvcltTUEVDSUVTJDRdKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMkNCwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc1Byb3RvdHlwZU9mJDMgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuXG52YXIgJFR5cGVFcnJvciQ4ID0gVHlwZUVycm9yO1xuXG52YXIgYW5JbnN0YW5jZSQzID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YkMyhQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyAkVHlwZUVycm9yJDgoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJGYgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckMyA9IHdlbGxLbm93blN5bWJvbCRmKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHJDNdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSB0b1N0cmluZ1RhZ1N1cHBvcnQ7XG52YXIgaXNDYWxsYWJsZSRiID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2ZSYXcgPSBjbGFzc29mUmF3JDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIFRPX1NUUklOR19UQUckMiA9IHdlbGxLbm93blN5bWJvbCRlKCd0b1N0cmluZ1RhZycpO1xudmFyICRPYmplY3QkMSA9IE9iamVjdDtcblxuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BcbnZhciBjbGFzc29mJDkgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPyBjbGFzc29mUmF3IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gJE9iamVjdCQxKGl0KSwgVE9fU1RSSU5HX1RBRyQyKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlJGIoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkZSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZmFpbHMkaiA9IGZhaWxzJHM7XG52YXIgaXNDYWxsYWJsZSRhID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YkOCA9IGNsYXNzb2YkOTtcbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJDg7XG52YXIgaW5zcGVjdFNvdXJjZSQxID0gaW5zcGVjdFNvdXJjZSQ0O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBlbXB0eSA9IFtdO1xudmFyIGNvbnN0cnVjdCA9IGdldEJ1aWx0SW4kMygnUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyQyID0gdW5jdXJyeVRoaXMkZShjb25zdHJ1Y3RvclJlZ0V4cC5leGVjKTtcbnZhciBJTkNPUlJFQ1RfVE9fU1RSSU5HID0gIWNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMobm9vcCk7XG5cbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkYShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdHJ1Y3Qobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkYShhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mJDgoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjJDIoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UkMShhcmd1bWVudCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5pc0NvbnN0cnVjdG9yTGVnYWN5LnNoYW0gPSB0cnVlO1xuXG4vLyBgSXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY29uc3RydWN0b3JcbnZhciBpc0NvbnN0cnVjdG9yJDIgPSAhY29uc3RydWN0IHx8IGZhaWxzJGooZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG52YXIgaXNDb25zdHJ1Y3RvciQxID0gaXNDb25zdHJ1Y3RvciQyO1xudmFyIHRyeVRvU3RyaW5nJDMgPSB0cnlUb1N0cmluZyQ1O1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQyID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yJDEoYXJndW1lbnQpKSByZXR1cm4gYXJndW1lbnQ7XG4gIHRocm93ICRUeXBlRXJyb3IkNyh0cnlUb1N0cmluZyQzKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBhbk9iamVjdCRhID0gYW5PYmplY3QkZTtcbnZhciBhQ29uc3RydWN0b3IkMSA9IGFDb25zdHJ1Y3RvciQyO1xudmFyIHdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBTUEVDSUVTJDMgPSB3ZWxsS25vd25TeW1ib2wkZCgnc3BlY2llcycpO1xuXG4vLyBgU3BlY2llc0NvbnN0cnVjdG9yYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3BlY2llc2NvbnN0cnVjdG9yXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yJDMgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gIHZhciBDID0gYW5PYmplY3QkYShPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdCRhKEMpW1NQRUNJRVMkM10pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFDb25zdHJ1Y3RvciQxKFMpO1xufTtcblxudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSQzID0gRnVuY3Rpb25Qcm90b3R5cGUuYXBwbHk7XG52YXIgY2FsbCRnID0gRnVuY3Rpb25Qcm90b3R5cGUuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tcmVmbGVjdCAtLSBzYWZlXG52YXIgZnVuY3Rpb25BcHBseSA9IHR5cGVvZiBSZWZsZWN0ID09ICdvYmplY3QnICYmIFJlZmxlY3QuYXBwbHkgfHwgKE5BVElWRV9CSU5EJDEgPyBjYWxsJGcuYmluZChhcHBseSQzKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZy5hcHBseShhcHBseSQzLCBhcmd1bWVudHMpO1xufSk7XG5cbnZhciB1bmN1cnJ5VGhpcyRkID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkNyA9IGFDYWxsYWJsZSQ5O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgYmluZCQ2ID0gdW5jdXJyeVRoaXMkZCh1bmN1cnJ5VGhpcyRkLmJpbmQpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBmdW5jdGlvbkJpbmRDb250ZXh0ID0gZnVuY3Rpb24gKGZuLCB0aGF0KSB7XG4gIGFDYWxsYWJsZSQ3KGZuKTtcbiAgcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kJDYoZm4sIHRoYXQpIDogZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG5cbnZhciBnZXRCdWlsdEluJDIgPSBnZXRCdWlsdEluJDg7XG5cbnZhciBodG1sJDIgPSBnZXRCdWlsdEluJDIoJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBhcnJheVNsaWNlJDUgPSB1bmN1cnJ5VGhpcyRjKFtdLnNsaWNlKTtcblxudmFyICRUeXBlRXJyb3IkNiA9IFR5cGVFcnJvcjtcblxudmFyIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoJDEgPSBmdW5jdGlvbiAocGFzc2VkLCByZXF1aXJlZCkge1xuICBpZiAocGFzc2VkIDwgcmVxdWlyZWQpIHRocm93ICRUeXBlRXJyb3IkNignTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG5cbnZhciB1c2VyQWdlbnQkNCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSW9zID0gLyg/OmlwYWR8aXBob25lfGlwb2QpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50JDQpO1xuXG52YXIgZ2xvYmFsJGkgPSBnbG9iYWwkdDtcbnZhciBhcHBseSQyID0gZnVuY3Rpb25BcHBseTtcbnZhciBiaW5kJDUgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkbjtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgZmFpbHMkaSA9IGZhaWxzJHM7XG52YXIgaHRtbCQxID0gaHRtbCQyO1xudmFyIGFycmF5U2xpY2UkNCA9IGFycmF5U2xpY2UkNTtcbnZhciBjcmVhdGVFbGVtZW50ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxO1xudmFyIElTX0lPUyQxID0gZW5naW5lSXNJb3M7XG52YXIgSVNfTk9ERSQzID0gZW5naW5lSXNOb2RlO1xuXG52YXIgc2V0JDEgPSBnbG9iYWwkaS5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXIgPSBnbG9iYWwkaS5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzJDIgPSBnbG9iYWwkaS5wcm9jZXNzO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsJGkuRGlzcGF0Y2g7XG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCRpLkZ1bmN0aW9uO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsJGkuTWVzc2FnZUNoYW5uZWw7XG52YXIgU3RyaW5nJDEgPSBnbG9iYWwkaS5TdHJpbmc7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUkMSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGxvY2F0aW9uLCBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudHJ5IHtcbiAgLy8gRGVubyB0aHJvd3MgYSBSZWZlcmVuY2VFcnJvciBvbiBgbG9jYXRpb25gIGFjY2VzcyB3aXRob3V0IGAtLWxvY2F0aW9uYCBmbGFnXG4gIGxvY2F0aW9uID0gZ2xvYmFsJGkubG9jYXRpb247XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbnZhciBydW4gPSBmdW5jdGlvbiAoaWQpIHtcbiAgaWYgKGhhc093biQzKHF1ZXVlJDEsIGlkKSkge1xuICAgIHZhciBmbiA9IHF1ZXVlJDFbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsJGkucG9zdE1lc3NhZ2UoU3RyaW5nJDEoaWQpLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5cbi8vIE5vZGUuanMgMC45KyAmIElFMTArIGhhcyBzZXRJbW1lZGlhdGUsIG90aGVyd2lzZTpcbmlmICghc2V0JDEgfHwgIWNsZWFyKSB7XG4gIHNldCQxID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGhhbmRsZXIpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZm4gPSBpc0NhbGxhYmxlJDkoaGFuZGxlcikgPyBoYW5kbGVyIDogRnVuY3Rpb24kMShoYW5kbGVyKTtcbiAgICB2YXIgYXJncyA9IGFycmF5U2xpY2UkNChhcmd1bWVudHMsIDEpO1xuICAgIHF1ZXVlJDFbKytjb3VudGVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwcGx5JDIoZm4sIHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfTtcbiAgICBkZWZlcihjb3VudGVyKTtcbiAgICByZXR1cm4gY291bnRlcjtcbiAgfTtcbiAgY2xlYXIgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZSQxW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChJU19OT0RFJDMpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgcHJvY2VzcyQyLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICAvLyBleGNlcHQgaU9TIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzYyNFxuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsICYmICFJU19JT1MkMSkge1xuICAgIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICAgIGRlZmVyID0gYmluZCQ1KHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChcbiAgICBnbG9iYWwkaS5hZGRFdmVudExpc3RlbmVyICYmXG4gICAgaXNDYWxsYWJsZSQ5KGdsb2JhbCRpLnBvc3RNZXNzYWdlKSAmJlxuICAgICFnbG9iYWwkaS5pbXBvcnRTY3JpcHRzICYmXG4gICAgbG9jYXRpb24gJiYgbG9jYXRpb24ucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICAhZmFpbHMkaShwb3N0KVxuICApIHtcbiAgICBkZWZlciA9IHBvc3Q7XG4gICAgZ2xvYmFsJGkuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIC8vIElFOC1cbiAgfSBlbHNlIGlmIChPTlJFQURZU1RBVEVDSEFOR0UgaW4gY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgaHRtbCQxLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sJDEucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHJ1bihpZCk7XG4gICAgICB9O1xuICAgIH07XG4gIC8vIFJlc3Qgb2xkIGJyb3dzZXJzXG4gIH0gZWxzZSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgdGFzayQxID0ge1xuICBzZXQ6IHNldCQxLFxuICBjbGVhcjogY2xlYXJcbn07XG5cbnZhciB1c2VyQWdlbnQkMyA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBnbG9iYWwkaCA9IGdsb2JhbCR0O1xuXG52YXIgZW5naW5lSXNJb3NQZWJibGUgPSAvaXBhZHxpcGhvbmV8aXBvZC9pLnRlc3QodXNlckFnZW50JDMpICYmIGdsb2JhbCRoLlBlYmJsZSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBlbmdpbmVJc1dlYm9zV2Via2l0ID0gL3dlYjBzKD8hLipjaHJvbWUpL2kudGVzdCh1c2VyQWdlbnQkMik7XG5cbnZhciBnbG9iYWwkZyA9IGdsb2JhbCR0O1xudmFyIGJpbmQkNCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLmY7XG52YXIgbWFjcm90YXNrID0gdGFzayQxLnNldDtcbnZhciBJU19JT1MgPSBlbmdpbmVJc0lvcztcbnZhciBJU19JT1NfUEVCQkxFID0gZW5naW5lSXNJb3NQZWJibGU7XG52YXIgSVNfV0VCT1NfV0VCS0lUID0gZW5naW5lSXNXZWJvc1dlYmtpdDtcbnZhciBJU19OT0RFJDIgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsJGcuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwkZy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIGRvY3VtZW50JDIgPSBnbG9iYWwkZy5kb2N1bWVudDtcbnZhciBwcm9jZXNzJDEgPSBnbG9iYWwkZy5wcm9jZXNzO1xudmFyIFByb21pc2UkMSA9IGdsb2JhbCRnLlByb21pc2U7XG4vLyBOb2RlLmpzIDExIHNob3dzIEV4cGVyaW1lbnRhbFdhcm5pbmcgb24gZ2V0dGluZyBgcXVldWVNaWNyb3Rhc2tgXG52YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbCRnLCAncXVldWVNaWNyb3Rhc2snKTtcbnZhciBxdWV1ZU1pY3JvdGFzayA9IHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciAmJiBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IudmFsdWU7XG5cbnZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5JDEsIHRvZ2dsZSwgbm9kZSwgcHJvbWlzZSwgdGhlbjtcblxuLy8gbW9kZXJuIGVuZ2luZXMgaGF2ZSBxdWV1ZU1pY3JvdGFzayBtZXRob2RcbmlmICghcXVldWVNaWNyb3Rhc2spIHtcbiAgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudCwgZm47XG4gICAgaWYgKElTX05PREUkMiAmJiAocGFyZW50ID0gcHJvY2VzcyQxLmRvbWFpbikpIHBhcmVudC5leGl0KCk7XG4gICAgd2hpbGUgKGhlYWQpIHtcbiAgICAgIGZuID0gaGVhZC5mbjtcbiAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICB0cnkge1xuICAgICAgICBmbigpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGhlYWQpIG5vdGlmeSQxKCk7XG4gICAgICAgIGVsc2UgbGFzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwYXJlbnQpIHBhcmVudC5lbnRlcigpO1xuICB9O1xuXG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgLy8gYWxzbyBleGNlcHQgV2ViT1MgV2Via2l0IGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84OThcbiAgaWYgKCFJU19JT1MgJiYgIUlTX05PREUkMiAmJiAhSVNfV0VCT1NfV0VCS0lUICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgZG9jdW1lbnQkMikge1xuICAgIHRvZ2dsZSA9IHRydWU7XG4gICAgbm9kZSA9IGRvY3VtZW50JDIuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgIG5ldyBNdXRhdGlvbk9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZSA9ICF0b2dnbGU7XG4gICAgfTtcbiAgLy8gZW52aXJvbm1lbnRzIHdpdGggbWF5YmUgbm9uLWNvbXBsZXRlbHkgY29ycmVjdCwgYnV0IGV4aXN0ZW50IFByb21pc2VcbiAgfSBlbHNlIGlmICghSVNfSU9TX1BFQkJMRSAmJiBQcm9taXNlJDEgJiYgUHJvbWlzZSQxLnJlc29sdmUpIHtcbiAgICAvLyBQcm9taXNlLnJlc29sdmUgd2l0aG91dCBhbiBhcmd1bWVudCB0aHJvd3MgYW4gZXJyb3IgaW4gTEcgV2ViT1MgMlxuICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgIC8vIHdvcmthcm91bmQgb2YgV2ViS2l0IH4gaU9TIFNhZmFyaSAxMC4xIGJ1Z1xuICAgIHByb21pc2UuY29uc3RydWN0b3IgPSBQcm9taXNlJDE7XG4gICAgdGhlbiA9IGJpbmQkNChwcm9taXNlLnRoZW4sIHByb21pc2UpO1xuICAgIG5vdGlmeSQxID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gTm9kZS5qcyB3aXRob3V0IHByb21pc2VzXG4gIH0gZWxzZSBpZiAoSVNfTk9ERSQyKSB7XG4gICAgbm90aWZ5JDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzJDEubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGZvciBvdGhlciBlbnZpcm9ubWVudHMgLSBtYWNyb3Rhc2sgYmFzZWQgb246XG4gIC8vIC0gc2V0SW1tZWRpYXRlXG4gIC8vIC0gTWVzc2FnZUNoYW5uZWxcbiAgLy8gLSB3aW5kb3cucG9zdE1lc3NhZ2VcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmJpbmQoZ2xvYmFsKVxuICAgIG1hY3JvdGFzayA9IGJpbmQkNChtYWNyb3Rhc2ssIGdsb2JhbCRnKTtcbiAgICBub3RpZnkkMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIG1hY3JvdGFzayhmbHVzaCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbWljcm90YXNrJDEgPSBxdWV1ZU1pY3JvdGFzayB8fCBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gIGlmIChsYXN0KSBsYXN0Lm5leHQgPSB0YXNrO1xuICBpZiAoIWhlYWQpIHtcbiAgICBoZWFkID0gdGFzaztcbiAgICBub3RpZnkkMSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcblxudmFyIGdsb2JhbCRmID0gZ2xvYmFsJHQ7XG5cbnZhciBob3N0UmVwb3J0RXJyb3JzJDEgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgY29uc29sZSA9IGdsb2JhbCRmLmNvbnNvbGU7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICBhcmd1bWVudHMubGVuZ3RoID09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiAgfVxufTtcblxudmFyIHBlcmZvcm0kMyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IGZhbHNlLCB2YWx1ZTogZXhlYygpIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHsgZXJyb3I6IHRydWUsIHZhbHVlOiBlcnJvciB9O1xuICB9XG59O1xuXG52YXIgUXVldWUkMSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbn07XG5cblF1ZXVlJDEucHJvdG90eXBlID0ge1xuICBhZGQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGVudHJ5ID0geyBpdGVtOiBpdGVtLCBuZXh0OiBudWxsIH07XG4gICAgaWYgKHRoaXMuaGVhZCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmhlYWQ7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXh0O1xuICAgICAgaWYgKHRoaXMudGFpbCA9PT0gZW50cnkpIHRoaXMudGFpbCA9IG51bGw7XG4gICAgICByZXR1cm4gZW50cnkuaXRlbTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBxdWV1ZSA9IFF1ZXVlJDE7XG5cbnZhciBnbG9iYWwkZSA9IGdsb2JhbCR0O1xuXG52YXIgcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsJGUuUHJvbWlzZTtcblxudmFyIGVuZ2luZUlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgdHlwZW9mIERlbm8gIT0gJ29iamVjdCc7XG5cbnZhciBnbG9iYWwkZCA9IGdsb2JhbCR0O1xudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkbjtcbnZhciBpc0ZvcmNlZCA9IGlzRm9yY2VkXzE7XG52YXIgaW5zcGVjdFNvdXJjZSA9IGluc3BlY3RTb3VyY2UkNDtcbnZhciB3ZWxsS25vd25TeW1ib2wkYyA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIElTX0JST1dTRVIgPSBlbmdpbmVJc0Jyb3dzZXI7XG52YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcblxuTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMgJiYgTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDMucHJvdG90eXBlO1xudmFyIFNQRUNJRVMkMiA9IHdlbGxLbm93blN5bWJvbCRjKCdzcGVjaWVzJyk7XG52YXIgU1VCQ0xBU1NJTkcgPSBmYWxzZTtcbnZhciBOQVRJVkVfUFJPTUlTRV9SRUpFQ1RJT05fRVZFTlQkMSA9IGlzQ2FsbGFibGUkOChnbG9iYWwkZC5Qcm9taXNlUmVqZWN0aW9uRXZlbnQpO1xuXG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkNSA9IGlzRm9yY2VkKCdQcm9taXNlJywgZnVuY3Rpb24gKCkge1xuICB2YXIgUFJPTUlTRV9DT05TVFJVQ1RPUl9TT1VSQ0UgPSBpbnNwZWN0U291cmNlKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBQUk9NSVNFX0NPTlNUUlVDVE9SX1NPVVJDRSAhPT0gU3RyaW5nKE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQzKTtcbiAgLy8gVjggNi42IChOb2RlIDEwIGFuZCBDaHJvbWUgNjYpIGhhdmUgYSBidWcgd2l0aCByZXNvbHZpbmcgY3VzdG9tIHRoZW5hYmxlc1xuICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgLy8gV2UgY2FuJ3QgZGV0ZWN0IGl0IHN5bmNocm9ub3VzbHksIHNvIGp1c3QgY2hlY2sgdmVyc2lvbnNcbiAgaWYgKCFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIFY4X1ZFUlNJT04gPT09IDY2KSByZXR1cm4gdHJ1ZTtcbiAgLy8gV2UgY2FuJ3QgdXNlIEBAc3BlY2llcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy82NzlcbiAgaWYgKFY4X1ZFUlNJT04gPj0gNTEgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KFBST01JU0VfQ09OU1RSVUNUT1JfU09VUkNFKSkgcmV0dXJuIGZhbHNlO1xuICAvLyBEZXRlY3QgY29ycmVjdG5lc3Mgb2Ygc3ViY2xhc3Npbmcgd2l0aCBAQHNwZWNpZXMgc3VwcG9ydFxuICB2YXIgcHJvbWlzZSA9IG5ldyBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMyhmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKDEpOyB9KTtcbiAgdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICBleGVjKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSwgZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbiAgfTtcbiAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTJDJdID0gRmFrZVByb21pc2U7XG4gIFNVQkNMQVNTSU5HID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgaWYgKCFTVUJDTEFTU0lORykgcmV0dXJuIHRydWU7XG4gIC8vIFVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgcmV0dXJuICFHTE9CQUxfQ09SRV9KU19QUk9NSVNFICYmIElTX0JST1dTRVIgJiYgIU5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxO1xufSk7XG5cbnZhciBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSB7XG4gIENPTlNUUlVDVE9SOiBGT1JDRURfUFJPTUlTRV9DT05TVFJVQ1RPUiQ1LFxuICBSRUpFQ1RJT05fRVZFTlQ6IE5BVElWRV9QUk9NSVNFX1JFSkVDVElPTl9FVkVOVCQxLFxuICBTVUJDTEFTU0lORzogU1VCQ0xBU1NJTkdcbn07XG5cbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSQyID0ge307XG5cbnZhciBhQ2FsbGFibGUkNiA9IGFDYWxsYWJsZSQ5O1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUNhbGxhYmxlJDYocmVzb2x2ZSk7XG4gIHRoaXMucmVqZWN0ID0gYUNhbGxhYmxlJDYocmVqZWN0KTtcbn07XG5cbi8vIGBOZXdQcm9taXNlQ2FwYWJpbGl0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW5ld3Byb21pc2VjYXBhYmlsaXR5XG5uZXdQcm9taXNlQ2FwYWJpbGl0eSQyLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcblxudmFyICQkZSA9IF9leHBvcnQ7XG52YXIgSVNfTk9ERSQxID0gZW5naW5lSXNOb2RlO1xudmFyIGdsb2JhbCRjID0gZ2xvYmFsJHQ7XG52YXIgY2FsbCRmID0gZnVuY3Rpb25DYWxsO1xudmFyIGRlZmluZUJ1aWx0SW4kNiA9IGRlZmluZUJ1aWx0SW4kODtcbnZhciBzZXRQcm90b3R5cGVPZiQ1ID0gb2JqZWN0U2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0VG9TdHJpbmdUYWckMyA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgc2V0U3BlY2llcyQxID0gc2V0U3BlY2llcyQyO1xudmFyIGFDYWxsYWJsZSQ1ID0gYUNhbGxhYmxlJDk7XG52YXIgaXNDYWxsYWJsZSQ3ID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDcgPSBpc09iamVjdCRkO1xudmFyIGFuSW5zdGFuY2UkMiA9IGFuSW5zdGFuY2UkMztcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMiA9IHNwZWNpZXNDb25zdHJ1Y3RvciQzO1xudmFyIHRhc2sgPSB0YXNrJDEuc2V0O1xudmFyIG1pY3JvdGFzayA9IG1pY3JvdGFzayQxO1xudmFyIGhvc3RSZXBvcnRFcnJvcnMgPSBob3N0UmVwb3J0RXJyb3JzJDE7XG52YXIgcGVyZm9ybSQyID0gcGVyZm9ybSQzO1xudmFyIFF1ZXVlID0gcXVldWU7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0ID0gaW50ZXJuYWxTdGF0ZTtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiA9IHByb21pc2VOYXRpdmVDb25zdHJ1Y3RvcjtcbnZhciBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24gPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb247XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMyA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG5cbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgPSBQcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UID0gUHJvbWlzZUNvbnN0cnVjdG9yRGV0ZWN0aW9uLlJFSkVDVElPTl9FVkVOVDtcbnZhciBOQVRJVkVfUFJPTUlTRV9TVUJDTEFTU0lORyA9IFByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5TVUJDTEFTU0lORztcbnZhciBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0LnNldDtcbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEgPSBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMiAmJiBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IkMi5wcm90b3R5cGU7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDI7XG52YXIgUHJvbWlzZVByb3RvdHlwZSA9IE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMTtcbnZhciBUeXBlRXJyb3IkMiA9IGdsb2JhbCRjLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCQxID0gZ2xvYmFsJGMuZG9jdW1lbnQ7XG52YXIgcHJvY2VzcyA9IGdsb2JhbCRjLnByb2Nlc3M7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlJDMuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSQxO1xuXG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCQxICYmIGRvY3VtZW50JDEuY3JlYXRlRXZlbnQgJiYgZ2xvYmFsJGMuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG5cbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyLCBuYXRpdmVUaGVuO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0JDcoaXQpICYmIGlzQ2FsbGFibGUkNyh0aGVuID0gaXQudGhlbikgPyB0aGVuIDogZmFsc2U7XG59O1xuXG52YXIgY2FsbFJlYWN0aW9uID0gZnVuY3Rpb24gKHJlYWN0aW9uLCBzdGF0ZSkge1xuICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgdmFyIG9rID0gc3RhdGUuc3RhdGUgPT0gRlVMRklMTEVEO1xuICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgdHJ5IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaWYgKCFvaykge1xuICAgICAgICBpZiAoc3RhdGUucmVqZWN0aW9uID09PSBVTkhBTkRMRUQpIG9uSGFuZGxlVW5oYW5kbGVkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUucmVqZWN0aW9uID0gSEFORExFRDtcbiAgICAgIH1cbiAgICAgIGlmIChoYW5kbGVyID09PSB0cnVlKSByZXN1bHQgPSB2YWx1ZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgcmVzdWx0ID0gaGFuZGxlcih2YWx1ZSk7IC8vIGNhbiB0aHJvd1xuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICBleGl0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICAgIHJlamVjdChUeXBlRXJyb3IkMignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhlbiA9IGlzVGhlbmFibGUocmVzdWx0KSkge1xuICAgICAgICBjYWxsJGYodGhlbiwgcmVzdWx0LCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICB9IGVsc2UgcmVqZWN0KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgfVxufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVhY3Rpb25zID0gc3RhdGUucmVhY3Rpb25zO1xuICAgIHZhciByZWFjdGlvbjtcbiAgICB3aGlsZSAocmVhY3Rpb24gPSByZWFjdGlvbnMuZ2V0KCkpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5ub3RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhc3RhdGUucmVqZWN0aW9uKSBvblVuaGFuZGxlZChzdGF0ZSk7XG4gIH0pO1xufTtcblxudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gIHZhciBldmVudCwgaGFuZGxlcjtcbiAgaWYgKERJU1BBVENIX0VWRU5UKSB7XG4gICAgZXZlbnQgPSBkb2N1bWVudCQxLmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbCRjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICB9IGVsc2UgZXZlbnQgPSB7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcmVhc29uIH07XG4gIGlmICghTkFUSVZFX1BST01JU0VfUkVKRUNUSU9OX0VWRU5UICYmIChoYW5kbGVyID0gZ2xvYmFsJGNbJ29uJyArIG5hbWVdKSkgaGFuZGxlcihldmVudCk7XG4gIGVsc2UgaWYgKG5hbWUgPT09IFVOSEFORExFRF9SRUpFQ1RJT04pIGhvc3RSZXBvcnRFcnJvcnMoJ1VuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbicsIHJlYXNvbik7XG59O1xuXG52YXIgb25VbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCRmKHRhc2ssIGdsb2JhbCRjLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gICAgdmFyIElTX1VOSEFORExFRCA9IGlzVW5oYW5kbGVkKHN0YXRlKTtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0kMihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFJDEpIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoJ3VuaGFuZGxlZFJlamVjdGlvbicsIHZhbHVlLCBwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoVU5IQU5ETEVEX1JFSkVDVElPTiwgcHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICAvLyBCcm93c2VycyBzaG91bGQgbm90IHRyaWdnZXIgYHJlamVjdGlvbkhhbmRsZWRgIGV2ZW50IGlmIGl0IHdhcyBoYW5kbGVkIGhlcmUsIE5vZGVKUyAtIHNob3VsZFxuICAgICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSQxIHx8IGlzVW5oYW5kbGVkKHN0YXRlKSA/IFVOSEFORExFRCA6IEhBTkRMRUQ7XG4gICAgICBpZiAocmVzdWx0LmVycm9yKSB0aHJvdyByZXN1bHQudmFsdWU7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xuXG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgY2FsbCRmKHRhc2ssIGdsb2JhbCRjLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb21pc2UgPSBzdGF0ZS5mYWNhZGU7XG4gICAgaWYgKElTX05PREUkMSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGRpc3BhdGNoRXZlbnQoUkVKRUNUSU9OX0hBTkRMRUQsIHByb21pc2UsIHN0YXRlLnZhbHVlKTtcbiAgfSk7XG59O1xuXG52YXIgYmluZCQzID0gZnVuY3Rpb24gKGZuLCBzdGF0ZSwgdW53cmFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBmbihzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gIH07XG59O1xuXG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAoc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiAgaWYgKHN0YXRlLmRvbmUpIHJldHVybjtcbiAgc3RhdGUuZG9uZSA9IHRydWU7XG4gIGlmICh1bndyYXApIHN0YXRlID0gdW53cmFwO1xuICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICBzdGF0ZS5zdGF0ZSA9IFJFSkVDVEVEO1xuICBub3RpZnkoc3RhdGUsIHRydWUpO1xufTtcblxudmFyIGludGVybmFsUmVzb2x2ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHRyeSB7XG4gICAgaWYgKHN0YXRlLmZhY2FkZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvciQyKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgdmFyIHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKTtcbiAgICBpZiAodGhlbikge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IGRvbmU6IGZhbHNlIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbCRmKHRoZW4sIHZhbHVlLFxuICAgICAgICAgICAgYmluZCQzKGludGVybmFsUmVzb2x2ZSwgd3JhcHBlciwgc3RhdGUpLFxuICAgICAgICAgICAgYmluZCQzKGludGVybmFsUmVqZWN0LCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkoc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QoeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIGFuSW5zdGFuY2UkMih0aGlzLCBQcm9taXNlUHJvdG90eXBlKTtcbiAgICBhQ2FsbGFibGUkNShleGVjdXRvcik7XG4gICAgY2FsbCRmKEludGVybmFsLCB0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IoYmluZCQzKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpLCBiaW5kJDMoaW50ZXJuYWxSZWplY3QsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGludGVybmFsUmVqZWN0KHN0YXRlLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIFByb21pc2VQcm90b3R5cGUgPSBQcm9taXNlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUkMyh0aGlzLCB7XG4gICAgICB0eXBlOiBQUk9NSVNFLFxuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBub3RpZmllZDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGZhbHNlLFxuICAgICAgcmVhY3Rpb25zOiBuZXcgUXVldWUoKSxcbiAgICAgIHJlamVjdGlvbjogZmFsc2UsXG4gICAgICBzdGF0ZTogUEVORElORyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfTtcblxuICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICBJbnRlcm5hbC5wcm90b3R5cGUgPSBkZWZpbmVCdWlsdEluJDYoUHJvbWlzZVByb3RvdHlwZSwgJ3RoZW4nLCBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUodGhpcyk7XG4gICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMShzcGVjaWVzQ29uc3RydWN0b3IkMih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgIHJlYWN0aW9uLm9rID0gaXNDYWxsYWJsZSQ3KG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICByZWFjdGlvbi5mYWlsID0gaXNDYWxsYWJsZSQ3KG9uUmVqZWN0ZWQpICYmIG9uUmVqZWN0ZWQ7XG4gICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSQxID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgaWYgKHN0YXRlLnN0YXRlID09IFBFTkRJTkcpIHN0YXRlLnJlYWN0aW9ucy5hZGQocmVhY3Rpb24pO1xuICAgIGVsc2UgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxSZWFjdGlvbihyZWFjdGlvbiwgc3RhdGUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICB9KTtcblxuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHByb21pc2UpO1xuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gICAgdGhpcy5yZXNvbHZlID0gYmluZCQzKGludGVybmFsUmVzb2x2ZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZCQzKGludGVybmFsUmVqZWN0LCBzdGF0ZSk7XG4gIH07XG5cbiAgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMy5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMSA9IGZ1bmN0aW9uIChDKSB7XG4gICAgcmV0dXJuIEMgPT09IFByb21pc2VDb25zdHJ1Y3RvciB8fCBDID09PSBQcm9taXNlV3JhcHBlclxuICAgICAgPyBuZXcgT3duUHJvbWlzZUNhcGFiaWxpdHkoQylcbiAgICAgIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB9O1xuXG4gIGlmIChpc0NhbGxhYmxlJDcoTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yJDIpICYmIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMSAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgIG5hdGl2ZVRoZW4gPSBOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEudGhlbjtcblxuICAgIGlmICghTkFUSVZFX1BST01JU0VfU1VCQ0xBU1NJTkcpIHtcbiAgICAgIC8vIG1ha2UgYFByb21pc2UjdGhlbmAgcmV0dXJuIGEgcG9seWZpbGxlZCBgUHJvbWlzZWAgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICAgIGRlZmluZUJ1aWx0SW4kNihOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsICd0aGVuJywgZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBjYWxsJGYobmF0aXZlVGhlbiwgdGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjQwXG4gICAgICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgICB9XG5cbiAgICAvLyBtYWtlIGAuY29uc3RydWN0b3IgPT09IFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICB0cnkge1xuICAgICAgZGVsZXRlIE5hdGl2ZVByb21pc2VQcm90b3R5cGUkMS5jb25zdHJ1Y3RvcjtcbiAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbiAgICAvLyBtYWtlIGBpbnN0YW5jZW9mIFByb21pc2VgIHdvcmsgZm9yIG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXNcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YkNSkge1xuICAgICAgc2V0UHJvdG90eXBlT2YkNShOYXRpdmVQcm9taXNlUHJvdG90eXBlJDEsIFByb21pc2VQcm90b3R5cGUpO1xuICAgIH1cbiAgfVxufVxuXG4kJGUoeyBnbG9iYWw6IHRydWUsIGNvbnN0cnVjdG9yOiB0cnVlLCB3cmFwOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDQgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyQzKFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSwgZmFsc2UpO1xuc2V0U3BlY2llcyQxKFBST01JU0UpO1xuXG52YXIgaXRlcmF0b3JzID0ge307XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIEl0ZXJhdG9ycyQ0ID0gaXRlcmF0b3JzO1xuXG52YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCRiKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlJDEgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMiA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzJDQuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlJDFbSVRFUkFUT1IkNV0gPT09IGl0KTtcbn07XG5cbnZhciBjbGFzc29mJDcgPSBjbGFzc29mJDk7XG52YXIgZ2V0TWV0aG9kJDIgPSBnZXRNZXRob2QkNDtcbnZhciBJdGVyYXRvcnMkMyA9IGl0ZXJhdG9ycztcbnZhciB3ZWxsS25vd25TeW1ib2wkYSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IkNCA9IHdlbGxLbm93blN5bWJvbCRhKCdpdGVyYXRvcicpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gZ2V0TWV0aG9kJDIoaXQsIElURVJBVE9SJDQpXG4gICAgfHwgZ2V0TWV0aG9kJDIoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnMkM1tjbGFzc29mJDcoaXQpXTtcbn07XG5cbnZhciBjYWxsJGUgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkOTtcbnZhciBhbk9iamVjdCQ5ID0gYW5PYmplY3QkZTtcbnZhciB0cnlUb1N0cmluZyQyID0gdHJ5VG9TdHJpbmckNTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gZ2V0SXRlcmF0b3JNZXRob2QkMztcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDIgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQyKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkNChpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ5KGNhbGwkZShpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgJFR5cGVFcnJvciQ1KHRyeVRvU3RyaW5nJDIoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbnZhciBjYWxsJGQgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkOCA9IGFuT2JqZWN0JGU7XG52YXIgZ2V0TWV0aG9kJDEgPSBnZXRNZXRob2QkNDtcblxudmFyIGl0ZXJhdG9yQ2xvc2UkMSA9IGZ1bmN0aW9uIChpdGVyYXRvciwga2luZCwgdmFsdWUpIHtcbiAgdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuICBhbk9iamVjdCQ4KGl0ZXJhdG9yKTtcbiAgdHJ5IHtcbiAgICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZCQxKGl0ZXJhdG9yLCAncmV0dXJuJyk7XG4gICAgaWYgKCFpbm5lclJlc3VsdCkge1xuICAgICAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpbm5lclJlc3VsdCA9IGNhbGwkZChpbm5lclJlc3VsdCwgaXRlcmF0b3IpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlubmVyRXJyb3IgPSB0cnVlO1xuICAgIGlubmVyUmVzdWx0ID0gZXJyb3I7XG4gIH1cbiAgaWYgKGtpbmQgPT09ICd0aHJvdycpIHRocm93IHZhbHVlO1xuICBpZiAoaW5uZXJFcnJvcikgdGhyb3cgaW5uZXJSZXN1bHQ7XG4gIGFuT2JqZWN0JDgoaW5uZXJSZXN1bHQpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG52YXIgYmluZCQyID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJGMgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkNyA9IGFuT2JqZWN0JGU7XG52YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDU7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDEgPSBpc0FycmF5SXRlcmF0b3JNZXRob2QkMjtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ2ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciBpc1Byb3RvdHlwZU9mJDIgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIGdldEl0ZXJhdG9yJDEgPSBnZXRJdGVyYXRvciQyO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDEgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDE7XG5cbnZhciAkVHlwZUVycm9yJDQgPSBUeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDIgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX0lURVJBVE9SID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklTX0lURVJBVE9SKTtcbiAgdmFyIElOVEVSUlVQVEVEID0gISEob3B0aW9ucyAmJiBvcHRpb25zLklOVEVSUlVQVEVEKTtcbiAgdmFyIGZuID0gYmluZCQyKHVuYm91bmRGdW5jdGlvbiwgdGhhdCk7XG4gIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG5cbiAgdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgY29uZGl0aW9uKTtcbiAgICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuICB9O1xuXG4gIHZhciBjYWxsRm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoQVNfRU5UUklFUykge1xuICAgICAgYW5PYmplY3QkNyh2YWx1ZSk7XG4gICAgICByZXR1cm4gSU5URVJSVVBURUQgPyBmbih2YWx1ZVswXSwgdmFsdWVbMV0sIHN0b3ApIDogZm4odmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICB9IHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlLCBzdG9wKSA6IGZuKHZhbHVlKTtcbiAgfTtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kJDEoaXRlcmFibGUpO1xuICAgIGlmICghaXRlckZuKSB0aHJvdyAkVHlwZUVycm9yJDQodHJ5VG9TdHJpbmckMShpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxKGl0ZXJGbikpIHtcbiAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ2KGl0ZXJhYmxlKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgaXNQcm90b3R5cGVPZiQyKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xuICAgIH1cbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDEoaXRlcmFibGUsIGl0ZXJGbik7XG4gIH1cblxuICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkYyhuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDIoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkOSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgSVRFUkFUT1IkMyA9IHdlbGxLbm93blN5bWJvbCQ5KCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgY2FsbGVkID0gMDtcbiAgdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBkb25lOiAhIWNhbGxlZCsrIH07XG4gICAgfSxcbiAgICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIGl0ZXJhdG9yV2l0aFJldHVybltJVEVSQVRPUiQzXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQyID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICBpZiAoIVNLSVBfQ0xPU0lORyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBJVEVSQVRJT05fU1VQUE9SVCA9IGZhbHNlO1xuICB0cnkge1xuICAgIHZhciBvYmplY3QgPSB7fTtcbiAgICBvYmplY3RbSVRFUkFUT1IkM10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcblxudmFyIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxID0gcHJvbWlzZU5hdGl2ZUNvbnN0cnVjdG9yO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxudmFyIHByb21pc2VTdGF0aWNzSW5jb3JyZWN0SXRlcmF0aW9uID0gRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMyB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDEoZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3RvciQxLmFsbChpdGVyYWJsZSkudGhlbih1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcblxudmFyICQkZCA9IF9leHBvcnQ7XG52YXIgY2FsbCRiID0gZnVuY3Rpb25DYWxsO1xudmFyIGFDYWxsYWJsZSQzID0gYUNhbGxhYmxlJDk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgcGVyZm9ybSQxID0gcGVyZm9ybSQzO1xudmFyIGl0ZXJhdGUkMSA9IGl0ZXJhdGUkMjtcbnZhciBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiQxID0gcHJvbWlzZVN0YXRpY3NJbmNvcnJlY3RJdGVyYXRpb247XG5cbi8vIGBQcm9taXNlLmFsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UuYWxsXG4kJGQoeyB0YXJnZXQ6ICdQcm9taXNlJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBQUk9NSVNFX1NUQVRJQ1NfSU5DT1JSRUNUX0lURVJBVElPTiQxIH0sIHtcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQyLmYoQyk7XG4gICAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtJDEoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyICRwcm9taXNlUmVzb2x2ZSA9IGFDYWxsYWJsZSQzKEMucmVzb2x2ZSk7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGl0ZXJhdGUkMShpdGVyYWJsZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgICAgICB2YXIgYWxyZWFkeUNhbGxlZCA9IGZhbHNlO1xuICAgICAgICByZW1haW5pbmcrKztcbiAgICAgICAgY2FsbCRiKCRwcm9taXNlUmVzb2x2ZSwgQywgcHJvbWlzZSkudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICBpZiAoYWxyZWFkeUNhbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIGFscmVhZHlDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmVycm9yKSByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyICQkYyA9IF9leHBvcnQ7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcbnZhciBOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IgPSBwcm9taXNlTmF0aXZlQ29uc3RydWN0b3I7XG52YXIgZ2V0QnVpbHRJbiQxID0gZ2V0QnVpbHRJbiQ4O1xudmFyIGlzQ2FsbGFibGUkNiA9IGlzQ2FsbGFibGUkbjtcbnZhciBkZWZpbmVCdWlsdEluJDUgPSBkZWZpbmVCdWlsdEluJDg7XG5cbnZhciBOYXRpdmVQcm9taXNlUHJvdG90eXBlID0gTmF0aXZlUHJvbWlzZUNvbnN0cnVjdG9yICYmIE5hdGl2ZVByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5jYXRjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4kJGMoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMiwgcmVhbDogdHJ1ZSB9LCB7XG4gICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG59KTtcblxuLy8gbWFrZXMgc3VyZSB0aGF0IG5hdGl2ZSBwcm9taXNlLWJhc2VkIEFQSXMgYFByb21pc2UjY2F0Y2hgIHByb3Blcmx5IHdvcmtzIHdpdGggcGF0Y2hlZCBgUHJvbWlzZSN0aGVuYFxuaWYgKGlzQ2FsbGFibGUkNihOYXRpdmVQcm9taXNlQ29uc3RydWN0b3IpKSB7XG4gIHZhciBtZXRob2QgPSBnZXRCdWlsdEluJDEoJ1Byb21pc2UnKS5wcm90b3R5cGVbJ2NhdGNoJ107XG4gIGlmIChOYXRpdmVQcm9taXNlUHJvdG90eXBlWydjYXRjaCddICE9PSBtZXRob2QpIHtcbiAgICBkZWZpbmVCdWlsdEluJDUoTmF0aXZlUHJvbWlzZVByb3RvdHlwZSwgJ2NhdGNoJywgbWV0aG9kLCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgfVxufVxuXG52YXIgJCRiID0gX2V4cG9ydDtcbnZhciBjYWxsJGEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkOTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSQxID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcbnZhciBwZXJmb3JtID0gcGVyZm9ybSQzO1xudmFyIGl0ZXJhdGUgPSBpdGVyYXRlJDI7XG52YXIgUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gPSBwcm9taXNlU3RhdGljc0luY29ycmVjdEl0ZXJhdGlvbjtcblxuLy8gYFByb21pc2UucmFjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuJCRiKHsgdGFyZ2V0OiAnUHJvbWlzZScsIHN0YXQ6IHRydWUsIGZvcmNlZDogUFJPTUlTRV9TVEFUSUNTX0lOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUkMS5mKEMpO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUNhbGxhYmxlJDIoQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIGNhbGwkYSgkcHJvbWlzZVJlc29sdmUsIEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyIGNhbGwkOSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5JDI7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IkMSA9IHByb21pc2VDb25zdHJ1Y3RvckRldGVjdGlvbi5DT05TVFJVQ1RPUjtcblxuLy8gYFByb21pc2UucmVqZWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZWplY3RcbiQkYSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SJDEgfSwge1xuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mKHRoaXMpO1xuICAgIGNhbGwkOShjYXBhYmlsaXR5LnJlamVjdCwgdW5kZWZpbmVkLCByKTtcbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG59KTtcblxudmFyIGFuT2JqZWN0JDYgPSBhbk9iamVjdCRlO1xudmFyIGlzT2JqZWN0JDYgPSBpc09iamVjdCRkO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkkMjtcblxudmFyIHByb21pc2VSZXNvbHZlJDEgPSBmdW5jdGlvbiAoQywgeCkge1xuICBhbk9iamVjdCQ2KEMpO1xuICBpZiAoaXNPYmplY3QkNih4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG5cbnZhciAkJDkgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJDg7XG52YXIgRk9SQ0VEX1BST01JU0VfQ09OU1RSVUNUT1IgPSBwcm9taXNlQ29uc3RydWN0b3JEZXRlY3Rpb24uQ09OU1RSVUNUT1I7XG52YXIgcHJvbWlzZVJlc29sdmUgPSBwcm9taXNlUmVzb2x2ZSQxO1xuXG5nZXRCdWlsdEluKCdQcm9taXNlJyk7XG5cbi8vIGBQcm9taXNlLnJlc29sdmVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlc29sdmVcbiQkOSh7IHRhcmdldDogJ1Byb21pc2UnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRF9QUk9NSVNFX0NPTlNUUlVDVE9SIH0sIHtcbiAgcmVzb2x2ZTogZnVuY3Rpb24gcmVzb2x2ZSh4KSB7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKHRoaXMsIHgpO1xuICB9XG59KTtcblxuY2xhc3MgV2ViU3RvcmFnZVNlcnZpY2Uge1xuICBnZXRJdGVtKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydGllcyA9IHt9O1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDEgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxudmFyIG9iamVjdEtleXMkMiA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzJDEpO1xufTtcblxudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IHY4UHJvdG90eXBlRGVmaW5lQnVnO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkZTtcbnZhciB0b0luZGV4ZWRPYmplY3QkMiA9IHRvSW5kZXhlZE9iamVjdCQ2O1xudmFyIG9iamVjdEtleXMkMSA9IG9iamVjdEtleXMkMjtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnRpZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbm9iamVjdERlZmluZVByb3BlcnRpZXMuZiA9IERFU0NSSVBUT1JTJDUgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QkNShPKTtcbiAgdmFyIHByb3BzID0gdG9JbmRleGVkT2JqZWN0JDIoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyQxKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgZGVmaW5lUHJvcGVydHlNb2R1bGUkMi5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuICByZXR1cm4gTztcbn07XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG5cbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkZTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyA9IGVudW1CdWdLZXlzJDM7XG52YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNDtcbnZhciBodG1sID0gaHRtbCQyO1xudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50JDI7XG52YXIgc2hhcmVkS2V5JDEgPSBzaGFyZWRLZXkkMztcblxudmFyIEdUID0gJz4nO1xudmFyIExUID0gJzwnO1xudmFyIFBST1RPVFlQRSQxID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8kMSA9IHNoYXJlZEtleSQxKCdJRV9QUk9UTycpO1xuXG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxudmFyIHNjcmlwdFRhZyA9IGZ1bmN0aW9uIChjb250ZW50KSB7XG4gIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgQWN0aXZlWCBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiAgYWN0aXZlWERvY3VtZW50LmNsb3NlKCk7XG4gIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7IC8vIGF2b2lkIG1lbW9yeSBsZWFrXG4gIHJldHVybiB0ZW1wO1xufTtcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQxKCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRSQxXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiAgcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UTyQxXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWNyZWF0ZSAtLSBzYWZlXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gYW5PYmplY3QkNChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuICAgIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFJDFdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPJDFdID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllc01vZHVsZS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgd2VsbEtub3duU3ltYm9sJDggPSB3ZWxsS25vd25TeW1ib2wkajtcbnZhciBjcmVhdGUkMyA9IG9iamVjdENyZWF0ZTtcbnZhciBkZWZpbmVQcm9wZXJ0eSQ0ID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcblxudmFyIFVOU0NPUEFCTEVTID0gd2VsbEtub3duU3ltYm9sJDgoJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuaWYgKEFycmF5UHJvdG90eXBlW1VOU0NPUEFCTEVTXSA9PSB1bmRlZmluZWQpIHtcbiAgZGVmaW5lUHJvcGVydHkkNChBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgdmFsdWU6IGNyZWF0ZSQzKG51bGwpXG4gIH0pO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgYWRkVG9VbnNjb3BhYmxlcyQyID0gZnVuY3Rpb24gKGtleSkge1xuICBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG52YXIgZmFpbHMkaCA9IGZhaWxzJHM7XG5cbnZhciBjb3JyZWN0UHJvdG90eXBlR2V0dGVyID0gIWZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWdldHByb3RvdHlwZW9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmV3IEYoKSkgIT09IEYucHJvdG90eXBlO1xufSk7XG5cbnZhciBoYXNPd24kMiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNDYWxsYWJsZSQ1ID0gaXNDYWxsYWJsZSRuO1xudmFyIHRvT2JqZWN0JDUgPSB0b09iamVjdCQ3O1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQzO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IGNvcnJlY3RQcm90b3R5cGVHZXR0ZXI7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSQyID0gJE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiAgdmFyIG9iamVjdCA9IHRvT2JqZWN0JDUoTyk7XG4gIGlmIChoYXNPd24kMihvYmplY3QsIElFX1BST1RPKSkgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gIHZhciBjb25zdHJ1Y3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgaWYgKGlzQ2FsbGFibGUkNShjb25zdHJ1Y3RvcikgJiYgb2JqZWN0IGluc3RhbmNlb2YgY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiAkT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlJDIgOiBudWxsO1xufTtcblxudmFyIGZhaWxzJGcgPSBmYWlscyRzO1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkbjtcbnZhciBnZXRQcm90b3R5cGVPZiQzID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgZGVmaW5lQnVpbHRJbiQ0ID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHdlbGxLbm93blN5bWJvbCQ3ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJDcoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSQyLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzLXgvbm8tYXJyYXktcHJvdG90eXBlLWtleXMgLS0gc2FmZSAqL1xuaWYgKFtdLmtleXMpIHtcbiAgYXJyYXlJdGVyYXRvciA9IFtdLmtleXMoKTtcbiAgLy8gU2FmYXJpIDggaGFzIGJ1Z2d5IGl0ZXJhdG9ycyB3L28gYG5leHRgXG4gIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSkgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YkMyhnZXRQcm90b3R5cGVPZiQzKGFycmF5SXRlcmF0b3IpKTtcbiAgICBpZiAoUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlKSBJdGVyYXRvclByb3RvdHlwZSQyID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbnZhciBORVdfSVRFUkFUT1JfUFJPVE9UWVBFID0gSXRlcmF0b3JQcm90b3R5cGUkMiA9PSB1bmRlZmluZWQgfHwgZmFpbHMkZyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0ge307XG4gIC8vIEZGNDQtIGxlZ2FjeSBpdGVyYXRvcnMgY2FzZVxuICByZXR1cm4gSXRlcmF0b3JQcm90b3R5cGUkMltJVEVSQVRPUiQyXS5jYWxsKHRlc3QpICE9PSB0ZXN0O1xufSk7XG5cbmlmIChORVdfSVRFUkFUT1JfUFJPVE9UWVBFKSBJdGVyYXRvclByb3RvdHlwZSQyID0ge307XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZSQ0KEl0ZXJhdG9yUHJvdG90eXBlJDJbSVRFUkFUT1IkMl0pKSB7XG4gIGRlZmluZUJ1aWx0SW4kNChJdGVyYXRvclByb3RvdHlwZSQyLCBJVEVSQVRPUiQyLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG52YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlJDIsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMVxufTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlJDEgPSBpdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSQyID0gb2JqZWN0Q3JlYXRlO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgc2V0VG9TdHJpbmdUYWckMiA9IHNldFRvU3RyaW5nVGFnJDQ7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG5cbnZhciByZXR1cm5UaGlzJDEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKEl0ZXJhdG9yQ29uc3RydWN0b3IsIE5BTUUsIG5leHQsIEVOVU1FUkFCTEVfTkVYVCkge1xuICB2YXIgVE9fU1RSSU5HX1RBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUkMihJdGVyYXRvclByb3RvdHlwZSQxLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWckMihJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSk7XG4gIEl0ZXJhdG9ycyQyW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciAkJDggPSBfZXhwb3J0O1xudmFyIGNhbGwkOCA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBGdW5jdGlvbk5hbWUkMSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBpc0NhbGxhYmxlJDMgPSBpc0NhbGxhYmxlJG47XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IkMTtcbnZhciBnZXRQcm90b3R5cGVPZiQyID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgc2V0UHJvdG90eXBlT2YkNCA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIHNldFRvU3RyaW5nVGFnJDEgPSBzZXRUb1N0cmluZ1RhZyQ0O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbiQzID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJGo7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG52YXIgSXRlcmF0b3JzQ29yZSA9IGl0ZXJhdG9yc0NvcmU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSQyID0gRnVuY3Rpb25OYW1lJDEuUFJPUEVSO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEgPSBGdW5jdGlvbk5hbWUkMS5DT05GSUdVUkFCTEU7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBJdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkMSA9IHdlbGxLbm93blN5bWJvbCQ2KCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQxXVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09ICdBcnJheScgPyBJdGVyYWJsZVByb3RvdHlwZS5lbnRyaWVzIHx8IG5hdGl2ZUl0ZXJhdG9yIDogbmF0aXZlSXRlcmF0b3I7XG4gIHZhciBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIG1ldGhvZHMsIEtFWTtcblxuICAvLyBmaXggbmF0aXZlXG4gIGlmIChhbnlOYXRpdmVJdGVyYXRvcikge1xuICAgIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDIoYW55TmF0aXZlSXRlcmF0b3IuY2FsbChuZXcgSXRlcmFibGUoKSkpO1xuICAgIGlmIChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIGlmIChnZXRQcm90b3R5cGVPZiQyKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSkgIT09IEl0ZXJhdG9yUHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChzZXRQcm90b3R5cGVPZiQ0KSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YkNChDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNDYWxsYWJsZSQzKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUiQxXSkpIHtcbiAgICAgICAgICBkZWZpbmVCdWlsdEluJDMoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiQxLCByZXR1cm5UaGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWckMShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGZpeCBBcnJheS5wcm90b3R5cGUueyB2YWx1ZXMsIEBAaXRlcmF0b3IgfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKFBST1BFUl9GVU5DVElPTl9OQU1FJDIgJiYgREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgaWYgKENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FJDEpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KEl0ZXJhYmxlUHJvdG90eXBlLCAnbmFtZScsIFZBTFVFUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJDgobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCQ4KHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkMV0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkMSwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDFbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG52YXIgdG9JbmRleGVkT2JqZWN0JDEgPSB0b0luZGV4ZWRPYmplY3QkNjtcbnZhciBhZGRUb1Vuc2NvcGFibGVzJDEgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG52YXIgSXRlcmF0b3JzID0gaXRlcmF0b3JzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMyA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBkZWZpbmVJdGVyYXRvciQxO1xudmFyIERFU0NSSVBUT1JTJDQgPSBkZXNjcmlwdG9ycztcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDMuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkNCA9IEludGVybmFsU3RhdGVNb2R1bGUkMy5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbnZhciBlc19hcnJheV9pdGVyYXRvciA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQyKHRoaXMsIHtcbiAgICB0eXBlOiBBUlJBWV9JVEVSQVRPUixcbiAgICB0YXJnZXQ6IHRvSW5kZXhlZE9iamVjdCQxKGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWFycmF5aXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSQ0KHRoaXMpO1xuICB2YXIgdGFyZ2V0ID0gc3RhdGUudGFyZ2V0O1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gIGlmICghdGFyZ2V0IHx8IGluZGV4ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGluZGV4LCBkb25lOiBmYWxzZSB9O1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHsgdmFsdWU6IHRhcmdldFtpbmRleF0sIGRvbmU6IGZhbHNlIH07XG4gIHJldHVybiB7IHZhbHVlOiBbaW5kZXgsIHRhcmdldFtpbmRleF1dLCBkb25lOiBmYWxzZSB9O1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyVcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtY3JlYXRlbWFwcGVkYXJndW1lbnRzb2JqZWN0XG52YXIgdmFsdWVzID0gSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzJDEoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcyQxKCdlbnRyaWVzJyk7XG5cbi8vIFY4IH4gQ2hyb21lIDQ1LSBidWdcbmlmIChERVNDUklQVE9SUyQ0ICYmIHZhbHVlcy5uYW1lICE9PSAndmFsdWVzJykgdHJ5IHtcbiAgZGVmaW5lUHJvcGVydHkkMyh2YWx1ZXMsICduYW1lJywgeyB2YWx1ZTogJ3ZhbHVlcycgfSk7XG59IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG5cbi8vIGl0ZXJhYmxlIERPTSBjb2xsZWN0aW9uc1xuLy8gZmxhZyAtIGBpdGVyYWJsZWAgaW50ZXJmYWNlIC0gJ2VudHJpZXMnLCAna2V5cycsICd2YWx1ZXMnLCAnZm9yRWFjaCcgbWV0aG9kc1xudmFyIGRvbUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IDAsXG4gIENTU1N0eWxlRGVjbGFyYXRpb246IDAsXG4gIENTU1ZhbHVlTGlzdDogMCxcbiAgQ2xpZW50UmVjdExpc3Q6IDAsXG4gIERPTVJlY3RMaXN0OiAwLFxuICBET01TdHJpbmdMaXN0OiAwLFxuICBET01Ub2tlbkxpc3Q6IDEsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiAwLFxuICBGaWxlTGlzdDogMCxcbiAgSFRNTEFsbENvbGxlY3Rpb246IDAsXG4gIEhUTUxDb2xsZWN0aW9uOiAwLFxuICBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiAwLFxuICBNZWRpYUxpc3Q6IDAsXG4gIE1pbWVUeXBlQXJyYXk6IDAsXG4gIE5hbWVkTm9kZU1hcDogMCxcbiAgTm9kZUxpc3Q6IDEsXG4gIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gIFBsdWdpbjogMCxcbiAgUGx1Z2luQXJyYXk6IDAsXG4gIFNWR0xlbmd0aExpc3Q6IDAsXG4gIFNWR051bWJlckxpc3Q6IDAsXG4gIFNWR1BhdGhTZWdMaXN0OiAwLFxuICBTVkdQb2ludExpc3Q6IDAsXG4gIFNWR1N0cmluZ0xpc3Q6IDAsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IDAsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gIFN0eWxlU2hlZXRMaXN0OiAwLFxuICBUZXh0VHJhY2tDdWVMaXN0OiAwLFxuICBUZXh0VHJhY2tMaXN0OiAwLFxuICBUb3VjaExpc3Q6IDBcbn07XG5cbi8vIGluIG9sZCBXZWJLaXQgdmVyc2lvbnMsIGBlbGVtZW50LmNsYXNzTGlzdGAgaXMgbm90IGFuIGluc3RhbmNlIG9mIGdsb2JhbCBgRE9NVG9rZW5MaXN0YFxudmFyIGRvY3VtZW50Q3JlYXRlRWxlbWVudCA9IGRvY3VtZW50Q3JlYXRlRWxlbWVudCQyO1xuXG52YXIgY2xhc3NMaXN0ID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdzcGFuJykuY2xhc3NMaXN0O1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSQxID0gY2xhc3NMaXN0ICYmIGNsYXNzTGlzdC5jb25zdHJ1Y3RvciAmJiBjbGFzc0xpc3QuY29uc3RydWN0b3IucHJvdG90eXBlO1xuXG52YXIgZG9tVG9rZW5MaXN0UHJvdG90eXBlID0gRE9NVG9rZW5MaXN0UHJvdG90eXBlJDEgPT09IE9iamVjdC5wcm90b3R5cGUgPyB1bmRlZmluZWQgOiBET01Ub2tlbkxpc3RQcm90b3R5cGUkMTtcblxudmFyIGdsb2JhbCRiID0gZ2xvYmFsJHQ7XG52YXIgRE9NSXRlcmFibGVzID0gZG9tSXRlcmFibGVzO1xudmFyIERPTVRva2VuTGlzdFByb3RvdHlwZSA9IGRvbVRva2VuTGlzdFByb3RvdHlwZTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IGVzX2FycmF5X2l0ZXJhdG9yO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgd2VsbEtub3duU3ltYm9sJDUgPSB3ZWxsS25vd25TeW1ib2wkajtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sJDUoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyQxID0gd2VsbEtub3duU3ltYm9sJDUoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbnZhciBoYW5kbGVQcm90b3R5cGUgPSBmdW5jdGlvbiAoQ29sbGVjdGlvblByb3RvdHlwZSwgQ09MTEVDVElPTl9OQU1FKSB7XG4gIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlKSB7XG4gICAgLy8gc29tZSBDaHJvbWUgdmVyc2lvbnMgaGF2ZSBub24tY29uZmlndXJhYmxlIG1ldGhvZHMgb24gRE9NVG9rZW5MaXN0XG4gICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcykgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHJDFdKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHJDEsIENPTExFQ1RJT05fTkFNRSk7XG4gICAgfVxuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0KENvbGxlY3Rpb25Qcm90b3R5cGUsIE1FVEhPRF9OQU1FLCBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gPSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gIGhhbmRsZVByb3RvdHlwZShnbG9iYWwkYltDT0xMRUNUSU9OX05BTUVdICYmIGdsb2JhbCRiW0NPTExFQ1RJT05fTkFNRV0ucHJvdG90eXBlLCBDT0xMRUNUSU9OX05BTUUpO1xufVxuXG5oYW5kbGVQcm90b3R5cGUoRE9NVG9rZW5MaXN0UHJvdG90eXBlLCAnRE9NVG9rZW5MaXN0Jyk7XG5cbmNsYXNzIExvZ2dlciB7XG4gIGNvbnN0cnVjdG9yKG5hbWVzcGFjZSkge1xuICAgIHRoaXMubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICB9XG4gIGVtaXQobWV0aG9kLCAuLi5wYXJhbXMpIHtcbiAgICBpZiAoIUxvZ2dlci5kZWJ1Zykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uYW1lc3BhY2UgJiYgbWV0aG9kICE9PSBcImVycm9yXCIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlW21ldGhvZF0odGhpcy5uYW1lc3BhY2UsIC4uLnBhcmFtcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgY29uc29sZVttZXRob2RdKC4uLnBhcmFtcyk7XG4gIH1cbiAgbG9nKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcImxvZ1wiLCAuLi5wYXJhbXMpO1xuICB9XG4gIGluZm8oLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwiaW5mb1wiLCAuLi5wYXJhbXMpO1xuICB9XG4gIHdhcm4oLi4ucGFyYW1zKSB7XG4gICAgdGhpcy5lbWl0KFwid2FyblwiLCAuLi5wYXJhbXMpO1xuICB9XG4gIGVycm9yKC4uLnBhcmFtcykge1xuICAgIHRoaXMuZW1pdChcImVycm9yXCIsIC4uLnBhcmFtcyk7XG4gIH1cbn1cbkxvZ2dlci5kZWJ1ZyA9IGZhbHNlO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG52YXIgJCQ3ID0gX2V4cG9ydDtcbnZhciAkaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLmluY2x1ZGVzO1xudmFyIGZhaWxzJGYgPSBmYWlscyRzO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBhZGRUb1Vuc2NvcGFibGVzJDI7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyRmKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFBcnJheSgxKS5pbmNsdWRlcygpO1xufSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiQkNyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogQlJPS0VOX09OX1NQQVJTRSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKCdpbmNsdWRlcycpO1xuXG52YXIgaXNPYmplY3QkNSA9IGlzT2JqZWN0JGQ7XG52YXIgY2xhc3NvZiQ2ID0gY2xhc3NvZlJhdyQxO1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBNQVRDSCQxID0gd2VsbEtub3duU3ltYm9sJDQoJ21hdGNoJyk7XG5cbi8vIGBJc1JlZ0V4cGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG52YXIgaXNSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QkNShpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIJDFdKSAhPT0gdW5kZWZpbmVkID8gISFpc1JlZ0V4cCA6IGNsYXNzb2YkNihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxudmFyIGlzUmVnRXhwJDEgPSBpc1JlZ2V4cDtcblxudmFyICRUeXBlRXJyb3IkMyA9IFR5cGVFcnJvcjtcblxudmFyIG5vdEFSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwJDEoaXQpKSB7XG4gICAgdGhyb3cgJFR5cGVFcnJvciQzKFwiVGhlIG1ldGhvZCBkb2Vzbid0IGFjY2VwdCByZWd1bGFyIGV4cHJlc3Npb25zXCIpO1xuICB9IHJldHVybiBpdDtcbn07XG5cbnZhciBjbGFzc29mJDUgPSBjbGFzc29mJDk7XG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xuXG52YXIgdG9TdHJpbmckNSA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoY2xhc3NvZiQ1KGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmcoYXJndW1lbnQpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQzID0gd2VsbEtub3duU3ltYm9sJGo7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQzKCdtYXRjaCcpO1xuXG52YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJGIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNjtcbnZhciB0b1N0cmluZyQ0ID0gdG9TdHJpbmckNTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IGNvcnJlY3RJc1JlZ2V4cExvZ2ljO1xuXG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzJGIoJycuaW5kZXhPZik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuJCQ2KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5zdHJpbmdJbmRleE9mKFxuICAgICAgdG9TdHJpbmckNChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDModGhpcykpLFxuICAgICAgdG9TdHJpbmckNChub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICApO1xuICB9XG59KTtcblxuLy8gYSBzdHJpbmcgb2YgYWxsIHZhbGlkIHVuaWNvZGUgd2hpdGVzcGFjZXNcbnZhciB3aGl0ZXNwYWNlcyQyID0gJ1xcdTAwMDlcXHUwMDBBXFx1MDAwQlxcdTAwMENcXHUwMDBEXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MjAwMFxcdTIwMDFcXHUyMDAyJyArXG4gICdcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG5cbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG52YXIgdG9TdHJpbmckMyA9IHRvU3RyaW5nJDU7XG52YXIgd2hpdGVzcGFjZXMkMSA9IHdoaXRlc3BhY2VzJDI7XG5cbnZhciByZXBsYWNlJDEgPSB1bmN1cnJ5VGhpcyRhKCcnLnJlcGxhY2UpO1xudmFyIHdoaXRlc3BhY2UgPSAnWycgKyB3aGl0ZXNwYWNlcyQxICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDMgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzKSB7XG4gICAgdmFyIHN0cmluZyA9IHRvU3RyaW5nJDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQyKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSByZXBsYWNlJDEoc3RyaW5nLCBsdHJpbSwgJycpO1xuICAgIGlmIChUWVBFICYgMikgc3RyaW5nID0gcmVwbGFjZSQxKHN0cmluZywgcnRyaW0sICcnKTtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9O1xufTtcblxudmFyIHN0cmluZ1RyaW0gPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUxlZnQsIHRyaW1TdGFydCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltc3RhcnRcbiAgc3RhcnQ6IGNyZWF0ZU1ldGhvZCQzKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS50cmltZW5kXG4gIGVuZDogY3JlYXRlTWV0aG9kJDMoMiksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnRyaW1gIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QkMygzKVxufTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FJDEgPSBmdW5jdGlvbk5hbWUuUFJPUEVSO1xudmFyIGZhaWxzJGUgPSBmYWlscyRzO1xudmFyIHdoaXRlc3BhY2VzID0gd2hpdGVzcGFjZXMkMjtcblxudmFyIG5vbiA9ICdcXHUyMDBCXFx1MDA4NVxcdTE4MEUnO1xuXG4vLyBjaGVjayB0aGF0IGEgbWV0aG9kIHdvcmtzIHdpdGggdGhlIGNvcnJlY3QgbGlzdFxuLy8gb2Ygd2hpdGVzcGFjZXMgYW5kIGhhcyBhIGNvcnJlY3QgbmFtZVxudmFyIHN0cmluZ1RyaW1Gb3JjZWQgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuIGZhaWxzJGUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpXG4gICAgICB8fCBub25bTUVUSE9EX05BTUVdKCkgIT09IG5vblxuICAgICAgfHwgKFBST1BFUl9GVU5DVElPTl9OQU1FJDEgJiYgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FKTtcbiAgfSk7XG59O1xuXG52YXIgJCQ1ID0gX2V4cG9ydDtcbnZhciAkdHJpbSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciBmb3JjZWRTdHJpbmdUcmltTWV0aG9kID0gc3RyaW5nVHJpbUZvcmNlZDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuJCQ1KHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCgndHJpbScpIH0sIHtcbiAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICByZXR1cm4gJHRyaW0odGhpcyk7XG4gIH1cbn0pO1xuXG52YXIgREVTQ1JJUFRPUlMkMyA9IGRlc2NyaXB0b3JzO1xudmFyIHVuY3VycnlUaGlzJDkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBmYWlscyRkID0gZmFpbHMkcztcbnZhciBvYmplY3RLZXlzID0gb2JqZWN0S2V5cyQyO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IG9iamVjdFByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIHRvT2JqZWN0JDQgPSB0b09iamVjdCQ3O1xudmFyIEluZGV4ZWRPYmplY3QkMiA9IGluZGV4ZWRPYmplY3Q7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyQ5KFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJGQoZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMkMyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JDIoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSQyKHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby1zeW1ib2wgLS0gc2FmZVxuICB2YXIgc3ltYm9sID0gU3ltYm9sKCk7XG4gIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbc3ltYm9sXSA9IDc7XG4gIGFscGhhYmV0LnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChjaHIpIHsgQltjaHJdID0gY2hyOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW3N5bWJvbF0gIT0gNyB8fCBvYmplY3RLZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICB2YXIgVCA9IHRvT2JqZWN0JDQodGFyZ2V0KTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiAgdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0JDIoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChvYmplY3RLZXlzKFMpLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoUykpIDogb2JqZWN0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkMyB8fCBjYWxsJDcocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQkNCA9IF9leHBvcnQ7XG52YXIgYXNzaWduID0gb2JqZWN0QXNzaWduO1xuXG4vLyBgT2JqZWN0LmFzc2lnbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQkNCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlciQxKCk7XG4gIH1cbiAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vbihldmVudE5hbWUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtb3ZlOiAoKSA9PiB0aGlzLmVtaXR0ZXIub2ZmKGV2ZW50TmFtZSwgY2FsbGJhY2spXG4gICAgfTtcbiAgfVxuICBvZmYoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMuZW1pdHRlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gIH1cbiAgZW1pdChldmVudE5hbWUsIGV2ZW50KSB7XG4gICAgdGhpcy5lbWl0dGVyLmVtaXQoZXZlbnROYW1lLCBldmVudCk7XG4gIH1cbn1cblxuY29uc3QgUEFDS0FHRV9OQU1FID0gXCJuZWFyLXdhbGxldC1zZWxlY3RvclwiO1xuY29uc3QgUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMgPSBcInJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXCI7XG5jb25zdCBDT05UUkFDVCA9IFwiY29udHJhY3RcIjtcbmNvbnN0IFBFTkRJTkdfQ09OVFJBQ1QgPSBcImNvbnRyYWN0OnBlbmRpbmdcIjtcbmNvbnN0IFNFTEVDVEVEX1dBTExFVF9JRCA9IGBzZWxlY3RlZFdhbGxldElkYDtcbmNvbnN0IFBFTkRJTkdfU0VMRUNURURfV0FMTEVUX0lEID0gYHNlbGVjdGVkV2FsbGV0SWQ6cGVuZGluZ2A7XG5cbmNsYXNzIFdhbGxldE1vZHVsZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZmFjdG9yaWVzLFxuICAgIHN0b3JhZ2UsXG4gICAgb3B0aW9ucyxcbiAgICBzdG9yZSxcbiAgICBlbWl0dGVyLFxuICAgIHByb3ZpZGVyXG4gIH0pIHtcbiAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHRoaXMubW9kdWxlcyA9IFtdO1xuICAgIHRoaXMuaW5zdGFuY2VzID0ge307XG4gIH1cbiAgdmFsaWRhdGVXYWxsZXQoaWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGFjY291bnRzID0gW107XG4gICAgICBjb25zdCB3YWxsZXQgPSB5aWVsZCB0aGlzLmdldFdhbGxldChpZCk7XG4gICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgIC8vIEVuc3VyZSBvdXIgcGVyc2lzdGVudCBzdGF0ZSBhbGlnbnMgd2l0aCB0aGUgc2VsZWN0ZWQgd2FsbGV0LlxuICAgICAgICAvLyBGb3IgZXhhbXBsZSBhIHdhbGxldCBpcyBzZWxlY3RlZCwgYnV0IGl0IHJldHVybnMgbm8gYWNjb3VudHMgKG5vdCBzaWduZWQgaW4pLlxuICAgICAgICBhY2NvdW50cyA9IHlpZWxkIHdhbGxldC5nZXRBY2NvdW50cygpLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHZhbGlkYXRlICR7d2FsbGV0LmlkfSBkdXJpbmcgc2V0dXBgKTtcbiAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH0pO1xuICB9XG4gIHJlc29sdmVTdG9yYWdlU3RhdGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGpzb25TdG9yYWdlID0gbmV3IEpzb25TdG9yYWdlKHRoaXMuc3RvcmFnZSwgUEFDS0FHRV9OQU1FKTtcbiAgICAgIGNvbnN0IHBlbmRpbmdTZWxlY3RlZFdhbGxldElkID0geWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShQRU5ESU5HX1NFTEVDVEVEX1dBTExFVF9JRCk7XG4gICAgICBjb25zdCBwZW5kaW5nQ29udHJhY3QgPSB5aWVsZCBqc29uU3RvcmFnZS5nZXRJdGVtKFBFTkRJTkdfQ09OVFJBQ1QpO1xuICAgICAgaWYgKHBlbmRpbmdTZWxlY3RlZFdhbGxldElkICYmIHBlbmRpbmdDb250cmFjdCkge1xuICAgICAgICBjb25zdCBfYWNjb3VudHMgPSB5aWVsZCB0aGlzLnZhbGlkYXRlV2FsbGV0KHBlbmRpbmdTZWxlY3RlZFdhbGxldElkKTtcbiAgICAgICAgeWllbGQganNvblN0b3JhZ2UucmVtb3ZlSXRlbShQRU5ESU5HX1NFTEVDVEVEX1dBTExFVF9JRCk7XG4gICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnJlbW92ZUl0ZW0oUEVORElOR19DT05UUkFDVCk7XG4gICAgICAgIGlmIChfYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogX3NlbGVjdGVkV2FsbGV0SWRcbiAgICAgICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkV2FsbGV0ID0geWllbGQgdGhpcy5nZXRXYWxsZXQoX3NlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICAgIGlmIChzZWxlY3RlZFdhbGxldCAmJiBwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCAhPT0gX3NlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgICAgIHlpZWxkIHNlbGVjdGVkV2FsbGV0LnNpZ25PdXQoKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiRmFpbGVkIHRvIHNpZ24gb3V0IGV4aXN0aW5nIHdhbGxldFwiKTtcbiAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVjZW50bHlTaWduZWRJbldhbGxldHNGcm9tUGVuZGluZyA9IHlpZWxkIHRoaXMuc2V0V2FsbGV0QXNSZWNlbnRseVNpZ25lZEluKHBlbmRpbmdTZWxlY3RlZFdhbGxldElkKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWNjb3VudHM6IF9hY2NvdW50cyxcbiAgICAgICAgICAgIGNvbnRyYWN0OiBwZW5kaW5nQ29udHJhY3QsXG4gICAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBwZW5kaW5nU2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiByZWNlbnRseVNpZ25lZEluV2FsbGV0c0Zyb21QZW5kaW5nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICBjb250cmFjdCxcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgdGhpcy52YWxpZGF0ZVdhbGxldChzZWxlY3RlZFdhbGxldElkKTtcbiAgICAgIGNvbnN0IHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0geWllbGQganNvblN0b3JhZ2UuZ2V0SXRlbShSRUNFTlRMWV9TSUdORURfSU5fV0FMTEVUUyk7XG4gICAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjY291bnRzOiBbXSxcbiAgICAgICAgICBjb250cmFjdDogbnVsbCxcbiAgICAgICAgICBzZWxlY3RlZFdhbGxldElkOiBudWxsLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzOiByZWNlbnRseVNpZ25lZEluV2FsbGV0cyB8fCBbXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGNvbnRyYWN0LFxuICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0czogcmVjZW50bHlTaWduZWRJbldhbGxldHMgfHwgW11cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgc2V0V2FsbGV0QXNSZWNlbnRseVNpZ25lZEluKHdhbGxldElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGpzb25TdG9yYWdlID0gbmV3IEpzb25TdG9yYWdlKHRoaXMuc3RvcmFnZSwgUEFDS0FHRV9OQU1FKTtcbiAgICAgIGxldCByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMpO1xuICAgICAgaWYgKCFyZWNlbnRseVNpZ25lZEluV2FsbGV0cykge1xuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFyZWNlbnRseVNpZ25lZEluV2FsbGV0cy5pbmNsdWRlcyh3YWxsZXRJZCkpIHtcbiAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHMudW5zaGlmdCh3YWxsZXRJZCk7XG4gICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzID0gcmVjZW50bHlTaWduZWRJbldhbGxldHMuc2xpY2UoMCwgNSk7XG4gICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMsIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWNlbnRseVNpZ25lZEluV2FsbGV0cztcbiAgICB9KTtcbiAgfVxuICBzaWduT3V0V2FsbGV0KHdhbGxldElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHRoaXMuZ2V0V2FsbGV0KHdhbGxldElkKTtcbiAgICAgIHlpZWxkIHdhbGxldC5zaWduT3V0KCkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgbG9nZ2VyLmxvZyhgRmFpbGVkIHRvIHNpZ24gb3V0ICR7d2FsbGV0LmlkfWApO1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgLy8gQXQgbGVhc3QgY2xlYW4gdXAgc3RhdGUgb24gb3VyIHNpZGUuXG4gICAgICAgIHRoaXMub25XYWxsZXRTaWduZWRPdXQod2FsbGV0LmlkKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG9uV2FsbGV0U2lnbmVkSW4od2FsbGV0SWQsIHtcbiAgICBhY2NvdW50cyxcbiAgICBjb250cmFjdElkLFxuICAgIG1ldGhvZE5hbWVzXG4gIH0pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZWxlY3RlZFdhbGxldElkXG4gICAgICB9ID0gdGhpcy5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3QganNvblN0b3JhZ2UgPSBuZXcgSnNvblN0b3JhZ2UodGhpcy5zdG9yYWdlLCBQQUNLQUdFX05BTUUpO1xuICAgICAgY29uc3QgY29udHJhY3QgPSB7XG4gICAgICAgIGNvbnRyYWN0SWQsXG4gICAgICAgIG1ldGhvZE5hbWVzXG4gICAgICB9O1xuICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5nZXRNb2R1bGUod2FsbGV0SWQpO1xuICAgICAgICAvLyBXZSBjYW4ndCBndWFyYW50ZWUgdGhlIHVzZXIgd2lsbCBhY3R1YWxseSBzaWduIGluIHdpdGggYnJvd3NlciB3YWxsZXRzLlxuICAgICAgICAvLyBCZXN0IHdlIGNhbiBkbyBpcyBzZXQgaW4gc3RvcmFnZSBhbmQgdmFsaWRhdGUgb24gaW5pdC5cbiAgICAgICAgaWYgKG1vZHVsZS50eXBlID09PSBcImJyb3dzZXJcIikge1xuICAgICAgICAgIHlpZWxkIGpzb25TdG9yYWdlLnNldEl0ZW0oUEVORElOR19TRUxFQ1RFRF9XQUxMRVRfSUQsIHdhbGxldElkKTtcbiAgICAgICAgICB5aWVsZCBqc29uU3RvcmFnZS5zZXRJdGVtKFBFTkRJTkdfQ09OVFJBQ1QsIGNvbnRyYWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWRXYWxsZXRJZCAmJiBzZWxlY3RlZFdhbGxldElkICE9PSB3YWxsZXRJZCkge1xuICAgICAgICB5aWVsZCB0aGlzLnNpZ25PdXRXYWxsZXQoc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWNlbnRseVNpZ25lZEluV2FsbGV0cyA9IHlpZWxkIHRoaXMuc2V0V2FsbGV0QXNSZWNlbnRseVNpZ25lZEluKHdhbGxldElkKTtcbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIldBTExFVF9DT05ORUNURURcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHdhbGxldElkLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJzaWduZWRJblwiLCB7XG4gICAgICAgIHdhbGxldElkLFxuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lcyxcbiAgICAgICAgYWNjb3VudHNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIG9uV2FsbGV0U2lnbmVkT3V0KHdhbGxldElkKSB7XG4gICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBcIldBTExFVF9ESVNDT05ORUNURURcIixcbiAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgd2FsbGV0SWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmVtaXR0ZXIuZW1pdChcInNpZ25lZE91dFwiLCB7XG4gICAgICB3YWxsZXRJZFxuICAgIH0pO1xuICB9XG4gIHNldHVwV2FsbGV0RW1pdHRlcihtb2R1bGUpIHtcbiAgICBjb25zdCBlbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIGVtaXR0ZXIub24oXCJzaWduZWRPdXRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5vbldhbGxldFNpZ25lZE91dChtb2R1bGUuaWQpO1xuICAgIH0pO1xuICAgIGVtaXR0ZXIub24oXCJzaWduZWRJblwiLCBldmVudCA9PiB7XG4gICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkSW4obW9kdWxlLmlkLCBldmVudCk7XG4gICAgfSk7XG4gICAgZW1pdHRlci5vbihcImFjY291bnRzQ2hhbmdlZFwiLCAoe1xuICAgICAgYWNjb3VudHNcbiAgICB9KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmVtaXR0ZXIuZW1pdChcImFjY291bnRzQ2hhbmdlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgIGFjY291bnRzXG4gICAgICB9KTtcbiAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25PdXRXYWxsZXQobW9kdWxlLmlkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgICB0eXBlOiBcIkFDQ09VTlRTX0NIQU5HRURcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgICAgYWNjb3VudHNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSkpO1xuICAgIGVtaXR0ZXIub24oXCJuZXR3b3JrQ2hhbmdlZFwiLCAoe1xuICAgICAgbmV0d29ya0lkXG4gICAgfSkgPT4ge1xuICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoXCJuZXR3b3JrQ2hhbmdlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgIG5ldHdvcmtJZFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZW1pdHRlci5vbihcInVyaUNoYW5nZWRcIiwgKHtcbiAgICAgIHVyaVxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMuZW1pdHRlci5lbWl0KFwidXJpQ2hhbmdlZFwiLCB7XG4gICAgICAgIHdhbGxldElkOiBtb2R1bGUuaWQsXG4gICAgICAgIHVyaVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVtaXR0ZXI7XG4gIH1cbiAgdmFsaWRhdGVTaWduTWVzc2FnZVBhcmFtcyh7XG4gICAgbWVzc2FnZSxcbiAgICBub25jZSxcbiAgICByZWNpcGllbnRcbiAgfSkge1xuICAgIGlmICghbWVzc2FnZSB8fCBtZXNzYWdlLnRyaW0oKSA9PT0gXCJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtZXNzYWdlLiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZy5cIik7XG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG5vbmNlKSB8fCBub25jZS5sZW5ndGggIT09IDMyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vbmNlLiBJdCBtdXN0IGJlIGEgQnVmZmVyIHdpdGggYSBsZW5ndGggb2YgMzIgYnl0ZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoIXJlY2lwaWVudCB8fCByZWNpcGllbnQudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlY2lwaWVudC4gSXQgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuXCIpO1xuICAgIH1cbiAgfVxuICBkZWNvcmF0ZVdhbGxldCh3YWxsZXQpIHtcbiAgICBjb25zdCBfc2lnbkluID0gd2FsbGV0LnNpZ25JbjtcbiAgICBjb25zdCBfc2lnbk91dCA9IHdhbGxldC5zaWduT3V0O1xuICAgIGNvbnN0IF9zaWduTWVzc2FnZSA9IHdhbGxldC5zaWduTWVzc2FnZTtcbiAgICB3YWxsZXQuc2lnbkluID0gcGFyYW1zID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgX3NpZ25JbihwYXJhbXMpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250cmFjdElkLFxuICAgICAgICBtZXRob2ROYW1lcyA9IFtdXG4gICAgICB9ID0gcGFyYW1zO1xuICAgICAgeWllbGQgdGhpcy5vbldhbGxldFNpZ25lZEluKHdhbGxldC5pZCwge1xuICAgICAgICBhY2NvdW50cyxcbiAgICAgICAgY29udHJhY3RJZCxcbiAgICAgICAgbWV0aG9kTmFtZXNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY291bnRzO1xuICAgIH0pO1xuICAgIHdhbGxldC5zaWduT3V0ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3NpZ25PdXQoKTtcbiAgICAgIHRoaXMub25XYWxsZXRTaWduZWRPdXQod2FsbGV0LmlkKTtcbiAgICB9KTtcbiAgICB3YWxsZXQuc2lnbk1lc3NhZ2UgPSBwYXJhbXMgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKF9zaWduTWVzc2FnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBUaGUgc2lnbk1lc3NhZ2UgbWV0aG9kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgJHt3YWxsZXQubWV0YWRhdGEubmFtZX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsaWRhdGVTaWduTWVzc2FnZVBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIHlpZWxkIF9zaWduTWVzc2FnZShwYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiB3YWxsZXQ7XG4gIH1cbiAgc2V0dXBJbnN0YW5jZShtb2R1bGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCFtb2R1bGUubWV0YWRhdGEuYXZhaWxhYmxlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtb2R1bGUudHlwZSA9PT0gXCJpbmplY3RlZFwiID8gXCJub3QgaW5zdGFsbGVkXCIgOiBcIm5vdCBhdmFpbGFibGVcIjtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7bW9kdWxlLm1ldGFkYXRhLm5hbWV9IGlzICR7bWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdhbGxldCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBpZDogbW9kdWxlLmlkLFxuICAgICAgICB0eXBlOiBtb2R1bGUudHlwZSxcbiAgICAgICAgbWV0YWRhdGE6IG1vZHVsZS5tZXRhZGF0YVxuICAgICAgfSwgeWllbGQgbW9kdWxlLmluaXQoe1xuICAgICAgICBpZDogbW9kdWxlLmlkLFxuICAgICAgICB0eXBlOiBtb2R1bGUudHlwZSxcbiAgICAgICAgbWV0YWRhdGE6IG1vZHVsZS5tZXRhZGF0YSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICBzdG9yZTogdGhpcy5zdG9yZS50b1JlYWRPbmx5KCksXG4gICAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgICBlbWl0dGVyOiB0aGlzLnNldHVwV2FsbGV0RW1pdHRlcihtb2R1bGUpLFxuICAgICAgICBsb2dnZXI6IG5ldyBMb2dnZXIobW9kdWxlLmlkKSxcbiAgICAgICAgc3RvcmFnZTogbmV3IEpzb25TdG9yYWdlKHRoaXMuc3RvcmFnZSwgW1BBQ0tBR0VfTkFNRSwgbW9kdWxlLmlkXSlcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0aGlzLmRlY29yYXRlV2FsbGV0KHdhbGxldCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0TW9kdWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlcy5maW5kKHggPT4geC5pZCA9PT0gaWQpO1xuICB9XG4gIGdldFdhbGxldChpZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLmdldE1vZHVsZShpZCk7XG4gICAgICBpZiAoIW1vZHVsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZFxuICAgICAgfSA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHVzZXIgdW5pbnN0YWxsZWQvcmVtb3ZlZCBhIHdhbGxldCB3aGljaCB3YXMgcHJldmlvdXNseSBzaWduZWQgaW4gd2l0aFxuICAgICAgLy8gYmVzdCB3ZSBjYW4gZG8gaXMgY2xlYW4gdXAgc3RhdGUgb24gb3VyIHNpZGUuXG4gICAgICBpZiAoIW1vZHVsZS5tZXRhZGF0YS5hdmFpbGFibGUgJiYgc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICB0aGlzLm9uV2FsbGV0U2lnbmVkT3V0KHNlbGVjdGVkV2FsbGV0SWQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5aWVsZCBtb2R1bGUud2FsbGV0KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXAoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1vZHVsZXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5mYWN0b3JpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0geWllbGQgdGhpcy5mYWN0b3JpZXNbaV0oe1xuICAgICAgICAgIG9wdGlvbnM6IHRoaXMub3B0aW9uc1xuICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgIGxvZ2dlci5sb2coXCJGYWlsZWQgdG8gc2V0dXAgbW9kdWxlXCIpO1xuICAgICAgICAgIGxvZ2dlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCB3YWxsZXRzIHRoYXQgYXJlbid0IGF2YWlsYWJsZS5cbiAgICAgICAgaWYgKCFtb2R1bGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTa2lwIGR1cGxpY2F0ZWQgbW9kdWxlLlxuICAgICAgICBpZiAobW9kdWxlcy5zb21lKHggPT4geC5pZCA9PT0gbW9kdWxlLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1vZHVsZXMucHVzaCh7XG4gICAgICAgICAgaWQ6IG1vZHVsZS5pZCxcbiAgICAgICAgICB0eXBlOiBtb2R1bGUudHlwZSxcbiAgICAgICAgICBtZXRhZGF0YTogbW9kdWxlLm1ldGFkYXRhLFxuICAgICAgICAgIHdhbGxldDogKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5pbnN0YW5jZXNbbW9kdWxlLmlkXTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZSA9IHlpZWxkIHRoaXMuc2V0dXBJbnN0YW5jZShtb2R1bGUpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZXNbbW9kdWxlLmlkXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2R1bGVzID0gbW9kdWxlcztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGNvbnRyYWN0LFxuICAgICAgICBzZWxlY3RlZFdhbGxldElkLFxuICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgfSA9IHlpZWxkIHRoaXMucmVzb2x2ZVN0b3JhZ2VTdGF0ZSgpO1xuICAgICAgdGhpcy5zdG9yZS5kaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiU0VUVVBfV0FMTEVUX01PRFVMRVNcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZHVsZXNbaV0udHlwZSAhPT0gXCJpbnN0YW50LWxpbmtcIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IHlpZWxkIHRoaXMubW9kdWxlc1tpXS53YWxsZXQoKTtcbiAgICAgICAgaWYgKCF3YWxsZXQubWV0YWRhdGEucnVuT25TdGFydHVwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCB3YWxsZXQuc2lnbkluKHtcbiAgICAgICAgICAgIGNvbnRyYWN0SWQ6IHdhbGxldC5nZXRDb250cmFjdElkKClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRmFpbGVkIHRvIHNpZ24gaW4gdG8gd2FsbGV0LiBcIiArIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5jb25zdCBnZXROZXR3b3JrUHJlc2V0ID0gbmV0d29ya0lkID0+IHtcbiAgc3dpdGNoIChuZXR3b3JrSWQpIHtcbiAgICBjYXNlIFwibWFpbm5ldFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmV0d29ya0lkLFxuICAgICAgICBub2RlVXJsOiBcImh0dHBzOi8vcnBjLm1haW5uZXQubmVhci5vcmdcIixcbiAgICAgICAgaGVscGVyVXJsOiBcImh0dHBzOi8vaGVscGVyLm1haW5uZXQubmVhci5vcmdcIixcbiAgICAgICAgZXhwbG9yZXJVcmw6IFwiaHR0cHM6Ly9uZWFyYmxvY2tzLmlvXCIsXG4gICAgICAgIGluZGV4ZXJVcmw6IFwiaHR0cHM6Ly9hcGkua2l0d2FsbGV0LmFwcFwiXG4gICAgICB9O1xuICAgIGNhc2UgXCJ0ZXN0bmV0XCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXR3b3JrSWQsXG4gICAgICAgIG5vZGVVcmw6IFwiaHR0cHM6Ly9ycGMudGVzdG5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBoZWxwZXJVcmw6IFwiaHR0cHM6Ly9oZWxwZXIudGVzdG5ldC5uZWFyLm9yZ1wiLFxuICAgICAgICBleHBsb3JlclVybDogXCJodHRwczovL3Rlc3RuZXQubmVhcmJsb2Nrcy5pb1wiLFxuICAgICAgICBpbmRleGVyVXJsOiBcImh0dHBzOi8vdGVzdG5ldC1hcGkua2l0d2FsbGV0LmFwcFwiXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgY29uZmlnIGZvcjogJyR7bmV0d29ya0lkfSdgKTtcbiAgfVxufTtcbmNvbnN0IHJlc29sdmVOZXR3b3JrID0gbmV0d29yayA9PiB7XG4gIHJldHVybiB0eXBlb2YgbmV0d29yayA9PT0gXCJzdHJpbmdcIiA/IGdldE5ldHdvcmtQcmVzZXQobmV0d29yaykgOiBuZXR3b3JrO1xufTtcbmNvbnN0IHJlc29sdmVPcHRpb25zID0gcGFyYW1zID0+IHtcbiAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICBsYW5ndWFnZUNvZGU6IHBhcmFtcy5sYW5ndWFnZUNvZGUgfHwgdW5kZWZpbmVkLFxuICAgIG5ldHdvcms6IHJlc29sdmVOZXR3b3JrKHBhcmFtcy5uZXR3b3JrKSxcbiAgICBkZWJ1ZzogcGFyYW1zLmRlYnVnIHx8IGZhbHNlLFxuICAgIG9wdGltaXplV2FsbGV0T3JkZXI6IHBhcmFtcy5vcHRpbWl6ZVdhbGxldE9yZGVyID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSxcbiAgICByYW5kb21pemVXYWxsZXRPcmRlcjogcGFyYW1zLnJhbmRvbWl6ZVdhbGxldE9yZGVyIHx8IGZhbHNlLFxuICAgIHJlbGF5ZXJVcmw6IHBhcmFtcy5yZWxheWVyVXJsIHx8IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4ge1xuICAgIG9wdGlvbnMsXG4gICAgc3RvcmFnZTogcGFyYW1zLnN0b3JhZ2UgfHwgbmV3IFdlYlN0b3JhZ2VTZXJ2aWNlKClcbiAgfTtcbn07XG5cbmNvbnN0IHJlZHVjZXIgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBsb2dnZXIubG9nKFwiU3RvcmUgQWN0aW9uXCIsIGFjdGlvbik7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFwiU0VUVVBfV0FMTEVUX01PRFVMRVNcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgY29udHJhY3QsXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZCxcbiAgICAgICAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0c1xuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGNvbnN0IGFjY291bnRTdGF0ZXMgPSBhY2NvdW50cy5tYXAoKGFjY291bnQsIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2NvdW50KSwge1xuICAgICAgICAgICAgYWN0aXZlOiBpID09PSAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQsXG4gICAgICAgICAgcmVjZW50bHlTaWduZWRJbldhbGxldHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgY2FzZSBcIldBTExFVF9DT05ORUNURURcIjpcbiAgICAgIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdhbGxldElkLFxuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIGFjY291bnRzLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcbiAgICAgICAgaWYgKCFhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aXZlQWNjb3VudEluZGV4ID0gc3RhdGUuYWNjb3VudHMuZmluZEluZGV4KGFjY291bnQgPT4gYWNjb3VudC5hY3RpdmUpO1xuICAgICAgICBjb25zdCBhY2NvdW50U3RhdGVzID0gYWNjb3VudHMubWFwKChhY2NvdW50LCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogaSA9PT0gKGFjdGl2ZUFjY291bnRJbmRleCA+IC0xID8gYWN0aXZlQWNjb3VudEluZGV4IDogMClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGNvbnRyYWN0LFxuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzLFxuICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SWQ6IHdhbGxldElkLFxuICAgICAgICAgIHJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGNhc2UgXCJXQUxMRVRfRElTQ09OTkVDVEVEXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3YWxsZXRJZFxuICAgICAgICB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICAgIGlmICh3YWxsZXRJZCAhPT0gc3RhdGUuc2VsZWN0ZWRXYWxsZXRJZCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBjb250cmFjdDogbnVsbCxcbiAgICAgICAgICBhY2NvdW50czogW10sXG4gICAgICAgICAgc2VsZWN0ZWRXYWxsZXRJZDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlIFwiQUNDT1VOVFNfQ0hBTkdFRFwiOlxuICAgICAge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgd2FsbGV0SWQsXG4gICAgICAgICAgYWNjb3VudHNcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBpZiAod2FsbGV0SWQgIT09IHN0YXRlLnNlbGVjdGVkV2FsbGV0SWQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0aXZlQWNjb3VudCA9IHN0YXRlLmFjY291bnRzLmZpbmQoYWNjb3VudCA9PiBhY2NvdW50LmFjdGl2ZSk7XG4gICAgICAgIGNvbnN0IGlzQWN0aXZlQWNjb3VudFJlbW92ZWQgPSAhYWNjb3VudHMuc29tZShhY2NvdW50ID0+IGFjY291bnQuYWNjb3VudElkID09PSAoYWN0aXZlQWNjb3VudCA9PT0gbnVsbCB8fCBhY3RpdmVBY2NvdW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVBY2NvdW50LmFjY291bnRJZCkpO1xuICAgICAgICBjb25zdCBhY2NvdW50U3RhdGVzID0gYWNjb3VudHMubWFwKChhY2NvdW50LCBpKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjb3VudCksIHtcbiAgICAgICAgICAgIGFjdGl2ZTogaXNBY3RpdmVBY2NvdW50UmVtb3ZlZCA/IGkgPT09IDAgOiBhY2NvdW50LmFjY291bnRJZCA9PT0gKGFjdGl2ZUFjY291bnQgPT09IG51bGwgfHwgYWN0aXZlQWNjb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlQWNjb3VudC5hY2NvdW50SWQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHtcbiAgICAgICAgICBhY2NvdW50czogYWNjb3VudFN0YXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBjYXNlIFwiU0VUX0FDVElWRV9BQ0NPVU5UXCI6XG4gICAgICB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhY2NvdW50SWRcbiAgICAgICAgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBhY2NvdW50U3RhdGVzID0gc3RhdGUuYWNjb3VudHMubWFwKGFjY291bnQgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7XG4gICAgICAgICAgICBhY3RpdmU6IGFjY291bnQuYWNjb3VudElkID09PSBhY2NvdW50SWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlKSwge1xuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50U3RhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5jb25zdCBjcmVhdGVTdG9yZSA9IHN0b3JhZ2UgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IGpzb25TdG9yYWdlID0gbmV3IEpzb25TdG9yYWdlKHN0b3JhZ2UsIFBBQ0tBR0VfTkFNRSk7XG4gIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgICBtb2R1bGVzOiBbXSxcbiAgICBhY2NvdW50czogW10sXG4gICAgY29udHJhY3Q6IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oQ09OVFJBQ1QpLFxuICAgIHNlbGVjdGVkV2FsbGV0SWQ6IHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oU0VMRUNURURfV0FMTEVUX0lEKSxcbiAgICByZWNlbnRseVNpZ25lZEluV2FsbGV0czogKHlpZWxkIGpzb25TdG9yYWdlLmdldEl0ZW0oUkVDRU5UTFlfU0lHTkVEX0lOX1dBTExFVFMpKSB8fCBbXVxuICB9O1xuICBjb25zdCBzdGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0IGFjdGlvbnMkID0gbmV3IFN1YmplY3QoKTtcbiAgYWN0aW9ucyQucGlwZShzY2FuKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSkpLnN1YnNjcmliZShzdGF0ZSQpO1xuICBjb25zdCBzeW5jU3RvcmFnZSA9IChwcmV2U3RhdGUsIHN0YXRlLCBzdG9yYWdlS2V5LCBwcm9wZXJ0eSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKHN0YXRlW3Byb3BlcnR5XSA9PT0gcHJldlN0YXRlW3Byb3BlcnR5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RhdGVbcHJvcGVydHldKSB7XG4gICAgICB5aWVsZCBqc29uU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXksIHN0YXRlW3Byb3BlcnR5XSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHlpZWxkIGpzb25TdG9yYWdlLnJlbW92ZUl0ZW0oc3RvcmFnZUtleSk7XG4gIH0pO1xuICBsZXQgcHJldlN0YXRlID0gc3RhdGUkLmdldFZhbHVlKCk7XG4gIHN0YXRlJC5zdWJzY3JpYmUoc3RhdGUgPT4ge1xuICAgIHN5bmNTdG9yYWdlKHByZXZTdGF0ZSwgc3RhdGUsIFNFTEVDVEVEX1dBTExFVF9JRCwgXCJzZWxlY3RlZFdhbGxldElkXCIpO1xuICAgIHN5bmNTdG9yYWdlKHByZXZTdGF0ZSwgc3RhdGUsIENPTlRSQUNULCBcImNvbnRyYWN0XCIpO1xuICAgIHN5bmNTdG9yYWdlKHByZXZTdGF0ZSwgc3RhdGUsIFJFQ0VOVExZX1NJR05FRF9JTl9XQUxMRVRTLCBcInJlY2VudGx5U2lnbmVkSW5XYWxsZXRzXCIpO1xuICAgIHByZXZTdGF0ZSA9IHN0YXRlO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBvYnNlcnZhYmxlOiBzdGF0ZSQsXG4gICAgZ2V0U3RhdGU6ICgpID0+IHN0YXRlJC5nZXRWYWx1ZSgpLFxuICAgIGRpc3BhdGNoOiBhY3Rpb24gPT4gYWN0aW9ucyQubmV4dChhY3Rpb24pLFxuICAgIHRvUmVhZE9ubHk6ICgpID0+ICh7XG4gICAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUkLmdldFZhbHVlKCksXG4gICAgICBvYnNlcnZhYmxlOiBzdGF0ZSQuYXNPYnNlcnZhYmxlKClcbiAgICB9KVxuICB9O1xufSk7XG5cbmxldCB3YWxsZXRTZWxlY3Rvckluc3RhbmNlID0gbnVsbDtcbmNvbnN0IGNyZWF0ZVNlbGVjdG9yID0gKG9wdGlvbnMsIHN0b3JlLCB3YWxsZXRNb2R1bGVzLCBlbWl0dGVyKSA9PiB7XG4gIHJldHVybiB7XG4gICAgb3B0aW9ucyxcbiAgICBzdG9yZTogc3RvcmUudG9SZWFkT25seSgpLFxuICAgIHdhbGxldDogaWQgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNlbGVjdGVkV2FsbGV0SWRcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgY29uc3Qgd2FsbGV0ID0geWllbGQgd2FsbGV0TW9kdWxlcy5nZXRXYWxsZXQoaWQgfHwgc2VsZWN0ZWRXYWxsZXRJZCk7XG4gICAgICBpZiAoIXdhbGxldCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdhbGxldCBpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyB3YWxsZXQgc2VsZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH0pLFxuICAgIHNldEFjdGl2ZUFjY291bnQ6IGFjY291bnRJZCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIGlmICghYWNjb3VudHMuc29tZShhY2NvdW50ID0+IGFjY291bnQuYWNjb3VudElkID09PSBhY2NvdW50SWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYWNjb3VudCBpZFwiKTtcbiAgICAgIH1cbiAgICAgIHN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJTRVRfQUNUSVZFX0FDQ09VTlRcIixcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGFjY291bnRJZFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGlzU2lnbmVkSW4oKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIHJldHVybiBCb29sZWFuKGFjY291bnRzLmxlbmd0aCk7XG4gICAgfSxcbiAgICBvbjogKGV2ZW50TmFtZSwgY2FsbGJhY2spID0+IHtcbiAgICAgIHJldHVybiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgb2ZmOiAoZXZlbnROYW1lLCBjYWxsYmFjaykgPT4ge1xuICAgICAgZW1pdHRlci5vZmYoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9O1xufTtcbi8qKlxyXG4gKiBJbml0aWF0ZXMgYSB3YWxsZXQgc2VsZWN0b3IgaW5zdGFuY2VcclxuICogQHBhcmFtIHtXYWxsZXRTZWxlY3RvclBhcmFtc30gcGFyYW1zIFNlbGVjdG9yIHBhcmFtZXRlcnMgKG5ldHdvcmssIG1vZHVsZXMuLi4pXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPFdhbGxldFNlbGVjdG9yPn0gUmV0dXJucyBhIFdhbGxldFNlbGVjdG9yIG9iamVjdFxyXG4gKi9cbmNvbnN0IHNldHVwV2FsbGV0U2VsZWN0b3IgPSBwYXJhbXMgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gIGNvbnN0IHtcbiAgICBvcHRpb25zLFxuICAgIHN0b3JhZ2VcbiAgfSA9IHJlc29sdmVPcHRpb25zKHBhcmFtcyk7XG4gIExvZ2dlci5kZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIGNvbnN0IHN0b3JlID0geWllbGQgY3JlYXRlU3RvcmUoc3RvcmFnZSk7XG4gIGNvbnN0IHdhbGxldE1vZHVsZXMgPSBuZXcgV2FsbGV0TW9kdWxlcyh7XG4gICAgZmFjdG9yaWVzOiBwYXJhbXMubW9kdWxlcyxcbiAgICBzdG9yYWdlLFxuICAgIG9wdGlvbnMsXG4gICAgc3RvcmUsXG4gICAgZW1pdHRlcixcbiAgICBwcm92aWRlcjogbmV3IFByb3ZpZGVyKG9wdGlvbnMubmV0d29yay5ub2RlVXJsKVxuICB9KTtcbiAgeWllbGQgd2FsbGV0TW9kdWxlcy5zZXR1cCgpO1xuICBpZiAocGFyYW1zLmFsbG93TXVsdGlwbGVTZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gY3JlYXRlU2VsZWN0b3Iob3B0aW9ucywgc3RvcmUsIHdhbGxldE1vZHVsZXMsIGVtaXR0ZXIpO1xuICB9XG4gIGlmICghd2FsbGV0U2VsZWN0b3JJbnN0YW5jZSkge1xuICAgIHdhbGxldFNlbGVjdG9ySW5zdGFuY2UgPSBjcmVhdGVTZWxlY3RvcihvcHRpb25zLCBzdG9yZSwgd2FsbGV0TW9kdWxlcywgZW1pdHRlcik7XG4gIH1cbiAgcmV0dXJuIHdhbGxldFNlbGVjdG9ySW5zdGFuY2U7XG59KTtcblxuY29uc3Qgd2FpdCA9IG1zID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufTtcbmNvbnN0IHBvbGwgPSAoY2IsIGludGVydmFsLCByZW1haW5pbmcpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCByZXN1bHQgPSBjYigpO1xuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIXJlbWFpbmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4Y2VlZGVkIHRpbWVvdXRcIik7XG4gIH1cbiAgcmV0dXJuIHdhaXQoaW50ZXJ2YWwpLnRoZW4oKCkgPT4gcG9sbChjYiwgaW50ZXJ2YWwsIHJlbWFpbmluZyAtIDEpKTtcbn0pO1xuY29uc3Qgd2FpdEZvciA9IChjYiwgb3B0cyA9IHt9KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgY29uc3Qge1xuICAgIHRpbWVvdXQgPSAxMDAsXG4gICAgaW50ZXJ2YWwgPSA1MFxuICB9ID0gb3B0cztcbiAgcmV0dXJuIFByb21pc2UucmFjZShbd2FpdCh0aW1lb3V0KS50aGVuKCgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeGNlZWRlZCB0aW1lb3V0XCIpO1xuICB9KSwgcG9sbChjYiwgaW50ZXJ2YWwsIE1hdGguZmxvb3IodGltZW91dCAvIGludGVydmFsKSldKTtcbn0pO1xuXG5jb25zdCBnZXRBY3RpdmVBY2NvdW50ID0gc3RhdGUgPT4ge1xuICByZXR1cm4gc3RhdGUuYWNjb3VudHMuZmluZChhY2NvdW50ID0+IGFjY291bnQuYWN0aXZlKSB8fCBudWxsO1xufTtcblxudmFyIGFDYWxsYWJsZSQxID0gYUNhbGxhYmxlJDk7XG52YXIgdG9PYmplY3QkMyA9IHRvT2JqZWN0JDc7XG52YXIgSW5kZXhlZE9iamVjdCQxID0gaW5kZXhlZE9iamVjdDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ1ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcblxudmFyICRUeXBlRXJyb3IkMiA9IFR5cGVFcnJvcjtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQyID0gZnVuY3Rpb24gKElTX1JJR0hUKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgY2FsbGJhY2tmbiwgYXJndW1lbnRzTGVuZ3RoLCBtZW1vKSB7XG4gICAgYUNhbGxhYmxlJDEoY2FsbGJhY2tmbik7XG4gICAgdmFyIE8gPSB0b09iamVjdCQzKHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdCQxKE8pO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ1KE8pO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93ICRUeXBlRXJyb3IkMignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxudmFyIGFycmF5UmVkdWNlID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuICBsZWZ0OiBjcmVhdGVNZXRob2QkMihmYWxzZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlUmlnaHRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuICByaWdodDogY3JlYXRlTWV0aG9kJDIodHJ1ZSlcbn07XG5cbnZhciBmYWlscyRjID0gZmFpbHMkcztcblxudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMSA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzJGMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9LCAxKTtcbiAgfSk7XG59O1xuXG52YXIgJCQzID0gX2V4cG9ydDtcbnZhciAkcmVkdWNlID0gYXJyYXlSZWR1Y2UubGVmdDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gYXJyYXlNZXRob2RJc1N0cmljdCQxO1xudmFyIENIUk9NRV9WRVJTSU9OID0gZW5naW5lVjhWZXJzaW9uO1xudmFyIElTX05PREUgPSBlbmdpbmVJc05vZGU7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgncmVkdWNlJyk7XG4vLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ5OTgyXG52YXIgQ0hST01FX0JVRyA9ICFJU19OT0RFICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MztcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmVkdWNlXG4kJDMoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFTVFJJQ1RfTUVUSE9EIHx8IENIUk9NRV9CVUcgfSwge1xuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgbGVuZ3RoLCBsZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBhbk9iamVjdCQzID0gYW5PYmplY3QkZTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXQtcmVnZXhwLnByb3RvdHlwZS5mbGFnc1xudmFyIHJlZ2V4cEZsYWdzJDEgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGF0ID0gYW5PYmplY3QkMyh0aGlzKTtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBpZiAodGhhdC5oYXNJbmRpY2VzKSByZXN1bHQgKz0gJ2QnO1xuICBpZiAodGhhdC5nbG9iYWwpIHJlc3VsdCArPSAnZyc7XG4gIGlmICh0aGF0Lmlnbm9yZUNhc2UpIHJlc3VsdCArPSAnaSc7XG4gIGlmICh0aGF0Lm11bHRpbGluZSkgcmVzdWx0ICs9ICdtJztcbiAgaWYgKHRoYXQuZG90QWxsKSByZXN1bHQgKz0gJ3MnO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC51bmljb2RlU2V0cykgcmVzdWx0ICs9ICd2JztcbiAgaWYgKHRoYXQuc3RpY2t5KSByZXN1bHQgKz0gJ3knO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGZhaWxzJGIgPSBmYWlscyRzO1xudmFyIGdsb2JhbCRhID0gZ2xvYmFsJHQ7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnYScsICd5JykgLT4gL2EveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCQyID0gZ2xvYmFsJGEuUmVnRXhwO1xuXG52YXIgVU5TVVBQT1JURURfWSQyID0gZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAkMignYScsICd5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdhYmNkJykgIT0gbnVsbDtcbn0pO1xuXG4vLyBVQyBCcm93c2VyIGJ1Z1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzEwMDhcbnZhciBNSVNTRURfU1RJQ0tZID0gVU5TVVBQT1JURURfWSQyIHx8IGZhaWxzJGIoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISRSZWdFeHAkMignYScsICd5Jykuc3RpY2t5O1xufSk7XG5cbnZhciBCUk9LRU5fQ0FSRVQgPSBVTlNVUFBPUlRFRF9ZJDIgfHwgZmFpbHMkYihmdW5jdGlvbiAoKSB7XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTc3MzY4N1xuICB2YXIgcmUgPSAkUmVnRXhwJDIoJ15yJywgJ2d5Jyk7XG4gIHJlLmxhc3RJbmRleCA9IDI7XG4gIHJldHVybiByZS5leGVjKCdzdHInKSAhPSBudWxsO1xufSk7XG5cbnZhciByZWdleHBTdGlja3lIZWxwZXJzID0ge1xuICBCUk9LRU5fQ0FSRVQ6IEJST0tFTl9DQVJFVCxcbiAgTUlTU0VEX1NUSUNLWTogTUlTU0VEX1NUSUNLWSxcbiAgVU5TVVBQT1JURURfWTogVU5TVVBQT1JURURfWSQyXG59O1xuXG52YXIgZmFpbHMkYSA9IGZhaWxzJHM7XG52YXIgZ2xvYmFsJDkgPSBnbG9iYWwkdDtcblxuLy8gYmFiZWwtbWluaWZ5IGFuZCBDbG9zdXJlIENvbXBpbGVyIHRyYW5zcGlsZXMgUmVnRXhwKCcuJywgJ3MnKSAtPiAvLi9zIGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciAkUmVnRXhwJDEgPSBnbG9iYWwkOS5SZWdFeHA7XG5cbnZhciByZWdleHBVbnN1cHBvcnRlZERvdEFsbCA9IGZhaWxzJGEoZnVuY3Rpb24gKCkge1xuICB2YXIgcmUgPSAkUmVnRXhwJDEoJy4nLCAncycpO1xuICByZXR1cm4gIShyZS5kb3RBbGwgJiYgcmUuZXhlYygnXFxuJykgJiYgcmUuZmxhZ3MgPT09ICdzJyk7XG59KTtcblxudmFyIGZhaWxzJDkgPSBmYWlscyRzO1xudmFyIGdsb2JhbCQ4ID0gZ2xvYmFsJHQ7XG5cbi8vIGJhYmVsLW1pbmlmeSBhbmQgQ2xvc3VyZSBDb21waWxlciB0cmFuc3BpbGVzIFJlZ0V4cCgnKD88YT5iKScsICdnJykgLT4gLyg/PGE+YikvZyBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgJFJlZ0V4cCA9IGdsb2JhbCQ4LlJlZ0V4cDtcblxudmFyIHJlZ2V4cFVuc3VwcG9ydGVkTmNnID0gZmFpbHMkOShmdW5jdGlvbiAoKSB7XG4gIHZhciByZSA9ICRSZWdFeHAoJyg/PGE+YiknLCAnZycpO1xuICByZXR1cm4gcmUuZXhlYygnYicpLmdyb3Vwcy5hICE9PSAnYicgfHxcbiAgICAnYicucmVwbGFjZShyZSwgJyQ8YT5jJykgIT09ICdiYyc7XG59KTtcblxuLyogZXNsaW50LWRpc2FibGUgcmVnZXhwL25vLWVtcHR5LWNhcHR1cmluZy1ncm91cCwgcmVnZXhwL25vLWVtcHR5LWdyb3VwLCByZWdleHAvbm8tbGF6eS1lbmRzIC0tIHRlc3RpbmcgKi9cbi8qIGVzbGludC1kaXNhYmxlIHJlZ2V4cC9uby11c2VsZXNzLXF1YW50aWZpZXIgLS0gdGVzdGluZyAqL1xudmFyIGNhbGwkNiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciB1bmN1cnJ5VGhpcyQ4ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyQyID0gdG9TdHJpbmckNTtcbnZhciByZWdleHBGbGFncyA9IHJlZ2V4cEZsYWdzJDE7XG52YXIgc3RpY2t5SGVscGVycyQxID0gcmVnZXhwU3RpY2t5SGVscGVycztcbnZhciBzaGFyZWQgPSBzaGFyZWQkNC5leHBvcnRzO1xudmFyIGNyZWF0ZSQxID0gb2JqZWN0Q3JlYXRlO1xudmFyIGdldEludGVybmFsU3RhdGUkMyA9IGludGVybmFsU3RhdGUuZ2V0O1xudmFyIFVOU1VQUE9SVEVEX0RPVF9BTEwgPSByZWdleHBVbnN1cHBvcnRlZERvdEFsbDtcbnZhciBVTlNVUFBPUlRFRF9OQ0cgPSByZWdleHBVbnN1cHBvcnRlZE5jZztcblxudmFyIG5hdGl2ZVJlcGxhY2UgPSBzaGFyZWQoJ25hdGl2ZS1zdHJpbmctcmVwbGFjZScsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSk7XG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbnZhciBwYXRjaGVkRXhlYyA9IG5hdGl2ZUV4ZWM7XG52YXIgY2hhckF0JDIgPSB1bmN1cnJ5VGhpcyQ4KCcnLmNoYXJBdCk7XG52YXIgaW5kZXhPZiA9IHVuY3VycnlUaGlzJDgoJycuaW5kZXhPZik7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzJDgoJycucmVwbGFjZSk7XG52YXIgc3RyaW5nU2xpY2UkMiA9IHVuY3VycnlUaGlzJDgoJycuc2xpY2UpO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlMSA9IC9hLztcbiAgdmFyIHJlMiA9IC9iKi9nO1xuICBjYWxsJDYobmF0aXZlRXhlYywgcmUxLCAnYScpO1xuICBjYWxsJDYobmF0aXZlRXhlYywgcmUyLCAnYScpO1xuICByZXR1cm4gcmUxLmxhc3RJbmRleCAhPT0gMCB8fCByZTIubGFzdEluZGV4ICE9PSAwO1xufSkoKTtcblxudmFyIFVOU1VQUE9SVEVEX1kkMSA9IHN0aWNreUhlbHBlcnMkMS5CUk9LRU5fQ0FSRVQ7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEIHx8IFVOU1VQUE9SVEVEX1kkMSB8fCBVTlNVUFBPUlRFRF9ET1RfQUxMIHx8IFVOU1VQUE9SVEVEX05DRztcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHJpbmcpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMyhyZSk7XG4gICAgdmFyIHN0ciA9IHRvU3RyaW5nJDIoc3RyaW5nKTtcbiAgICB2YXIgcmF3ID0gc3RhdGUucmF3O1xuICAgIHZhciByZXN1bHQsIHJlQ29weSwgbGFzdEluZGV4LCBtYXRjaCwgaSwgb2JqZWN0LCBncm91cDtcblxuICAgIGlmIChyYXcpIHtcbiAgICAgIHJhdy5sYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG4gICAgICByZXN1bHQgPSBjYWxsJDYocGF0Y2hlZEV4ZWMsIHJhdywgc3RyKTtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJhdy5sYXN0SW5kZXg7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBzdGF0ZS5ncm91cHM7XG4gICAgdmFyIHN0aWNreSA9IFVOU1VQUE9SVEVEX1kkMSAmJiByZS5zdGlja3k7XG4gICAgdmFyIGZsYWdzID0gY2FsbCQ2KHJlZ2V4cEZsYWdzLCByZSk7XG4gICAgdmFyIHNvdXJjZSA9IHJlLnNvdXJjZTtcbiAgICB2YXIgY2hhcnNBZGRlZCA9IDA7XG4gICAgdmFyIHN0ckNvcHkgPSBzdHI7XG5cbiAgICBpZiAoc3RpY2t5KSB7XG4gICAgICBmbGFncyA9IHJlcGxhY2UoZmxhZ3MsICd5JywgJycpO1xuICAgICAgaWYgKGluZGV4T2YoZmxhZ3MsICdnJykgPT09IC0xKSB7XG4gICAgICAgIGZsYWdzICs9ICdnJztcbiAgICAgIH1cblxuICAgICAgc3RyQ29weSA9IHN0cmluZ1NsaWNlJDIoc3RyLCByZS5sYXN0SW5kZXgpO1xuICAgICAgLy8gU3VwcG9ydCBhbmNob3JlZCBzdGlja3kgYmVoYXZpb3IuXG4gICAgICBpZiAocmUubGFzdEluZGV4ID4gMCAmJiAoIXJlLm11bHRpbGluZSB8fCByZS5tdWx0aWxpbmUgJiYgY2hhckF0JDIoc3RyLCByZS5sYXN0SW5kZXggLSAxKSAhPT0gJ1xcbicpKSB7XG4gICAgICAgIHNvdXJjZSA9ICcoPzogJyArIHNvdXJjZSArICcpJztcbiAgICAgICAgc3RyQ29weSA9ICcgJyArIHN0ckNvcHk7XG4gICAgICAgIGNoYXJzQWRkZWQrKztcbiAgICAgIH1cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBzdHIgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14oPzonICsgc291cmNlICsgJyknLCBmbGFncyk7XG4gICAgfVxuXG4gICAgaWYgKE5QQ0dfSU5DTFVERUQpIHtcbiAgICAgIHJlQ29weSA9IG5ldyBSZWdFeHAoJ14nICsgc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgfVxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcpIGxhc3RJbmRleCA9IHJlLmxhc3RJbmRleDtcblxuICAgIG1hdGNoID0gY2FsbCQ2KG5hdGl2ZUV4ZWMsIHN0aWNreSA/IHJlQ29weSA6IHJlLCBzdHJDb3B5KTtcblxuICAgIGlmIChzdGlja3kpIHtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBtYXRjaC5pbnB1dCA9IHN0cmluZ1NsaWNlJDIobWF0Y2guaW5wdXQsIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaFswXSA9IHN0cmluZ1NsaWNlJDIobWF0Y2hbMF0sIGNoYXJzQWRkZWQpO1xuICAgICAgICBtYXRjaC5pbmRleCA9IHJlLmxhc3RJbmRleDtcbiAgICAgICAgcmUubGFzdEluZGV4ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgIH0gZWxzZSByZS5sYXN0SW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HICYmIG1hdGNoKSB7XG4gICAgICByZS5sYXN0SW5kZXggPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgY2FsbCQ2KG5hdGl2ZVJlcGxhY2UsIG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggJiYgZ3JvdXBzKSB7XG4gICAgICBtYXRjaC5ncm91cHMgPSBvYmplY3QgPSBjcmVhdGUkMShudWxsKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgIG9iamVjdFtncm91cFswXV0gPSBtYXRjaFtncm91cFsxXV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG52YXIgcmVnZXhwRXhlYyQzID0gcGF0Y2hlZEV4ZWM7XG5cbnZhciAkJDIgPSBfZXhwb3J0O1xudmFyIGV4ZWMkMSA9IHJlZ2V4cEV4ZWMkMztcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZXhlY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUuZXhlY1xuJCQyKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMkMSB9LCB7XG4gIGV4ZWM6IGV4ZWMkMVxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtZXNjYXBlICovXG4vLyBodHRwczovL2dpdGh1Yi5jb20vRGFtb25PZWhsbWFuL2RldGVjdC1icm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC50c1xuY29uc3QgU0VBUkNIQk9YX1VBX1JFR0VYID0gL2FsZXhhfGJvdHxjcmF3bChlcnxpbmcpfGZhY2Vib29rZXh0ZXJuYWxoaXR8ZmVlZGJ1cm5lcnxnb29nbGUgd2ViIHByZXZpZXd8bmFnaW9zfHBvc3RyYW5rfHBpbmdkb218c2x1cnB8c3BpZGVyfHlhaG9vIXx5YW5kZXgvO1xuY29uc3QgdXNlckFnZW50UnVsZXMgPSBbW1wiYW9sXCIsIC9BT0xTaGllbGRcXC8oWzAtOVxcLl9dKykvXSwgW1wiZWRnZVwiLCAvRWRnZVxcLyhbMC05XFwuX10rKS9dLCBbXCJlZGdlLWlvc1wiLCAvRWRnaU9TXFwvKFswLTlcXC5fXSspL10sIFtcInlhbmRleGJyb3dzZXJcIiwgL1lhQnJvd3NlclxcLyhbMC05XFwuX10rKS9dLCBbXCJrYWthb3RhbGtcIiwgL0tBS0FPVEFMS1xccyhbMC05XFwuXSspL10sIFtcInNhbXN1bmdcIiwgL1NhbXN1bmdCcm93c2VyXFwvKFswLTlcXC5dKykvXSwgW1wic2lsa1wiLCAvXFxiU2lsa1xcLyhbMC05Ll8tXSspXFxiL10sIFtcIm1pdWlcIiwgL01pdWlCcm93c2VyXFwvKFswLTlcXC5dKykkL10sIFtcImJlYWtlclwiLCAvQmVha2VyQnJvd3NlclxcLyhbMC05XFwuXSspL10sIFtcImVkZ2UtY2hyb21pdW1cIiwgL0VkZ0E/XFwvKFswLTlcXC5dKykvXSwgW1wiY2hyb21pdW0td2Vidmlld1wiLCAvKD8hQ2hyb20uKk9QUil3dlxcKS4qQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLCBbXCJjaHJvbWVcIiwgLyg/IUNocm9tLipPUFIpQ2hyb20oPzplfGl1bSlcXC8oWzAtOVxcLl0rKSg6P1xcc3wkKS9dLCBbXCJwaGFudG9tanNcIiwgL1BoYW50b21KU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcImNyaW9zXCIsIC9DcmlPU1xcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcImZpcmVmb3hcIiwgL0ZpcmVmb3hcXC8oWzAtOVxcLl0rKSg/Olxcc3wkKS9dLCBbXCJmeGlvc1wiLCAvRnhpT1NcXC8oWzAtOVxcLl0rKS9dLCBbXCJvcGVyYS1taW5pXCIsIC9PcGVyYSBNaW5pLipWZXJzaW9uXFwvKFswLTlcXC5dKykvXSwgW1wib3BlcmFcIiwgL09wZXJhXFwvKFswLTlcXC5dKykoPzpcXHN8JCkvXSwgW1wib3BlcmFcIiwgL09QUlxcLyhbMC05XFwuXSspKDo/XFxzfCQpL10sIFtcInBpZVwiLCAvXk1pY3Jvc29mdCBQb2NrZXQgSW50ZXJuZXQgRXhwbG9yZXJcXC8oXFxkK1xcLlxcZCspJC9dLCBbXCJwaWVcIiwgL15Nb3ppbGxhXFwvXFxkXFwuXFxkK1xcc1xcKGNvbXBhdGlibGU7XFxzKD86TVNQP0lFfE1TSW50ZXJuZXQgRXhwbG9yZXIpIChcXGQrXFwuXFxkKyk7LipXaW5kb3dzIENFLipcXCkkL10sIFtcIm5ldGZyb250XCIsIC9eTW96aWxsYVxcL1xcZFxcLlxcZCsuKk5ldEZyb250XFwvKFxcZC5cXGQpL10sIFtcImllXCIsIC9UcmlkZW50XFwvN1xcLjAuKnJ2XFw6KFswLTlcXC5dKykuKlxcKS4qR2Vja28kL10sIFtcImllXCIsIC9NU0lFXFxzKFswLTlcXC5dKyk7LipUcmlkZW50XFwvWzQtN10uMC9dLCBbXCJpZVwiLCAvTVNJRVxccyg3XFwuMCkvXSwgW1wiYmIxMFwiLCAvQkIxMDtcXHNUb3VjaC4qVmVyc2lvblxcLyhbMC05XFwuXSspL10sIFtcImFuZHJvaWRcIiwgL0FuZHJvaWRcXHMoWzAtOVxcLl0rKS9dLCBbXCJpb3NcIiwgL1ZlcnNpb25cXC8oWzAtOVxcLl9dKykuKk1vYmlsZS4qU2FmYXJpLiovXSwgW1wic2FmYXJpXCIsIC9WZXJzaW9uXFwvKFswLTlcXC5fXSspLipTYWZhcmkvXSwgW1wiZmFjZWJvb2tcIiwgL0ZCW0FTXVZcXC8oWzAtOVxcLl0rKS9dLCBbXCJpbnN0YWdyYW1cIiwgL0luc3RhZ3JhbVxccyhbMC05XFwuXSspL10sIFtcImlvcy13ZWJ2aWV3XCIsIC9BcHBsZVdlYktpdFxcLyhbMC05XFwuXSspLipNb2JpbGUvXSwgW1wiaW9zLXdlYnZpZXdcIiwgL0FwcGxlV2ViS2l0XFwvKFswLTlcXC5dKykuKkdlY2tvXFwpJC9dLCBbXCJjdXJsXCIsIC9eY3VybFxcLyhbMC05XFwuXSspJC9dLCBbXCJzZWFyY2hib3RcIiwgU0VBUkNIQk9YX1VBX1JFR0VYXV07XG5jb25zdCBtYXRjaFVzZXJBZ2VudCA9IHVhID0+IHtcbiAgcmV0dXJuIHVhICE9PSBcIlwiICYmIHVzZXJBZ2VudFJ1bGVzLnJlZHVjZSgobWF0Y2hlZCwgW2Jyb3dzZXIsIHJlZ2V4XSkgPT4ge1xuICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9XG4gICAgY29uc3QgdWFNYXRjaCA9IHJlZ2V4LmV4ZWModWEpO1xuICAgIHJldHVybiAhIXVhTWF0Y2ggJiYgW2Jyb3dzZXIsIHVhTWF0Y2hdO1xuICB9LCBmYWxzZSk7XG59O1xuY29uc3QgaXNDdXJyZW50QnJvd3NlclN1cHBvcnRlZCA9IHN1cHBvcnRlZEJyb3dzZXIgPT4ge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBtYXRjaGVkUnVsZSA9IG1hdGNoVXNlckFnZW50KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBpZiAoIW1hdGNoZWRSdWxlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IFtuYW1lXSA9IG1hdGNoZWRSdWxlO1xuICBpZiAobmFtZSA9PT0gXCJzZWFyY2hib3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gISFzdXBwb3J0ZWRCcm93c2VyLmZpbmQoaXRlbSA9PiBpdGVtID09PSBuYW1lKTtcbn07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLXR5cGVkLWFycmF5cyAtLSBzYWZlXG52YXIgYXJyYXlCdWZmZXJOYXRpdmUgPSB0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERhdGFWaWV3ICE9ICd1bmRlZmluZWQnO1xuXG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiQxID0gYXJyYXlCdWZmZXJOYXRpdmU7XG52YXIgREVTQ1JJUFRPUlMkMiA9IGRlc2NyaXB0b3JzO1xudmFyIGdsb2JhbCQ3ID0gZ2xvYmFsJHQ7XG52YXIgaXNDYWxsYWJsZSQyID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDQgPSBpc09iamVjdCRkO1xudmFyIGhhc093biQxID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBjbGFzc29mJDQgPSBjbGFzc29mJDk7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ1O1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDg7XG52YXIgZGVmaW5lQnVpbHRJbiQyID0gZGVmaW5lQnVpbHRJbiQ4O1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGlzUHJvdG90eXBlT2YkMSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgZ2V0UHJvdG90eXBlT2YkMSA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mJDMgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIHVpZCA9IHVpZCQzO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMiA9IGludGVybmFsU3RhdGU7XG5cbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmVuZm9yY2U7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLmdldDtcbnZhciBJbnQ4QXJyYXkkNCA9IGdsb2JhbCQ3LkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUkMSA9IEludDhBcnJheSQ0ICYmIEludDhBcnJheSQ0LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSQxID0gZ2xvYmFsJDcuVWludDhDbGFtcGVkQXJyYXk7XG52YXIgVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUgPSBVaW50OENsYW1wZWRBcnJheSQxICYmIFVpbnQ4Q2xhbXBlZEFycmF5JDEucHJvdG90eXBlO1xudmFyIFR5cGVkQXJyYXkkMSA9IEludDhBcnJheSQ0ICYmIGdldFByb3RvdHlwZU9mJDEoSW50OEFycmF5JDQpO1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9IEludDhBcnJheVByb3RvdHlwZSQxICYmIGdldFByb3RvdHlwZU9mJDEoSW50OEFycmF5UHJvdG90eXBlJDEpO1xudmFyIE9iamVjdFByb3RvdHlwZSQxID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBUeXBlRXJyb3IkMSA9IGdsb2JhbCQ3LlR5cGVFcnJvcjtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2wkMigndG9TdHJpbmdUYWcnKTtcbnZhciBUWVBFRF9BUlJBWV9UQUckMSA9IHVpZCgnVFlQRURfQVJSQVlfVEFHJyk7XG52YXIgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IgPSAnVHlwZWRBcnJheUNvbnN0cnVjdG9yJztcbi8vIEZpeGluZyBuYXRpdmUgdHlwZWQgYXJyYXlzIGluIE9wZXJhIFByZXN0byBjcmFzaGVzIHRoZSBicm93c2VyLCBzZWUgIzU5NVxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiA9IE5BVElWRV9BUlJBWV9CVUZGRVIkMSAmJiAhIXNldFByb3RvdHlwZU9mJDMgJiYgY2xhc3NvZiQ0KGdsb2JhbCQ3Lm9wZXJhKSAhPT0gJ09wZXJhJztcbnZhciBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgPSBmYWxzZTtcbnZhciBOQU1FLCBDb25zdHJ1Y3RvciwgUHJvdG90eXBlO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG4gIEludDhBcnJheTogMSxcbiAgVWludDhBcnJheTogMSxcbiAgVWludDhDbGFtcGVkQXJyYXk6IDEsXG4gIEludDE2QXJyYXk6IDIsXG4gIFVpbnQxNkFycmF5OiAyLFxuICBJbnQzMkFycmF5OiA0LFxuICBVaW50MzJBcnJheTogNCxcbiAgRmxvYXQzMkFycmF5OiA0LFxuICBGbG9hdDY0QXJyYXk6IDhcbn07XG5cbnZhciBCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG4gIEJpZ0ludDY0QXJyYXk6IDgsXG4gIEJpZ1VpbnQ2NEFycmF5OiA4XG59O1xuXG52YXIgaXNWaWV3ID0gZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gIGlmICghaXNPYmplY3QkNChpdCkpIHJldHVybiBmYWxzZTtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZiQ0KGl0KTtcbiAgcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnXG4gICAgfHwgaGFzT3duJDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKVxuICAgIHx8IGhhc093biQxKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcblxudmFyIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGVPZiQxKGl0KTtcbiAgaWYgKCFpc09iamVjdCQ0KHByb3RvKSkgcmV0dXJuO1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDIocHJvdG8pO1xuICByZXR1cm4gKHN0YXRlICYmIGhhc093biQxKHN0YXRlLCBUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUikpID8gc3RhdGVbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdIDogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKHByb3RvKTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkkMSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0JDQoaXQpKSByZXR1cm4gZmFsc2U7XG4gIHZhciBrbGFzcyA9IGNsYXNzb2YkNChpdCk7XG4gIHJldHVybiBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpXG4gICAgfHwgaGFzT3duJDEoQmlnSW50QXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcyk7XG59O1xuXG52YXIgYVR5cGVkQXJyYXkkNCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNUeXBlZEFycmF5JDEoaXQpKSByZXR1cm4gaXQ7XG4gIHRocm93IFR5cGVFcnJvciQxKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXknKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDIgPSBmdW5jdGlvbiAoQykge1xuICBpZiAoaXNDYWxsYWJsZSQyKEMpICYmICghc2V0UHJvdG90eXBlT2YkMyB8fCBpc1Byb3RvdHlwZU9mJDEoVHlwZWRBcnJheSQxLCBDKSkpIHJldHVybiBDO1xuICB0aHJvdyBUeXBlRXJyb3IkMSh0cnlUb1N0cmluZyhDKSArICcgaXMgbm90IGEgdHlwZWQgYXJyYXkgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDQgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkLCBvcHRpb25zKSB7XG4gIGlmICghREVTQ1JJUFRPUlMkMikgcmV0dXJuO1xuICBpZiAoZm9yY2VkKSBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWwkN1tBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24kMShUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKSB0cnkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gb2xkIFdlYktpdCBidWcgLSBzb21lIG1ldGhvZHMgYXJlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXSA9IHByb3BlcnR5O1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7IC8qIGVtcHR5ICovIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlJDFbS0VZXSB8fCBmb3JjZWQpIHtcbiAgICBkZWZpbmVCdWlsdEluJDIoVHlwZWRBcnJheVByb3RvdHlwZSQxLCBLRVksIGZvcmNlZCA/IHByb3BlcnR5XG4gICAgICA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiAmJiBJbnQ4QXJyYXlQcm90b3R5cGUkMVtLRVldIHx8IHByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QkMSA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gIGlmICghREVTQ1JJUFRPUlMkMikgcmV0dXJuO1xuICBpZiAoc2V0UHJvdG90eXBlT2YkMykge1xuICAgIGlmIChmb3JjZWQpIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W0FSUkFZXTtcbiAgICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzT3duJDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB0cnkge1xuICAgICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV07XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfVxuICAgIGlmICghVHlwZWRBcnJheSQxW0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgICAvLyBWOCB+IENocm9tZSA0OS01MCBgJVR5cGVkQXJyYXklYCBtZXRob2RzIGFyZSBub24td3JpdGFibGUgbm9uLWNvbmZpZ3VyYWJsZVxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRlZmluZUJ1aWx0SW4kMihUeXBlZEFycmF5JDEsIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIgJiYgVHlwZWRBcnJheSQxW0tFWV0gfHwgcHJvcGVydHkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICAgIH0gZWxzZSByZXR1cm47XG4gIH1cbiAgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ3W0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgZGVmaW5lQnVpbHRJbiQyKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZLCBwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG59O1xuXG5mb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgQ29uc3RydWN0b3IgPSBnbG9iYWwkN1tOQU1FXTtcbiAgUHJvdG90eXBlID0gQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpZiAoUHJvdG90eXBlKSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQxKFByb3RvdHlwZSlbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdID0gQ29uc3RydWN0b3I7XG4gIGVsc2UgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyID0gZmFsc2U7XG59XG5cbmZvciAoTkFNRSBpbiBCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgQ29uc3RydWN0b3IgPSBnbG9iYWwkN1tOQU1FXTtcbiAgUHJvdG90eXBlID0gQ29uc3RydWN0b3IgJiYgQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICBpZiAoUHJvdG90eXBlKSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSQxKFByb3RvdHlwZSlbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdID0gQ29uc3RydWN0b3I7XG59XG5cbi8vIFdlYktpdCBidWcgLSB0eXBlZCBhcnJheXMgY29uc3RydWN0b3JzIHByb3RvdHlwZSBpcyBPYmplY3QucHJvdG90eXBlXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiB8fCAhaXNDYWxsYWJsZSQyKFR5cGVkQXJyYXkkMSkgfHwgVHlwZWRBcnJheSQxID09PSBGdW5jdGlvbi5wcm90b3R5cGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvdyAtLSBzYWZlXG4gIFR5cGVkQXJyYXkkMSA9IGZ1bmN0aW9uIFR5cGVkQXJyYXkoKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yJDEoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gIH07XG4gIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDIpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIGlmIChnbG9iYWwkN1tOQU1FXSkgc2V0UHJvdG90eXBlT2YkMyhnbG9iYWwkN1tOQU1FXSwgVHlwZWRBcnJheSQxKTtcbiAgfVxufVxuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiB8fCAhVHlwZWRBcnJheVByb3RvdHlwZSQxIHx8IFR5cGVkQXJyYXlQcm90b3R5cGUkMSA9PT0gT2JqZWN0UHJvdG90eXBlJDEpIHtcbiAgVHlwZWRBcnJheVByb3RvdHlwZSQxID0gVHlwZWRBcnJheSQxLnByb3RvdHlwZTtcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMikgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbCQ3W05BTUVdKSBzZXRQcm90b3R5cGVPZiQzKGdsb2JhbCQ3W05BTUVdLnByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSQxKTtcbiAgfVxufVxuXG4vLyBXZWJLaXQgYnVnIC0gb25lIG1vcmUgb2JqZWN0IGluIFVpbnQ4Q2xhbXBlZEFycmF5IHByb3RvdHlwZSBjaGFpblxuaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMiAmJiBnZXRQcm90b3R5cGVPZiQxKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlKSAhPT0gVHlwZWRBcnJheVByb3RvdHlwZSQxKSB7XG4gIHNldFByb3RvdHlwZU9mJDMoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUkMSk7XG59XG5cbmlmIChERVNDUklQVE9SUyQyICYmICFoYXNPd24kMShUeXBlZEFycmF5UHJvdG90eXBlJDEsIFRPX1NUUklOR19UQUcpKSB7XG4gIFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCA9IHRydWU7XG4gIGRlZmluZVByb3BlcnR5JDEoVHlwZWRBcnJheVByb3RvdHlwZSQxLCBUT19TVFJJTkdfVEFHLCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc09iamVjdCQ0KHRoaXMpID8gdGhpc1tUWVBFRF9BUlJBWV9UQUckMV0gOiB1bmRlZmluZWQ7XG4gIH0gfSk7XG4gIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkgaWYgKGdsb2JhbCQ3W05BTUVdKSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDMoZ2xvYmFsJDdbTkFNRV0sIFRZUEVEX0FSUkFZX1RBRyQxLCBOQU1FKTtcbiAgfVxufVxuXG52YXIgYXJyYXlCdWZmZXJWaWV3Q29yZSA9IHtcbiAgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUzogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyQyLFxuICBUWVBFRF9BUlJBWV9UQUc6IFRZUEVEX0FSUkFZX1RBR19SRVFVSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUckMSxcbiAgYVR5cGVkQXJyYXk6IGFUeXBlZEFycmF5JDQsXG4gIGFUeXBlZEFycmF5Q29uc3RydWN0b3I6IGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMixcbiAgZXhwb3J0VHlwZWRBcnJheU1ldGhvZDogZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQ0LFxuICBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kOiBleHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kJDEsXG4gIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yLFxuICBpc1ZpZXc6IGlzVmlldyxcbiAgaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXkkMSxcbiAgVHlwZWRBcnJheTogVHlwZWRBcnJheSQxLFxuICBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlJDFcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuXG52YXIgZ2xvYmFsJDYgPSBnbG9iYWwkdDtcbnZhciBmYWlscyQ4ID0gZmFpbHMkcztcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24kMjtcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTJDEgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG5cbnZhciBBcnJheUJ1ZmZlciQzID0gZ2xvYmFsJDYuQXJyYXlCdWZmZXI7XG52YXIgSW50OEFycmF5JDMgPSBnbG9iYWwkNi5JbnQ4QXJyYXk7XG5cbnZhciB0eXBlZEFycmF5Q29uc3RydWN0b3JzUmVxdWlyZVdyYXBwZXJzID0gIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MkMSB8fCAhZmFpbHMkOChmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheSQzKDEpO1xufSkgfHwgIWZhaWxzJDgoZnVuY3Rpb24gKCkge1xuICBuZXcgSW50OEFycmF5JDMoLTEpO1xufSkgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgbmV3IEludDhBcnJheSQzKCk7XG4gIG5ldyBJbnQ4QXJyYXkkMyhudWxsKTtcbiAgbmV3IEludDhBcnJheSQzKDEuNSk7XG4gIG5ldyBJbnQ4QXJyYXkkMyhpdGVyYWJsZSk7XG59LCB0cnVlKSB8fCBmYWlscyQ4KGZ1bmN0aW9uICgpIHtcbiAgLy8gU2FmYXJpICgxMSspIGJ1ZyAtIGEgcmVhc29uIHdoeSBldmVuIFNhZmFyaSAxMyBzaG91bGQgbG9hZCBhIHR5cGVkIGFycmF5IHBvbHlmaWxsXG4gIHJldHVybiBuZXcgSW50OEFycmF5JDMobmV3IEFycmF5QnVmZmVyJDMoMiksIDEsIHVuZGVmaW5lZCkubGVuZ3RoICE9PSAxO1xufSk7XG5cbnZhciBiaW5kJDEgPSBmdW5jdGlvbkJpbmRDb250ZXh0O1xudmFyIGNhbGwkNSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhQ29uc3RydWN0b3IgPSBhQ29uc3RydWN0b3IkMjtcbnZhciB0b09iamVjdCQyID0gdG9PYmplY3QkNztcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ0ID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciBnZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDI7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQzO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IkMSA9IGFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxudmFyIHR5cGVkQXJyYXlGcm9tJDIgPSBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcGZuLCB0aGlzQXJnICovKSB7XG4gIHZhciBDID0gYUNvbnN0cnVjdG9yKHRoaXMpO1xuICB2YXIgTyA9IHRvT2JqZWN0JDIoc291cmNlKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG4gIHZhciBpLCBsZW5ndGgsIHJlc3VsdCwgc3RlcCwgaXRlcmF0b3IsIG5leHQ7XG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkge1xuICAgIGl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIE8gPSBbXTtcbiAgICB3aGlsZSAoIShzdGVwID0gY2FsbCQ1KG5leHQsIGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICAgTy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgIH1cbiAgfVxuICBpZiAobWFwcGluZyAmJiBhcmd1bWVudHNMZW5ndGggPiAyKSB7XG4gICAgbWFwZm4gPSBiaW5kJDEobWFwZm4sIGFyZ3VtZW50c1syXSk7XG4gIH1cbiAgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkNChPKTtcbiAgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yJDEoQykpKGxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGxlbmd0aCA+IGk7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IG1hcHBpbmcgPyBtYXBmbihPW2ldLCBpKSA6IE9baV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTJDEgPSB0eXBlZEFycmF5Q29uc3RydWN0b3JzUmVxdWlyZVdyYXBwZXJzO1xudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QgPSBhcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q7XG52YXIgdHlwZWRBcnJheUZyb20kMSA9IHR5cGVkQXJyYXlGcm9tJDI7XG5cbi8vIGAlVHlwZWRBcnJheSUuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5mcm9tXG5leHBvcnRUeXBlZEFycmF5U3RhdGljTWV0aG9kKCdmcm9tJywgdHlwZWRBcnJheUZyb20kMSwgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyQxKTtcblxudmFyIGRlZmluZUJ1aWx0SW4kMSA9IGRlZmluZUJ1aWx0SW4kODtcblxudmFyIGRlZmluZUJ1aWx0SW5zJDEgPSBmdW5jdGlvbiAodGFyZ2V0LCBzcmMsIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykgZGVmaW5lQnVpbHRJbiQxKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQzID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xudmFyIHRvTGVuZ3RoJDQgPSB0b0xlbmd0aCQ2O1xuXG52YXIgJFJhbmdlRXJyb3IkMiA9IFJhbmdlRXJyb3I7XG5cbi8vIGBUb0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbmRleFxudmFyIHRvSW5kZXgkMiA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXJPckluZmluaXR5JDMoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgkNChudW1iZXIpO1xuICBpZiAobnVtYmVyICE9PSBsZW5ndGgpIHRocm93ICRSYW5nZUVycm9yJDIoJ1dyb25nIGxlbmd0aCBvciBpbmRleCcpO1xuICByZXR1cm4gbGVuZ3RoO1xufTtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciAkQXJyYXkkMiA9IEFycmF5O1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yJDIgPSBNYXRoLmZsb29yO1xudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG52YXIgcGFjayA9IGZ1bmN0aW9uIChudW1iZXIsIG1hbnRpc3NhTGVuZ3RoLCBieXRlcykge1xuICB2YXIgYnVmZmVyID0gJEFycmF5JDIoYnl0ZXMpO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgcnQgPSBtYW50aXNzYUxlbmd0aCA9PT0gMjMgPyBwb3coMiwgLTI0KSAtIHBvdygyLCAtNzcpIDogMDtcbiAgdmFyIHNpZ24gPSBudW1iZXIgPCAwIHx8IG51bWJlciA9PT0gMCAmJiAxIC8gbnVtYmVyIDwgMCA/IDEgOiAwO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgZXhwb25lbnQsIG1hbnRpc3NhLCBjO1xuICBudW1iZXIgPSBhYnMobnVtYmVyKTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgaWYgKG51bWJlciAhPSBudW1iZXIgfHwgbnVtYmVyID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgbWFudGlzc2EgPSBudW1iZXIgIT0gbnVtYmVyID8gMSA6IDA7XG4gICAgZXhwb25lbnQgPSBlTWF4O1xuICB9IGVsc2Uge1xuICAgIGV4cG9uZW50ID0gZmxvb3IkMihsb2cobnVtYmVyKSAvIExOMik7XG4gICAgYyA9IHBvdygyLCAtZXhwb25lbnQpO1xuICAgIGlmIChudW1iZXIgKiBjIDwgMSkge1xuICAgICAgZXhwb25lbnQtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbnVtYmVyICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmIChudW1iZXIgKiBjID49IDIpIHtcbiAgICAgIGV4cG9uZW50Kys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG1hbnRpc3NhID0gMDtcbiAgICAgIGV4cG9uZW50ID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbWFudGlzc2EgPSAobnVtYmVyICogYyAtIDEpICogcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWFudGlzc2EgPSBudW1iZXIgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IDA7XG4gICAgfVxuICB9XG4gIHdoaWxlIChtYW50aXNzYUxlbmd0aCA+PSA4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gbWFudGlzc2EgJiAyNTU7XG4gICAgbWFudGlzc2EgLz0gMjU2O1xuICAgIG1hbnRpc3NhTGVuZ3RoIC09IDg7XG4gIH1cbiAgZXhwb25lbnQgPSBleHBvbmVudCA8PCBtYW50aXNzYUxlbmd0aCB8IG1hbnRpc3NhO1xuICBleHBvbmVudExlbmd0aCArPSBtYW50aXNzYUxlbmd0aDtcbiAgd2hpbGUgKGV4cG9uZW50TGVuZ3RoID4gMCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGV4cG9uZW50ICYgMjU1O1xuICAgIGV4cG9uZW50IC89IDI1NjtcbiAgICBleHBvbmVudExlbmd0aCAtPSA4O1xuICB9XG4gIGJ1ZmZlclstLWluZGV4XSB8PSBzaWduICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxudmFyIHVucGFjayA9IGZ1bmN0aW9uIChidWZmZXIsIG1hbnRpc3NhTGVuZ3RoKSB7XG4gIHZhciBieXRlcyA9IGJ1ZmZlci5sZW5ndGg7XG4gIHZhciBleHBvbmVudExlbmd0aCA9IGJ5dGVzICogOCAtIG1hbnRpc3NhTGVuZ3RoIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBleHBvbmVudExlbmd0aCkgLSAxO1xuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDE7XG4gIHZhciBuQml0cyA9IGV4cG9uZW50TGVuZ3RoIC0gNztcbiAgdmFyIGluZGV4ID0gYnl0ZXMgLSAxO1xuICB2YXIgc2lnbiA9IGJ1ZmZlcltpbmRleC0tXTtcbiAgdmFyIGV4cG9uZW50ID0gc2lnbiAmIDEyNztcbiAgdmFyIG1hbnRpc3NhO1xuICBzaWduID4+PSA3O1xuICB3aGlsZSAobkJpdHMgPiAwKSB7XG4gICAgZXhwb25lbnQgPSBleHBvbmVudCAqIDI1NiArIGJ1ZmZlcltpbmRleC0tXTtcbiAgICBuQml0cyAtPSA4O1xuICB9XG4gIG1hbnRpc3NhID0gZXhwb25lbnQgJiAoMSA8PCAtbkJpdHMpIC0gMTtcbiAgZXhwb25lbnQgPj49IC1uQml0cztcbiAgbkJpdHMgKz0gbWFudGlzc2FMZW5ndGg7XG4gIHdoaWxlIChuQml0cyA+IDApIHtcbiAgICBtYW50aXNzYSA9IG1hbnRpc3NhICogMjU2ICsgYnVmZmVyW2luZGV4LS1dO1xuICAgIG5CaXRzIC09IDg7XG4gIH1cbiAgaWYgKGV4cG9uZW50ID09PSAwKSB7XG4gICAgZXhwb25lbnQgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZXhwb25lbnQgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbWFudGlzc2EgPyBOYU4gOiBzaWduID8gLUluZmluaXR5IDogSW5maW5pdHk7XG4gIH0gZWxzZSB7XG4gICAgbWFudGlzc2EgPSBtYW50aXNzYSArIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgZXhwb25lbnQgPSBleHBvbmVudCAtIGVCaWFzO1xuICB9IHJldHVybiAoc2lnbiA/IC0xIDogMSkgKiBtYW50aXNzYSAqIHBvdygyLCBleHBvbmVudCAtIG1hbnRpc3NhTGVuZ3RoKTtcbn07XG5cbnZhciBpZWVlNzU0ID0ge1xuICBwYWNrOiBwYWNrLFxuICB1bnBhY2s6IHVucGFja1xufTtcblxudmFyIHRvT2JqZWN0JDEgPSB0b09iamVjdCQ3O1xudmFyIHRvQWJzb2x1dGVJbmRleCQyID0gdG9BYnNvbHV0ZUluZGV4JDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMyA9IGxlbmd0aE9mQXJyYXlMaWtlJDg7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG52YXIgYXJyYXlGaWxsJDEgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QkMSh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDMoTyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgkMihhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4JDIoZW5kLCBsZW5ndGgpO1xuICB3aGlsZSAoZW5kUG9zID4gaW5kZXgpIE9baW5kZXgrK10gPSB2YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQxKGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQ0O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDIgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gY3JlYXRlUHJvcGVydHkkMTtcblxudmFyICRBcnJheSQxID0gQXJyYXk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG5cbnZhciBhcnJheVNsaWNlU2ltcGxlID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDIoTyk7XG4gIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDEoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgkMShlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheSQxKG1heChmaW4gLSBrLCAwKSk7XG4gIGZvciAodmFyIG4gPSAwOyBrIDwgZmluOyBrKyssIG4rKykgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBuLCBPW2tdKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkdDtcbnZhciB1bmN1cnJ5VGhpcyQ3ID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBERVNDUklQVE9SUyQxID0gZGVzY3JpcHRvcnM7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IGFycmF5QnVmZmVyTmF0aXZlO1xudmFyIEZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uTmFtZTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xudmFyIGRlZmluZUJ1aWx0SW5zID0gZGVmaW5lQnVpbHRJbnMkMTtcbnZhciBmYWlscyQ3ID0gZmFpbHMkcztcbnZhciBhbkluc3RhbmNlJDEgPSBhbkluc3RhbmNlJDM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ2O1xudmFyIHRvTGVuZ3RoJDMgPSB0b0xlbmd0aCQ2O1xudmFyIHRvSW5kZXgkMSA9IHRvSW5kZXgkMjtcbnZhciBJRUVFNzU0ID0gaWVlZTc1NDtcbnZhciBnZXRQcm90b3R5cGVPZiA9IG9iamVjdEdldFByb3RvdHlwZU9mO1xudmFyIHNldFByb3RvdHlwZU9mJDIgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGFycmF5RmlsbCA9IGFycmF5RmlsbCQxO1xudmFyIGFycmF5U2xpY2UkMyA9IGFycmF5U2xpY2VTaW1wbGU7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQ0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMSA9IGludGVybmFsU3RhdGU7XG5cbnZhciBQUk9QRVJfRlVOQ1RJT05fTkFNRSA9IEZ1bmN0aW9uTmFtZS5QUk9QRVI7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBGdW5jdGlvbk5hbWUuQ09ORklHVVJBQkxFO1xudmFyIGdldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkMS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIERBVEFfVklFVyA9ICdEYXRhVmlldyc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgV1JPTkdfTEVOR1RIJDEgPSAnV3JvbmcgbGVuZ3RoJztcbnZhciBXUk9OR19JTkRFWCA9ICdXcm9uZyBpbmRleCc7XG52YXIgTmF0aXZlQXJyYXlCdWZmZXIgPSBnbG9iYWwkNVtBUlJBWV9CVUZGRVJdO1xudmFyICRBcnJheUJ1ZmZlciA9IE5hdGl2ZUFycmF5QnVmZmVyO1xudmFyIEFycmF5QnVmZmVyUHJvdG90eXBlJDEgPSAkQXJyYXlCdWZmZXIgJiYgJEFycmF5QnVmZmVyW1BST1RPVFlQRV07XG52YXIgJERhdGFWaWV3ID0gZ2xvYmFsJDVbREFUQV9WSUVXXTtcbnZhciBEYXRhVmlld1Byb3RvdHlwZSQxID0gJERhdGFWaWV3ICYmICREYXRhVmlld1tQUk9UT1RZUEVdO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgQXJyYXkkMSA9IGdsb2JhbCQ1LkFycmF5O1xudmFyIFJhbmdlRXJyb3IkMyA9IGdsb2JhbCQ1LlJhbmdlRXJyb3I7XG52YXIgZmlsbCA9IHVuY3VycnlUaGlzJDcoYXJyYXlGaWxsKTtcbnZhciByZXZlcnNlID0gdW5jdXJyeVRoaXMkNyhbXS5yZXZlcnNlKTtcblxudmFyIHBhY2tJRUVFNzU0ID0gSUVFRTc1NC5wYWNrO1xudmFyIHVucGFja0lFRUU3NTQgPSBJRUVFNzU0LnVucGFjaztcblxudmFyIHBhY2tJbnQ4ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gW251bWJlciAmIDB4RkZdO1xufTtcblxudmFyIHBhY2tJbnQxNiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGLCBudW1iZXIgPj4gOCAmIDB4RkZdO1xufTtcblxudmFyIHBhY2tJbnQzMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGLCBudW1iZXIgPj4gOCAmIDB4RkYsIG51bWJlciA+PiAxNiAmIDB4RkYsIG51bWJlciA+PiAyNCAmIDB4RkZdO1xufTtcblxudmFyIHVucGFja0ludDMyID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyWzNdIDw8IDI0IHwgYnVmZmVyWzJdIDw8IDE2IHwgYnVmZmVyWzFdIDw8IDggfCBidWZmZXJbMF07XG59O1xuXG52YXIgcGFja0Zsb2F0MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBwYWNrSUVFRTc1NChudW1iZXIsIDIzLCA0KTtcbn07XG5cbnZhciBwYWNrRmxvYXQ2NCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgNTIsIDgpO1xufTtcblxudmFyIGFkZEdldHRlciQxID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBrZXkpIHtcbiAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3JbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMpW2tleV07IH0gfSk7XG59O1xuXG52YXIgZ2V0ID0gZnVuY3Rpb24gKHZpZXcsIGNvdW50LCBpbmRleCwgaXNMaXR0bGVFbmRpYW4pIHtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleCQxKGluZGV4KTtcbiAgdmFyIHN0b3JlID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IkMyhXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUkMShzdG9yZS5idWZmZXIpLmJ5dGVzO1xuICB2YXIgc3RhcnQgPSBpbnRJbmRleCArIHN0b3JlLmJ5dGVPZmZzZXQ7XG4gIHZhciBwYWNrID0gYXJyYXlTbGljZSQzKGJ5dGVzLCBzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIHJldHVybiBpc0xpdHRsZUVuZGlhbiA/IHBhY2sgOiByZXZlcnNlKHBhY2spO1xufTtcblxudmFyIHNldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgaW50SW5kZXggPSB0b0luZGV4JDEoaW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvciQzKFdST05HX0lOREVYKTtcbiAgdmFyIGJ5dGVzID0gZ2V0SW50ZXJuYWxTdGF0ZSQxKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgYnl0ZXNbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogY291bnQgLSBpIC0gMV07XG59O1xuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVIpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSQxKHRoaXMsIEFycmF5QnVmZmVyUHJvdG90eXBlJDEpO1xuICAgIHZhciBieXRlTGVuZ3RoID0gdG9JbmRleCQxKGxlbmd0aCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICAgIGJ5dGVzOiBmaWxsKEFycmF5JDEoYnl0ZUxlbmd0aCksIDApLFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aFxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMkMSkgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgfTtcblxuICBBcnJheUJ1ZmZlclByb3RvdHlwZSQxID0gJEFycmF5QnVmZmVyW1BST1RPVFlQRV07XG5cbiAgJERhdGFWaWV3ID0gZnVuY3Rpb24gRGF0YVZpZXcoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSQxKHRoaXMsIERhdGFWaWV3UHJvdG90eXBlJDEpO1xuICAgIGFuSW5zdGFuY2UkMShidWZmZXIsIEFycmF5QnVmZmVyUHJvdG90eXBlJDEpO1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBnZXRJbnRlcm5hbFN0YXRlJDEoYnVmZmVyKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXJPckluZmluaXR5JDIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDMoJ1dyb25nIG9mZnNldCcpO1xuICAgIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID09PSB1bmRlZmluZWQgPyBidWZmZXJMZW5ndGggLSBvZmZzZXQgOiB0b0xlbmd0aCQzKGJ5dGVMZW5ndGgpO1xuICAgIGlmIChvZmZzZXQgKyBieXRlTGVuZ3RoID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDMoV1JPTkdfTEVOR1RIJDEpO1xuICAgIHNldEludGVybmFsU3RhdGUkMSh0aGlzLCB7XG4gICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGgsXG4gICAgICBieXRlT2Zmc2V0OiBvZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTJDEpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gIH07XG5cbiAgRGF0YVZpZXdQcm90b3R5cGUkMSA9ICREYXRhVmlld1tQUk9UT1RZUEVdO1xuXG4gIGlmIChERVNDUklQVE9SUyQxKSB7XG4gICAgYWRkR2V0dGVyJDEoJEFycmF5QnVmZmVyLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlciQxKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIkMSgkRGF0YVZpZXcsICdieXRlT2Zmc2V0Jyk7XG4gIH1cblxuICBkZWZpbmVCdWlsdElucyhEYXRhVmlld1Byb3RvdHlwZSQxLCB7XG4gICAgZ2V0SW50ODogZnVuY3Rpb24gZ2V0SW50OChieXRlT2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZ2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQpWzBdIDw8IDI0ID4+IDI0O1xuICAgIH0sXG4gICAgZ2V0VWludDg6IGZ1bmN0aW9uIGdldFVpbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF07XG4gICAgfSxcbiAgICBnZXRJbnQxNjogZnVuY3Rpb24gZ2V0SW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiAoYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdKSA8PCAxNiA+PiAxNjtcbiAgICB9LFxuICAgIGdldFVpbnQxNjogZnVuY3Rpb24gZ2V0VWludDE2KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHZhciBieXRlcyA9IGdldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gICAgICByZXR1cm4gYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzBdO1xuICAgIH0sXG4gICAgZ2V0SW50MzI6IGZ1bmN0aW9uIGdldEludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJbnQzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKTtcbiAgICB9LFxuICAgIGdldFVpbnQzMjogZnVuY3Rpb24gZ2V0VWludDMyKGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJbnQzMihnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpKSA+Pj4gMDtcbiAgICB9LFxuICAgIGdldEZsb2F0MzI6IGZ1bmN0aW9uIGdldEZsb2F0MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0lFRUU3NTQoZ2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKSwgMjMpO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQ2NDogZnVuY3Rpb24gZ2V0RmxvYXQ2NChieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpLCA1Mik7XG4gICAgfSxcbiAgICBzZXRJbnQ4OiBmdW5jdGlvbiBzZXRJbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgc2V0KHRoaXMsIDEsIGJ5dGVPZmZzZXQsIHBhY2tJbnQ4LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZXRJbnQxNjogZnVuY3Rpb24gc2V0SW50MTYoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCAyLCBieXRlT2Zmc2V0LCBwYWNrSW50MTYsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRVaW50MTY6IGZ1bmN0aW9uIHNldFVpbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldEludDMyOiBmdW5jdGlvbiBzZXRJbnQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tJbnQzMiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldFVpbnQzMjogZnVuY3Rpb24gc2V0VWludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0RmxvYXQzMjogZnVuY3Rpb24gc2V0RmxvYXQzMihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDQsIGJ5dGVPZmZzZXQsIHBhY2tGbG9hdDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0RmxvYXQ2NDogZnVuY3Rpb24gc2V0RmxvYXQ2NChieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDgsIGJ5dGVPZmZzZXQsIHBhY2tGbG9hdDY0LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICB2YXIgSU5DT1JSRUNUX0FSUkFZX0JVRkZFUl9OQU1FID0gUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgTmF0aXZlQXJyYXlCdWZmZXIubmFtZSAhPT0gQVJSQVlfQlVGRkVSO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbiAgaWYgKCFmYWlscyQ3KGZ1bmN0aW9uICgpIHtcbiAgICBOYXRpdmVBcnJheUJ1ZmZlcigxKTtcbiAgfSkgfHwgIWZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigtMSk7XG4gIH0pIHx8IGZhaWxzJDcoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigpO1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigxLjUpO1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcihOYU4pO1xuICAgIHJldHVybiBJTkNPUlJFQ1RfQVJSQVlfQlVGRkVSX05BTUUgJiYgIUNPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FO1xuICB9KSkge1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xuICAgICRBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIEFycmF5QnVmZmVyKGxlbmd0aCkge1xuICAgICAgYW5JbnN0YW5jZSQxKHRoaXMsIEFycmF5QnVmZmVyUHJvdG90eXBlJDEpO1xuICAgICAgcmV0dXJuIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcih0b0luZGV4JDEobGVuZ3RoKSk7XG4gICAgfTtcblxuICAgICRBcnJheUJ1ZmZlcltQUk9UT1RZUEVdID0gQXJyYXlCdWZmZXJQcm90b3R5cGUkMTtcblxuICAgIGZvciAodmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEoTmF0aXZlQXJyYXlCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKCRBcnJheUJ1ZmZlciwga2V5LCBOYXRpdmVBcnJheUJ1ZmZlcltrZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBBcnJheUJ1ZmZlclByb3RvdHlwZSQxLmNvbnN0cnVjdG9yID0gJEFycmF5QnVmZmVyO1xuICB9IGVsc2UgaWYgKElOQ09SUkVDVF9BUlJBWV9CVUZGRVJfTkFNRSAmJiBDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQyKE5hdGl2ZUFycmF5QnVmZmVyLCAnbmFtZScsIEFSUkFZX0JVRkZFUik7XG4gIH1cblxuICAvLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcbiAgaWYgKHNldFByb3RvdHlwZU9mJDIgJiYgZ2V0UHJvdG90eXBlT2YoRGF0YVZpZXdQcm90b3R5cGUkMSkgIT09IE9iamVjdFByb3RvdHlwZSkge1xuICAgIHNldFByb3RvdHlwZU9mJDIoRGF0YVZpZXdQcm90b3R5cGUkMSwgT2JqZWN0UHJvdG90eXBlKTtcbiAgfVxuXG4gIC8vIGlPUyBTYWZhcmkgNy54IGJ1Z1xuICB2YXIgdGVzdFZpZXcgPSBuZXcgJERhdGFWaWV3KG5ldyAkQXJyYXlCdWZmZXIoMikpO1xuICB2YXIgJHNldEludDggPSB1bmN1cnJ5VGhpcyQ3KERhdGFWaWV3UHJvdG90eXBlJDEuc2V0SW50OCk7XG4gIHRlc3RWaWV3LnNldEludDgoMCwgMjE0NzQ4MzY0OCk7XG4gIHRlc3RWaWV3LnNldEludDgoMSwgMjE0NzQ4MzY0OSk7XG4gIGlmICh0ZXN0Vmlldy5nZXRJbnQ4KDApIHx8ICF0ZXN0Vmlldy5nZXRJbnQ4KDEpKSBkZWZpbmVCdWlsdElucyhEYXRhVmlld1Byb3RvdHlwZSQxLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgJHNldEludDgodGhpcywgYnl0ZU9mZnNldCwgdmFsdWUgPDwgMjQgPj4gMjQpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICAkc2V0SW50OCh0aGlzLCBieXRlT2Zmc2V0LCB2YWx1ZSA8PCAyNCA+PiAyNCk7XG4gICAgfVxuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbn1cblxuc2V0VG9TdHJpbmdUYWcoJEFycmF5QnVmZmVyLCBBUlJBWV9CVUZGRVIpO1xuc2V0VG9TdHJpbmdUYWcoJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuXG52YXIgYXJyYXlCdWZmZXIgPSB7XG4gIEFycmF5QnVmZmVyOiAkQXJyYXlCdWZmZXIsXG4gIERhdGFWaWV3OiAkRGF0YVZpZXdcbn07XG5cbnZhciAkJDEgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDYgPSBmYWlscyRzO1xudmFyIEFycmF5QnVmZmVyTW9kdWxlJDEgPSBhcnJheUJ1ZmZlcjtcbnZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkZTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkNDtcbnZhciB0b0xlbmd0aCQyID0gdG9MZW5ndGgkNjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IkMSA9IHNwZWNpZXNDb25zdHJ1Y3RvciQzO1xuXG52YXIgQXJyYXlCdWZmZXIkMiA9IEFycmF5QnVmZmVyTW9kdWxlJDEuQXJyYXlCdWZmZXI7XG52YXIgRGF0YVZpZXckMiA9IEFycmF5QnVmZmVyTW9kdWxlJDEuRGF0YVZpZXc7XG52YXIgRGF0YVZpZXdQcm90b3R5cGUgPSBEYXRhVmlldyQyLnByb3RvdHlwZTtcbnZhciB1biRBcnJheUJ1ZmZlclNsaWNlID0gdW5jdXJyeVRoaXMkNihBcnJheUJ1ZmZlciQyLnByb3RvdHlwZS5zbGljZSk7XG52YXIgZ2V0VWludDggPSB1bmN1cnJ5VGhpcyQ2KERhdGFWaWV3UHJvdG90eXBlLmdldFVpbnQ4KTtcbnZhciBzZXRVaW50OCA9IHVuY3VycnlUaGlzJDYoRGF0YVZpZXdQcm90b3R5cGUuc2V0VWludDgpO1xuXG52YXIgSU5DT1JSRUNUX1NMSUNFID0gZmFpbHMkNihmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhbmV3IEFycmF5QnVmZmVyJDIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSk7XG5cbi8vIGBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheWJ1ZmZlci5wcm90b3R5cGUuc2xpY2VcbiQkMSh7IHRhcmdldDogJ0FycmF5QnVmZmVyJywgcHJvdG86IHRydWUsIHVuc2FmZTogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfU0xJQ0UgfSwge1xuICBzbGljZTogZnVuY3Rpb24gc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgIGlmICh1biRBcnJheUJ1ZmZlclNsaWNlICYmIGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW4kQXJyYXlCdWZmZXJTbGljZShhbk9iamVjdCQyKHRoaXMpLCBzdGFydCk7IC8vIEZGIGZpeFxuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gYW5PYmplY3QkMih0aGlzKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBmaXJzdCA9IHRvQWJzb2x1dGVJbmRleChzdGFydCwgbGVuZ3RoKTtcbiAgICB2YXIgZmluID0gdG9BYnNvbHV0ZUluZGV4KGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvciQxKHRoaXMsIEFycmF5QnVmZmVyJDIpKSh0b0xlbmd0aCQyKGZpbiAtIGZpcnN0KSk7XG4gICAgdmFyIHZpZXdTb3VyY2UgPSBuZXcgRGF0YVZpZXckMih0aGlzKTtcbiAgICB2YXIgdmlld1RhcmdldCA9IG5ldyBEYXRhVmlldyQyKHJlc3VsdCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoZmlyc3QgPCBmaW4pIHtcbiAgICAgIHNldFVpbnQ4KHZpZXdUYXJnZXQsIGluZGV4KyssIGdldFVpbnQ4KHZpZXdTb3VyY2UsIGZpcnN0KyspKTtcbiAgICB9IHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuXG52YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGlzT2JqZWN0JDMgPSBpc09iamVjdCRkO1xuXG52YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG5cbi8vIGBJc0ludGVncmFsTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtaXNpbnRlZ3JhbG51bWJlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzLXgvbm8tbnVtYmVyLWlzaW50ZWdlciAtLSBzYWZlXG52YXIgaXNJbnRlZ3JhbE51bWJlciQxID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiBpc0ludGVnZXIoaXQpIHtcbiAgcmV0dXJuICFpc09iamVjdCQzKGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IkMShpdCkgPT09IGl0O1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcblxudmFyICRSYW5nZUVycm9yJDEgPSBSYW5nZUVycm9yO1xuXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQxKGl0KTtcbiAgaWYgKHJlc3VsdCA8IDApIHRocm93ICRSYW5nZUVycm9yJDEoXCJUaGUgYXJndW1lbnQgY2FuJ3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSB0b1Bvc2l0aXZlSW50ZWdlciQxO1xuXG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xuXG52YXIgdG9PZmZzZXQkMiA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgdmFyIG9mZnNldCA9IHRvUG9zaXRpdmVJbnRlZ2VyKGl0KTtcbiAgaWYgKG9mZnNldCAlIEJZVEVTKSB0aHJvdyAkUmFuZ2VFcnJvcignV3Jvbmcgb2Zmc2V0Jyk7XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuXG52YXIgY2xhc3NvZiQzID0gY2xhc3NvZlJhdyQxO1xuXG4vLyBgSXNBcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWFycmF5LWlzYXJyYXkgLS0gc2FmZVxudmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmd1bWVudCkge1xuICByZXR1cm4gY2xhc3NvZiQzKGFyZ3VtZW50KSA9PSAnQXJyYXknO1xufTtcblxudmFyIGlzQXJyYXkgPSBpc0FycmF5JDE7XG52YXIgaXNDb25zdHJ1Y3RvciA9IGlzQ29uc3RydWN0b3IkMjtcbnZhciBpc09iamVjdCQyID0gaXNPYmplY3QkZDtcbnZhciB3ZWxsS25vd25TeW1ib2wkMSA9IHdlbGxLbm93blN5bWJvbCRqO1xuXG52YXIgU1BFQ0lFUyQxID0gd2VsbEtub3duU3ltYm9sJDEoJ3NwZWNpZXMnKTtcbnZhciAkQXJyYXkgPSBBcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5KG9yaWdpbmFsQXJyYXkpKSB7XG4gICAgQyA9IG9yaWdpbmFsQXJyYXkuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAoaXNDb25zdHJ1Y3RvcihDKSAmJiAoQyA9PT0gJEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdCQyKEMpKSB7XG4gICAgICBDID0gQ1tTUEVDSUVTJDFdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyAkQXJyYXkgOiBDO1xufTtcblxudmFyIGFycmF5U3BlY2llc0NvbnN0cnVjdG9yID0gYXJyYXlTcGVjaWVzQ29uc3RydWN0b3IkMTtcblxuLy8gYEFycmF5U3BlY2llc0NyZWF0ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXksIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChhcnJheVNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbEFycmF5KSkobGVuZ3RoID09PSAwID8gMCA6IGxlbmd0aCk7XG59O1xuXG52YXIgYmluZCA9IGZ1bmN0aW9uQmluZENvbnRleHQ7XG52YXIgdW5jdXJyeVRoaXMkNSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgdG9PYmplY3QgPSB0b09iamVjdCQ3O1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDEgPSBsZW5ndGhPZkFycmF5TGlrZSQ4O1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IGFycmF5U3BlY2llc0NyZWF0ZSQxO1xuXG52YXIgcHVzaCQxID0gdW5jdXJyeVRoaXMkNShbXS5wdXNoKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGZvckVhY2gsIG1hcCwgZmlsdGVyLCBzb21lLCBldmVyeSwgZmluZCwgZmluZEluZGV4LCBmaWx0ZXJSZWplY3QgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCQxID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBJU19GSUxURVJfUkVKRUNUID0gVFlQRSA9PSA3O1xuICB2YXIgTk9fSE9MRVMgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQxKHNlbGYpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgICB2YXIgdGFyZ2V0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSIHx8IElTX0ZJTFRFUl9SRUpFQ1QgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWx1ZSwgcmVzdWx0O1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHRhcmdldFtpbmRleF0gPSByZXN1bHQ7IC8vIG1hcFxuICAgICAgICBlbHNlIGlmIChyZXN1bHQpIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgMzogcmV0dXJuIHRydWU7ICAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsdWU7ICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAgLy8gZmluZEluZGV4XG4gICAgICAgICAgY2FzZSAyOiBwdXNoJDEodGFyZ2V0LCB2YWx1ZSk7ICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBmYWxzZTsgICAgICAgICAgICAgLy8gZXZlcnlcbiAgICAgICAgICBjYXNlIDc6IHB1c2gkMSh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJSZWplY3RcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuICB9O1xufTtcblxudmFyIGFycmF5SXRlcmF0aW9uID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG4gIGZvckVhY2g6IGNyZWF0ZU1ldGhvZCQxKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuICBtYXA6IGNyZWF0ZU1ldGhvZCQxKDEpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCQxKDIpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb21lXG4gIHNvbWU6IGNyZWF0ZU1ldGhvZCQxKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgZXZlcnk6IGNyZWF0ZU1ldGhvZCQxKDQpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCQxKDUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuICBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCQxKDYpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmZpbHRlclJlamVjdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWFycmF5LWZpbHRlcmluZ1xuICBmaWx0ZXJSZWplY3Q6IGNyZWF0ZU1ldGhvZCQxKDcpXG59O1xuXG52YXIgaXNDYWxsYWJsZSQxID0gaXNDYWxsYWJsZSRuO1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCRkO1xudmFyIHNldFByb3RvdHlwZU9mJDEgPSBvYmplY3RTZXRQcm90b3R5cGVPZjtcblxuLy8gbWFrZXMgc3ViY2xhc3Npbmcgd29yayBjb3JyZWN0IGZvciB3cmFwcGVkIGJ1aWx0LWluc1xudmFyIGluaGVyaXRJZlJlcXVpcmVkJDEgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gIHZhciBOZXdUYXJnZXQsIE5ld1RhcmdldFByb3RvdHlwZTtcbiAgaWYgKFxuICAgIC8vIGl0IGNhbiB3b3JrIG9ubHkgd2l0aCBuYXRpdmUgYHNldFByb3RvdHlwZU9mYFxuICAgIHNldFByb3RvdHlwZU9mJDEgJiZcbiAgICAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgaXNDYWxsYWJsZSQxKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSAmJlxuICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuICAgIGlzT2JqZWN0JDEoTmV3VGFyZ2V0UHJvdG90eXBlID0gTmV3VGFyZ2V0LnByb3RvdHlwZSkgJiZcbiAgICBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlXG4gICkgc2V0UHJvdG90eXBlT2YkMSgkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiAgcmV0dXJuICR0aGlzO1xufTtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJHQ7XG52YXIgY2FsbCQ0ID0gZnVuY3Rpb25DYWxsO1xudmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG52YXIgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyA9IHR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNSZXF1aXJlV3JhcHBlcnM7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSQ0ID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciBBcnJheUJ1ZmZlck1vZHVsZSA9IGFycmF5QnVmZmVyO1xudmFyIGFuSW5zdGFuY2UgPSBhbkluc3RhbmNlJDM7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDU7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkODtcbnZhciBpc0ludGVncmFsTnVtYmVyID0gaXNJbnRlZ3JhbE51bWJlciQxO1xudmFyIHRvTGVuZ3RoJDEgPSB0b0xlbmd0aCQ2O1xudmFyIHRvSW5kZXggPSB0b0luZGV4JDI7XG52YXIgdG9PZmZzZXQkMSA9IHRvT2Zmc2V0JDI7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IHRvUHJvcGVydHlLZXkkNDtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGNsYXNzb2YkMiA9IGNsYXNzb2YkOTtcbnZhciBpc09iamVjdCA9IGlzT2JqZWN0JGQ7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQzO1xudmFyIGNyZWF0ZSA9IG9iamVjdENyZWF0ZTtcbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBzZXRQcm90b3R5cGVPZiA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzLmY7XG52YXIgdHlwZWRBcnJheUZyb20gPSB0eXBlZEFycmF5RnJvbSQyO1xudmFyIGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIHNldFNwZWNpZXMgPSBzZXRTcGVjaWVzJDI7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IGludGVybmFsU3RhdGU7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSBpbmhlcml0SWZSZXF1aXJlZCQxO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIFJhbmdlRXJyb3IkMiA9IGdsb2JhbCQ0LlJhbmdlRXJyb3I7XG52YXIgQXJyYXlCdWZmZXIkMSA9IEFycmF5QnVmZmVyTW9kdWxlLkFycmF5QnVmZmVyO1xudmFyIEFycmF5QnVmZmVyUHJvdG90eXBlID0gQXJyYXlCdWZmZXIkMS5wcm90b3R5cGU7XG52YXIgRGF0YVZpZXckMSA9IEFycmF5QnVmZmVyTW9kdWxlLkRhdGFWaWV3O1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuVFlQRURfQVJSQVlfVEFHO1xudmFyIFR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDQuVHlwZWRBcnJheTtcbnZhciBUeXBlZEFycmF5UHJvdG90eXBlID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQ0LlR5cGVkQXJyYXlQcm90b3R5cGU7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xudmFyIGlzVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUkNC5pc1R5cGVkQXJyYXk7XG52YXIgQllURVNfUEVSX0VMRU1FTlQgPSAnQllURVNfUEVSX0VMRU1FTlQnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGgnO1xuXG52YXIgZnJvbUxpc3QgPSBmdW5jdGlvbiAoQywgbGlzdCkge1xuICBhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgQyhsZW5ndGgpO1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIGFkZEdldHRlciA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KGl0LCBrZXksIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcylba2V5XTtcbiAgfSB9KTtcbn07XG5cbnZhciBpc0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBrbGFzcztcbiAgcmV0dXJuIGlzUHJvdG90eXBlT2YoQXJyYXlCdWZmZXJQcm90b3R5cGUsIGl0KSB8fCAoa2xhc3MgPSBjbGFzc29mJDIoaXQpKSA9PSAnQXJyYXlCdWZmZXInIHx8IGtsYXNzID09ICdTaGFyZWRBcnJheUJ1ZmZlcic7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5SW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIGlzVHlwZWRBcnJheSh0YXJnZXQpXG4gICAgJiYgIWlzU3ltYm9sKGtleSlcbiAgICAmJiBrZXkgaW4gdGFyZ2V0XG4gICAgJiYgaXNJbnRlZ3JhbE51bWJlcigra2V5KVxuICAgICYmIGtleSA+PSAwO1xufTtcblxudmFyIHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIHtcbiAga2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuICByZXR1cm4gaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkpXG4gICAgPyBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMiwgdGFyZ2V0W2tleV0pXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xufTtcblxudmFyIHdyYXBwZWREZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKSB7XG4gIGtleSA9IHRvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGlzVHlwZWRBcnJheUluZGV4KHRhcmdldCwga2V5KVxuICAgICYmIGlzT2JqZWN0KGRlc2NyaXB0b3IpXG4gICAgJiYgaGFzT3duKGRlc2NyaXB0b3IsICd2YWx1ZScpXG4gICAgJiYgIWhhc093bihkZXNjcmlwdG9yLCAnZ2V0JylcbiAgICAmJiAhaGFzT3duKGRlc2NyaXB0b3IsICdzZXQnKVxuICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgJiYgKCFoYXNPd24oZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAmJiAoIWhhc093bihkZXNjcmlwdG9yLCAnZW51bWVyYWJsZScpIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSlcbiAgKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbn07XG5cbmlmIChERVNDUklQVE9SUykge1xuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9IHdyYXBwZWREZWZpbmVQcm9wZXJ0eTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZU9mZnNldCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnbGVuZ3RoJyk7XG4gIH1cblxuICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGRlZmluZVByb3BlcnR5OiB3cmFwcGVkRGVmaW5lUHJvcGVydHlcbiAgfSk7XG5cbiAgdHlwZWRBcnJheUNvbnN0cnVjdG9yLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgd3JhcHBlciwgQ0xBTVBFRCkge1xuICAgIHZhciBCWVRFUyA9IFRZUEUubWF0Y2goL1xcZCskLylbMF0gLyA4O1xuICAgIHZhciBDT05TVFJVQ1RPUl9OQU1FID0gVFlQRSArIChDTEFNUEVEID8gJ0NsYW1wZWQnIDogJycpICsgJ0FycmF5JztcbiAgICB2YXIgR0VUVEVSID0gJ2dldCcgKyBUWVBFO1xuICAgIHZhciBTRVRURVIgPSAnc2V0JyArIFRZUEU7XG4gICAgdmFyIE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbCQ0W0NPTlNUUlVDVE9SX05BTUVdO1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgcmV0dXJuIGRhdGEudmlld1tHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gcm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweEZGID8gMHhGRiA6IHZhbHVlICYgMHhGRjtcbiAgICAgIGRhdGEudmlld1tTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGg7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIkMShieXRlTGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGRhdGEpKSB7XG4gICAgICAgICAgYnVmZmVyID0gZGF0YTtcbiAgICAgICAgICBieXRlT2Zmc2V0ID0gdG9PZmZzZXQkMShvZmZzZXQsIEJZVEVTKTtcbiAgICAgICAgICB2YXIgJGxlbiA9IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICBpZiAoJGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoJGxlbiAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yJDIoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvciQyKFdST05HX0xFTkdUSCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSB0b0xlbmd0aCQxKCRsZW5ndGgpICogQllURVM7XG4gICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCArIGJ5dGVPZmZzZXQgPiAkbGVuKSB0aHJvdyBSYW5nZUVycm9yJDIoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBjYWxsJDQodHlwZWRBcnJheUZyb20sIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcbiAgICAgICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgIHZpZXc6IG5ldyBEYXRhVmlldyQxKGJ1ZmZlcilcbiAgICAgICAgfSk7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkgYWRkRWxlbWVudCh0aGF0LCBpbmRleCsrKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGRhdGEsIHR5cGVkQXJyYXlPZmZzZXQsICRsZW5ndGgpIHtcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRJZlJlcXVpcmVkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KGRhdGEpKSByZXR1cm4gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvcih0b0luZGV4KGRhdGEpKTtcbiAgICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEsIHRvT2Zmc2V0JDEodHlwZWRBcnJheU9mZnNldCwgQllURVMpLCAkbGVuZ3RoKVxuICAgICAgICAgICAgOiB0eXBlZEFycmF5T2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKGRhdGEsIHRvT2Zmc2V0JDEodHlwZWRBcnJheU9mZnNldCwgQllURVMpKVxuICAgICAgICAgICAgICA6IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSk7XG4gICAgICAgICAgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkgcmV0dXJuIGZyb21MaXN0KFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgICAgcmV0dXJuIGNhbGwkNCh0eXBlZEFycmF5RnJvbSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBkYXRhKTtcbiAgICAgICAgfSgpLCBkdW1teSwgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHNldFByb3RvdHlwZU9mKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgVHlwZWRBcnJheSk7XG4gICAgICBmb3JFYWNoKGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSkge1xuICAgICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwga2V5LCBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3Jba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZTtcbiAgICB9XG5cbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLmNvbnN0cnVjdG9yICE9PSBUeXBlZEFycmF5Q29uc3RydWN0b3IpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBlbmZvcmNlSW50ZXJuYWxTdGF0ZShUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpLlR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgIGlmIChUWVBFRF9BUlJBWV9UQUcpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQxKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgVFlQRURfQVJSQVlfVEFHLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB9XG5cbiAgICB2YXIgRk9SQ0VEID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yICE9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgJCh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIGZvcmNlZDogRk9SQ0VELCBzaGFtOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCBleHBvcnRlZCk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShUeXBlZEFycmF5Q29uc3RydWN0b3IsIEJZVEVTX1BFUl9FTEVNRU5ULCBCWVRFUyk7XG4gICAgfVxuXG4gICAgaWYgKCEoQllURVNfUEVSX0VMRU1FTlQgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEoVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlLCBCWVRFU19QRVJfRUxFTUVOVCwgQllURVMpO1xuICAgIH1cblxuICAgIHNldFNwZWNpZXMoQ09OU1RSVUNUT1JfTkFNRSk7XG4gIH07XG59IGVsc2UgdHlwZWRBcnJheUNvbnN0cnVjdG9yLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbnZhciBjcmVhdGVUeXBlZEFycmF5Q29uc3RydWN0b3IgPSB0eXBlZEFycmF5Q29uc3RydWN0b3IuZXhwb3J0cztcblxuLy8gYFVpbnQ4QXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xuY3JlYXRlVHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50OCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OEFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMjtcblxudmFyICRUeXBlRXJyb3IkMSA9IFR5cGVFcnJvcjtcblxuLy8gYFRvQmlnSW50YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9iaWdpbnRcbnZhciB0b0JpZ0ludCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBwcmltID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdudW1iZXInKTtcbiAgaWYgKHR5cGVvZiBwcmltID09ICdudW1iZXInKSB0aHJvdyAkVHlwZUVycm9yJDEoXCJDYW4ndCBjb252ZXJ0IG51bWJlciB0byBiaWdpbnRcIik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy14L25vLWJpZ2ludCAtLSBzYWZlXG4gIHJldHVybiBCaWdJbnQocHJpbSk7XG59O1xuXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSQzID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciAkZmlsbCA9IGFycmF5RmlsbCQxO1xudmFyIHRvQmlnSW50ID0gdG9CaWdJbnQkMTtcbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJDk7XG52YXIgY2FsbCQzID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJDQgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJDUgPSBmYWlscyRzO1xuXG52YXIgYVR5cGVkQXJyYXkkMyA9IEFycmF5QnVmZmVyVmlld0NvcmUkMy5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDMgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDMuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBzbGljZSA9IHVuY3VycnlUaGlzJDQoJycuc2xpY2UpO1xuXG4vLyBWOCB+IENocm9tZSA8IDU5LCBTYWZhcmkgPCAxNC4xLCBGRiA8IDU1LCBFZGdlIDw9MThcbnZhciBDT05WRVJTSU9OX0JVRyA9IGZhaWxzJDUoZnVuY3Rpb24gKCkge1xuICB2YXIgY291bnQgPSAwO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby10eXBlZC1hcnJheXMgLS0gc2FmZVxuICBuZXcgSW50OEFycmF5KDIpLmZpbGwoeyB2YWx1ZU9mOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3VudCsrOyB9IH0pO1xuICByZXR1cm4gY291bnQgIT09IDE7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuZmlsbFxuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCQzKCdmaWxsJywgZnVuY3Rpb24gZmlsbCh2YWx1ZSAvKiAsIHN0YXJ0LCBlbmQgKi8pIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGFUeXBlZEFycmF5JDModGhpcyk7XG4gIHZhciBhY3R1YWxWYWx1ZSA9IHNsaWNlKGNsYXNzb2YkMSh0aGlzKSwgMCwgMykgPT09ICdCaWcnID8gdG9CaWdJbnQodmFsdWUpIDogK3ZhbHVlO1xuICByZXR1cm4gY2FsbCQzKCRmaWxsLCB0aGlzLCBhY3R1YWxWYWx1ZSwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG59LCBDT05WRVJTSU9OX0JVRyk7XG5cbnZhciBnbG9iYWwkMyA9IGdsb2JhbCR0O1xudmFyIGNhbGwkMiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlJDIgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gbGVuZ3RoT2ZBcnJheUxpa2UkODtcbnZhciB0b09mZnNldCA9IHRvT2Zmc2V0JDI7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9PYmplY3QkNztcbnZhciBmYWlscyQ0ID0gZmFpbHMkcztcblxudmFyIFJhbmdlRXJyb3IkMSA9IGdsb2JhbCQzLlJhbmdlRXJyb3I7XG52YXIgSW50OEFycmF5JDIgPSBnbG9iYWwkMy5JbnQ4QXJyYXk7XG52YXIgSW50OEFycmF5UHJvdG90eXBlID0gSW50OEFycmF5JDIgJiYgSW50OEFycmF5JDIucHJvdG90eXBlO1xudmFyICRzZXQgPSBJbnQ4QXJyYXlQcm90b3R5cGUgJiYgSW50OEFycmF5UHJvdG90eXBlLnNldDtcbnZhciBhVHlwZWRBcnJheSQyID0gQXJyYXlCdWZmZXJWaWV3Q29yZSQyLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMiA9IEFycmF5QnVmZmVyVmlld0NvcmUkMi5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xuXG52YXIgV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRUVSSUNfT05fVFlQRURfQVJSQVlTID0gIWZhaWxzJDQoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMteC9uby10eXBlZC1hcnJheXMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDIpO1xuICBjYWxsJDIoJHNldCwgYXJyYXksIHsgbGVuZ3RoOiAxLCAwOiAzIH0sIDEpO1xuICByZXR1cm4gYXJyYXlbMV0gIT09IDM7XG59KTtcblxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MTEyOTQgYW5kIG90aGVyXG52YXIgVE9fT0JKRUNUX0JVRyA9IFdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUyAmJiBBcnJheUJ1ZmZlclZpZXdDb3JlJDIuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBmYWlscyQ0KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gbmV3IEludDhBcnJheSQyKDIpO1xuICBhcnJheS5zZXQoMSk7XG4gIGFycmF5LnNldCgnMicsIDEpO1xuICByZXR1cm4gYXJyYXlbMF0gIT09IDAgfHwgYXJyYXlbMV0gIT09IDI7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2V0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zZXRcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QkMignc2V0JywgZnVuY3Rpb24gc2V0KGFycmF5TGlrZSAvKiAsIG9mZnNldCAqLykge1xuICBhVHlwZWRBcnJheSQyKHRoaXMpO1xuICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDEpO1xuICB2YXIgc3JjID0gdG9JbmRleGVkT2JqZWN0KGFycmF5TGlrZSk7XG4gIGlmIChXT1JLU19XSVRIX09CSkVDVFNfQU5EX0dFRVJJQ19PTl9UWVBFRF9BUlJBWVMpIHJldHVybiBjYWxsJDIoJHNldCwgdGhpcywgc3JjLCBvZmZzZXQpO1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShzcmMpO1xuICB2YXIgaW5kZXggPSAwO1xuICBpZiAobGVuICsgb2Zmc2V0ID4gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yJDEoJ1dyb25nIGxlbmd0aCcpO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xufSwgIVdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VFUklDX09OX1RZUEVEX0FSUkFZUyB8fCBUT19PQkpFQ1RfQlVHKTtcblxudmFyIGFycmF5U2xpY2UkMiA9IGFycmF5U2xpY2VTaW1wbGU7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKFxuICAgIGFycmF5LFxuICAgIG1lcmdlU29ydChhcnJheVNsaWNlJDIoYXJyYXksIDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5U2xpY2UkMihhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBjb21wYXJlZm5cbiAgKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aClcbiAgICAgID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdXG4gICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlTb3J0ID0gbWVyZ2VTb3J0O1xuXG52YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBmaXJlZm94ID0gdXNlckFnZW50JDEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XG5cbnZhciBlbmdpbmVGZlZlcnNpb24gPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG5cbnZhciBVQSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSWVPckVkZ2UgPSAvTVNJRXxUcmlkZW50Ly50ZXN0KFVBKTtcblxudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKTtcblxudmFyIGVuZ2luZVdlYmtpdFZlcnNpb24gPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdO1xuXG52YXIgZ2xvYmFsJDIgPSBnbG9iYWwkdDtcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmYWlscyQzID0gZmFpbHMkcztcbnZhciBhQ2FsbGFibGUgPSBhQ2FsbGFibGUkOTtcbnZhciBpbnRlcm5hbFNvcnQgPSBhcnJheVNvcnQ7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSQxID0gYXJyYXlCdWZmZXJWaWV3Q29yZTtcbnZhciBGRiA9IGVuZ2luZUZmVmVyc2lvbjtcbnZhciBJRV9PUl9FREdFID0gZW5naW5lSXNJZU9yRWRnZTtcbnZhciBWOCA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBXRUJLSVQgPSBlbmdpbmVXZWJraXRWZXJzaW9uO1xuXG52YXIgYVR5cGVkQXJyYXkkMSA9IEFycmF5QnVmZmVyVmlld0NvcmUkMS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kJDEgPSBBcnJheUJ1ZmZlclZpZXdDb3JlJDEuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBVaW50MTZBcnJheSA9IGdsb2JhbCQyLlVpbnQxNkFycmF5O1xudmFyIHVuJFNvcnQgPSBVaW50MTZBcnJheSAmJiB1bmN1cnJ5VGhpcyQzKFVpbnQxNkFycmF5LnByb3RvdHlwZS5zb3J0KTtcblxuLy8gV2ViS2l0XG52YXIgQUNDRVBUX0lOQ09SUkVDVF9BUkdVTUVOVFMgPSAhIXVuJFNvcnQgJiYgIShmYWlscyQzKGZ1bmN0aW9uICgpIHtcbiAgdW4kU29ydChuZXcgVWludDE2QXJyYXkoMiksIG51bGwpO1xufSkgJiYgZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIHVuJFNvcnQobmV3IFVpbnQxNkFycmF5KDIpLCB7fSk7XG59KSk7XG5cbnZhciBTVEFCTEVfU09SVCA9ICEhdW4kU29ydCAmJiAhZmFpbHMkMyhmdW5jdGlvbiAoKSB7XG4gIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIGNhbiBiZSB0b28gc2xvdywgc28gY2hlY2sgZW5naW5lcyB2ZXJzaW9uc1xuICBpZiAoVjgpIHJldHVybiBWOCA8IDc0O1xuICBpZiAoRkYpIHJldHVybiBGRiA8IDY3O1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDI7XG5cbiAgdmFyIGFycmF5ID0gbmV3IFVpbnQxNkFycmF5KDUxNik7XG4gIHZhciBleHBlY3RlZCA9IEFycmF5KDUxNik7XG4gIHZhciBpbmRleCwgbW9kO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDUxNjsgaW5kZXgrKykge1xuICAgIG1vZCA9IGluZGV4ICUgNDtcbiAgICBhcnJheVtpbmRleF0gPSA1MTUgLSBpbmRleDtcbiAgICBleHBlY3RlZFtpbmRleF0gPSBpbmRleCAtIDIgKiBtb2QgKyAzO1xuICB9XG5cbiAgdW4kU29ydChhcnJheSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgLyA0IHwgMCkgLSAoYiAvIDQgfCAwKTtcbiAgfSk7XG5cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNTE2OyBpbmRleCsrKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSAhPT0gZXhwZWN0ZWRbaW5kZXhdKSByZXR1cm4gdHJ1ZTtcbiAgfVxufSk7XG5cbnZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gK2NvbXBhcmVmbih4LCB5KSB8fCAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgaWYgKHkgIT09IHkpIHJldHVybiAtMTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmICh4ICE9PSB4KSByZXR1cm4gMTtcbiAgICBpZiAoeCA9PT0gMCAmJiB5ID09PSAwKSByZXR1cm4gMSAvIHggPiAwICYmIDEgLyB5IDwgMCA/IDEgOiAtMTtcbiAgICByZXR1cm4geCA+IHk7XG4gIH07XG59O1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zb3J0XG5leHBvcnRUeXBlZEFycmF5TWV0aG9kJDEoJ3NvcnQnLCBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZShjb21wYXJlZm4pO1xuICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiB1biRTb3J0KHRoaXMsIGNvbXBhcmVmbik7XG5cbiAgcmV0dXJuIGludGVybmFsU29ydChhVHlwZWRBcnJheSQxKHRoaXMpLCBnZXRTb3J0Q29tcGFyZShjb21wYXJlZm4pKTtcbn0sICFTVEFCTEVfU09SVCB8fCBBQ0NFUFRfSU5DT1JSRUNUX0FSR1VNRU5UUyk7XG5cbnZhciBnbG9iYWwkMSA9IGdsb2JhbCR0O1xudmFyIGFwcGx5JDEgPSBmdW5jdGlvbkFwcGx5O1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBhcnJheUJ1ZmZlclZpZXdDb3JlO1xudmFyIGZhaWxzJDIgPSBmYWlscyRzO1xudmFyIGFycmF5U2xpY2UkMSA9IGFycmF5U2xpY2UkNTtcblxudmFyIEludDhBcnJheSQxID0gZ2xvYmFsJDEuSW50OEFycmF5O1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyICR0b0xvY2FsZVN0cmluZyA9IFtdLnRvTG9jYWxlU3RyaW5nO1xuXG4vLyBpT1MgU2FmYXJpIDYueCBmYWlscyBoZXJlXG52YXIgVE9fTE9DQUxFX1NUUklOR19CVUcgPSAhIUludDhBcnJheSQxICYmIGZhaWxzJDIoZnVuY3Rpb24gKCkge1xuICAkdG9Mb2NhbGVTdHJpbmcuY2FsbChuZXcgSW50OEFycmF5JDEoMSkpO1xufSk7XG5cbnZhciBGT1JDRUQgPSBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBJbnQ4QXJyYXkkMShbMSwgMl0pLnRvTG9jYWxlU3RyaW5nKCk7XG59KSB8fCAhZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheSQxLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnRvbG9jYWxlc3RyaW5nXG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCd0b0xvY2FsZVN0cmluZycsIGZ1bmN0aW9uIHRvTG9jYWxlU3RyaW5nKCkge1xuICByZXR1cm4gYXBwbHkkMShcbiAgICAkdG9Mb2NhbGVTdHJpbmcsXG4gICAgVE9fTE9DQUxFX1NUUklOR19CVUcgPyBhcnJheVNsaWNlJDEoYVR5cGVkQXJyYXkodGhpcykpIDogYVR5cGVkQXJyYXkodGhpcyksXG4gICAgYXJyYXlTbGljZSQxKGFyZ3VtZW50cylcbiAgKTtcbn0sIEZPUkNFRCk7XG5cbmNsYXNzIFBheWxvYWQge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgLy8gVGhlIHRhZydzIHZhbHVlIGlzIGEgaGFyZGNvZGVkIHZhbHVlIGFzIHBlclxuICAgIC8vIGRlZmluZWQgaW4gdGhlIE5FUCBbTkVQNDEzXShodHRwczovL2dpdGh1Yi5jb20vbmVhci9ORVBzL2Jsb2IvbWFzdGVyL25lcHMvbmVwLTA0MTMubWQpXG4gICAgdGhpcy50YWcgPSAyMTQ3NDg0MDYxO1xuICAgIHRoaXMubWVzc2FnZSA9IGRhdGEubWVzc2FnZTtcbiAgICB0aGlzLm5vbmNlID0gZGF0YS5ub25jZTtcbiAgICB0aGlzLnJlY2lwaWVudCA9IGRhdGEucmVjaXBpZW50O1xuICAgIGlmIChkYXRhLmNhbGxiYWNrVXJsKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrVXJsID0gZGF0YS5jYWxsYmFja1VybDtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHBheWxvYWRTY2hlbWEgPSBuZXcgTWFwKFtbUGF5bG9hZCwge1xuICBraW5kOiBcInN0cnVjdFwiLFxuICBmaWVsZHM6IFtbXCJ0YWdcIiwgXCJ1MzJcIl0sIFtcIm1lc3NhZ2VcIiwgXCJzdHJpbmdcIl0sIFtcIm5vbmNlXCIsIFszMl1dLCBbXCJyZWNpcGllbnRcIiwgXCJzdHJpbmdcIl0sIFtcImNhbGxiYWNrVXJsXCIsIHtcbiAgICBraW5kOiBcIm9wdGlvblwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCJcbiAgfV1dXG59XV0pO1xuY29uc3Qgc2VyaWFsaXplTmVwNDEzID0gc2lnbk1lc3NhZ2VQYXJhbXMgPT4ge1xuICBjb25zdCBwYXlsb2FkID0gbmV3IFBheWxvYWQoT2JqZWN0LmFzc2lnbih7fSwgc2lnbk1lc3NhZ2VQYXJhbXMpKTtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZShwYXlsb2FkU2NoZW1hLCBwYXlsb2FkKSk7XG59O1xuXG5jb25zdCB2ZXJpZnlTaWduYXR1cmUgPSAoe1xuICBwdWJsaWNLZXksXG4gIHNpZ25hdHVyZSxcbiAgbWVzc2FnZSxcbiAgbm9uY2UsXG4gIHJlY2lwaWVudCxcbiAgY2FsbGJhY2tVcmxcbn0pID0+IHtcbiAgLy8gUmVjb25zdHJ1Y3QgdGhlIHBheWxvYWQgdGhhdCB3YXMgKiphY3R1YWxseSBzaWduZWQqKlxuICBjb25zdCBwYXlsb2FkID0gbmV3IFBheWxvYWQoe1xuICAgIG1lc3NhZ2UsXG4gICAgbm9uY2UsXG4gICAgcmVjaXBpZW50LFxuICAgIGNhbGxiYWNrVXJsXG4gIH0pO1xuICAvLyBTZXJpYWxpemUgcGF5bG9hZCBiYXNlZCBvbiBwYXlsb2FkU2NoZW1hXG4gIGNvbnN0IGJvcnNoUGF5bG9hZCA9IHNlcmlhbGl6ZShwYXlsb2FkU2NoZW1hLCBwYXlsb2FkKTtcbiAgLy8gSGFzaCB0aGUgcGF5bG9hZCBhcyBpbiB0aGUgTkVQMDQxMyByZWZlcmVuY2VkIGV4YW1wbGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25lYXIvTkVQcy9ibG9iL21hc3Rlci9uZXBzL25lcC0wNDEzLm1kI3JlZmVyZW5jZXNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhZ2RpZXovbmVhci1sb2dpbi9ibG9iL21haW4vYXV0aGVudGljYXRlL3dhbGxldC1hdXRoZW50aWNhdGUuanMjTDIxXG4gIGNvbnN0IGhhc2hlZFBheWxvYWQgPSBVaW50OEFycmF5LmZyb20oc2hhMjU2LmFycmF5KGJvcnNoUGF5bG9hZCkpO1xuICAvLyBDb252ZXJ0IHJlYWwgc2lnbmF0dXJlIHRvIGJ1ZmZlciBiYXNlNjRcbiAgY29uc3QgcmVhbFNpZ25hdHVyZSA9IEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSwgXCJiYXNlNjRcIik7XG4gIGNvbnN0IHBrID0gdXRpbHMuUHVibGljS2V5LmZyb20ocHVibGljS2V5KTtcbiAgLy8gVmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgcmV0dXJuIHBrLnZlcmlmeShoYXNoZWRQYXlsb2FkLCByZWFsU2lnbmF0dXJlKTtcbn07XG5jb25zdCBmZXRjaEFsbFVzZXJLZXlzID0gKHtcbiAgYWNjb3VudElkLFxuICBuZXR3b3JrLFxuICBwdWJsaWNLZXlcbn0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCBwcm92aWRlciA9IG5ldyBwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKHtcbiAgICB1cmw6IG5ldHdvcmsubm9kZVVybFxuICB9KTtcbiAgY29uc3Qga2V5ID0geWllbGQgcHJvdmlkZXIucXVlcnkoe1xuICAgIHJlcXVlc3RfdHlwZTogXCJ2aWV3X2FjY2Vzc19rZXlcIixcbiAgICBhY2NvdW50X2lkOiBhY2NvdW50SWQsXG4gICAgZmluYWxpdHk6IFwiZmluYWxcIixcbiAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXlcbiAgfSk7XG4gIHJldHVybiBrZXk7XG59KTtcbmNvbnN0IHZlcmlmeUZ1bGxLZXlCZWxvbmdzVG9Vc2VyID0gKHtcbiAgcHVibGljS2V5LFxuICBhY2NvdW50SWQsXG4gIG5ldHdvcmtcbn0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgcGVybWlzc2lvblxuICB9ID0geWllbGQgZmV0Y2hBbGxVc2VyS2V5cyh7XG4gICAgYWNjb3VudElkLFxuICAgIG5ldHdvcmssXG4gICAgcHVibGljS2V5XG4gIH0pO1xuICByZXR1cm4gcGVybWlzc2lvbiA9PT0gXCJGdWxsQWNjZXNzXCI7XG59KTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGAgc2luY2UgaXQncyBtb3ZlZCB0byBlbnRyeSBwb2ludHNcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBkZWZpbmVCdWlsdEluJDg7XG52YXIgcmVnZXhwRXhlYyQyID0gcmVnZXhwRXhlYyQzO1xudmFyIGZhaWxzJDEgPSBmYWlscyRzO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHdlbGxLbm93blN5bWJvbCRqO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ4O1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG5cbnZhciBmaXhSZWdleHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMsIEZPUkNFRCwgU0hBTSkge1xuICB2YXIgU1lNQk9MID0gd2VsbEtub3duU3ltYm9sKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMkMShmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyQxKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuXG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlYWwgcmVnZXggaGVyZSBzaW5jZSBpdCBjYXVzZXMgZGVvcHRpbWl6YXRpb25cbiAgICAgIC8vIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uIGluIFY4XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMzA2XG4gICAgICByZSA9IHt9O1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgICAgcmUuZmxhZ3MgPSAnJztcbiAgICAgIHJlW1NZTUJPTF0gPSAvLi9bU1lNQk9MXTtcbiAgICB9XG5cbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG5cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIEZPUkNFRFxuICApIHtcbiAgICB2YXIgdW5jdXJyaWVkTmF0aXZlUmVnRXhwTWV0aG9kID0gdW5jdXJyeVRoaXMkMigvLi9bU1lNQk9MXSk7XG4gICAgdmFyIG1ldGhvZHMgPSBleGVjKFNZTUJPTCwgJydbS0VZXSwgZnVuY3Rpb24gKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICB2YXIgdW5jdXJyaWVkTmF0aXZlTWV0aG9kID0gdW5jdXJyeVRoaXMkMihuYXRpdmVNZXRob2QpO1xuICAgICAgdmFyICRleGVjID0gcmVnZXhwLmV4ZWM7XG4gICAgICBpZiAoJGV4ZWMgPT09IHJlZ2V4cEV4ZWMkMiB8fCAkZXhlYyA9PT0gUmVnRXhwUHJvdG90eXBlLmV4ZWMpIHtcbiAgICAgICAgaWYgKERFTEVHQVRFU19UT19TWU1CT0wgJiYgIWZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgIC8vIFdlIGF2b2lkIGl0IGJ5IGRpcmVjdGx5IGNhbGxpbmcgdGhlIG5hdGl2ZSBAQG1ldGhvZCBtZXRob2QuXG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuY3VycmllZE5hdGl2ZVJlZ0V4cE1ldGhvZChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5jdXJyaWVkTmF0aXZlTWV0aG9kKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW4oU3RyaW5nLnByb3RvdHlwZSwgS0VZLCBtZXRob2RzWzBdKTtcbiAgICBkZWZpbmVCdWlsdEluKFJlZ0V4cFByb3RvdHlwZSwgU1lNQk9MLCBtZXRob2RzWzFdKTtcbiAgfVxuXG4gIGlmIChTSEFNKSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoUmVnRXhwUHJvdG90eXBlW1NZTUJPTF0sICdzaGFtJywgdHJ1ZSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IHRvSW50ZWdlck9ySW5maW5pdHkkNjtcbnZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckNTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG5cbnZhciBjaGFyQXQkMSA9IHVuY3VycnlUaGlzJDEoJycuY2hhckF0KTtcbnZhciBjaGFyQ29kZUF0ID0gdW5jdXJyeVRoaXMkMSgnJy5jaGFyQ29kZUF0KTtcbnZhciBzdHJpbmdTbGljZSQxID0gdW5jdXJyeVRoaXMkMSgnJy5zbGljZSk7XG5cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgcG9zKSB7XG4gICAgdmFyIFMgPSB0b1N0cmluZyQxKHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSgkdGhpcykpO1xuICAgIHZhciBwb3NpdGlvbiA9IHRvSW50ZWdlck9ySW5maW5pdHkocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0KFMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gY2hhckNvZGVBdChTLCBwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkZcbiAgICAgICAgPyBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gY2hhckF0JDEoUywgcG9zaXRpb24pXG4gICAgICAgICAgOiBmaXJzdFxuICAgICAgICA6IENPTlZFUlRfVE9fU1RSSU5HXG4gICAgICAgICAgPyBzdHJpbmdTbGljZSQxKFMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpXG4gICAgICAgICAgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxudmFyIHN0cmluZ011bHRpYnl0ZSA9IHtcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXRgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiAgY29kZUF0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5hdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUuYXRcbiAgY2hhckF0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbnZhciBjaGFyQXQgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xuXG4vLyBgQWR2YW5jZVN0cmluZ0luZGV4YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4JDEgPSBmdW5jdGlvbiAoUywgaW5kZXgsIHVuaWNvZGUpIHtcbiAgcmV0dXJuIGluZGV4ICsgKHVuaWNvZGUgPyBjaGFyQXQoUywgaW5kZXgpLmxlbmd0aCA6IDEpO1xufTtcblxudmFyIGNhbGwkMSA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQxID0gYW5PYmplY3QkZTtcbnZhciBpc0NhbGxhYmxlID0gaXNDYWxsYWJsZSRuO1xudmFyIGNsYXNzb2YgPSBjbGFzc29mUmF3JDE7XG52YXIgcmVnZXhwRXhlYyQxID0gcmVnZXhwRXhlYyQzO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWdleHBleGVjXG52YXIgcmVnZXhwRXhlY0Fic3RyYWN0ID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmIChpc0NhbGxhYmxlKGV4ZWMpKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNhbGwkMShleGVjLCBSLCBTKTtcbiAgICBpZiAocmVzdWx0ICE9PSBudWxsKSBhbk9iamVjdCQxKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSA9PT0gJ1JlZ0V4cCcpIHJldHVybiBjYWxsJDEocmVnZXhwRXhlYyQxLCBSLCBTKTtcbiAgdGhyb3cgJFR5cGVFcnJvcignUmVnRXhwI2V4ZWMgY2FsbGVkIG9uIGluY29tcGF0aWJsZSByZWNlaXZlcicpO1xufTtcblxudmFyIGFwcGx5ID0gZnVuY3Rpb25BcHBseTtcbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IGZpeFJlZ2V4cFdlbGxLbm93blN5bWJvbExvZ2ljO1xudmFyIGlzUmVnRXhwID0gaXNSZWdleHA7XG52YXIgYW5PYmplY3QgPSBhbk9iamVjdCRlO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDY7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gc3BlY2llc0NvbnN0cnVjdG9yJDM7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4JDE7XG52YXIgdG9MZW5ndGggPSB0b0xlbmd0aCQ2O1xudmFyIHRvU3RyaW5nID0gdG9TdHJpbmckNTtcbnZhciBnZXRNZXRob2QgPSBnZXRNZXRob2QkNDtcbnZhciBhcnJheVNsaWNlID0gYXJyYXlTbGljZVNpbXBsZTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlZ2V4cEV4ZWNBYnN0cmFjdDtcbnZhciByZWdleHBFeGVjID0gcmVnZXhwRXhlYyQzO1xudmFyIHN0aWNreUhlbHBlcnMgPSByZWdleHBTdGlja3lIZWxwZXJzO1xudmFyIGZhaWxzID0gZmFpbHMkcztcblxudmFyIFVOU1VQUE9SVEVEX1kgPSBzdGlja3lIZWxwZXJzLlVOU1VQUE9SVEVEX1k7XG52YXIgTUFYX1VJTlQzMiA9IDB4RkZGRkZGRkY7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgJHB1c2ggPSBbXS5wdXNoO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKCRwdXNoKTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcblxuLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4vLyBXZWV4IEpTIGhhcyBmcm96ZW4gYnVpbHQtaW4gcHJvdG90eXBlcywgc28gdXNlIHRyeSAvIGNhdGNoIHdyYXBwZXJcbnZhciBTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCAhPT0gMiB8fCByZXN1bHRbMF0gIT09ICdhJyB8fCByZXN1bHRbMV0gIT09ICdiJztcbn0pO1xuXG4vLyBAQHNwbGl0IGxvZ2ljXG5maXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYygnc3BsaXQnLCBmdW5jdGlvbiAoU1BMSVQsIG5hdGl2ZVNwbGl0LCBtYXliZUNhbGxOYXRpdmUpIHtcbiAgdmFyIGludGVybmFsU3BsaXQ7XG4gIGlmIChcbiAgICAnYWJiYycuc3BsaXQoLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWVtcHR5LWdyb3VwIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPSA0IHx8XG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPSA0IHx8XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZ2V4cC9uby1lbXB0eS1jYXB0dXJpbmctZ3JvdXAsIHJlZ2V4cC9uby1lbXB0eS1ncm91cCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDEgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtzdHJpbmddO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICByZXR1cm4gY2FsbChuYXRpdmVTcGxpdCwgc3RyaW5nLCBzZXBhcmF0b3IsIGxpbSk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IGNhbGwocmVnZXhwRXhlYywgc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleDtcbiAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICBwdXNoKG91dHB1dCwgc3RyaW5nU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkgYXBwbHkoJHB1c2gsIG91dHB1dCwgYXJyYXlTbGljZShtYXRjaCwgMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW0pIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFleGVjKHNlcGFyYXRvckNvcHksICcnKSkgcHVzaChvdXRwdXQsICcnKTtcbiAgICAgIH0gZWxzZSBwdXNoKG91dHB1dCwgc3RyaW5nU2xpY2Uoc3RyaW5nLCBsYXN0TGFzdEluZGV4KSk7XG4gICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbSA/IGFycmF5U2xpY2Uob3V0cHV0LCAwLCBsaW0pIDogb3V0cHV0O1xuICAgIH07XG4gIC8vIENoYWtyYSwgVjhcbiAgfSBlbHNlIGlmICgnMCcuc3BsaXQodW5kZWZpbmVkLCAwKS5sZW5ndGgpIHtcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHJldHVybiBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCA/IFtdIDogY2FsbChuYXRpdmVTcGxpdCwgdGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbiAgfSBlbHNlIGludGVybmFsU3BsaXQgPSBuYXRpdmVTcGxpdDtcblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogZ2V0TWV0aG9kKHNlcGFyYXRvciwgU1BMSVQpO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyXG4gICAgICAgID8gY2FsbChzcGxpdHRlciwgc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBjYWxsKGludGVybmFsU3BsaXQsIHRvU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAgIC8vIHRoZSAneScgZmxhZy5cbiAgICBmdW5jdGlvbiAoc3RyaW5nLCBsaW1pdCkge1xuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QodGhpcyk7XG4gICAgICB2YXIgUyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJ4LCBTLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gbmF0aXZlU3BsaXQpO1xuXG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHJ4LCBSZWdFeHApO1xuXG4gICAgICB2YXIgdW5pY29kZU1hdGNoaW5nID0gcngudW5pY29kZTtcbiAgICAgIHZhciBmbGFncyA9IChyeC5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4LnVuaWNvZGUgPyAndScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKFVOU1VQUE9SVEVEX1kgPyAnZycgOiAneScpO1xuXG4gICAgICAvLyBeKD8gKyByeCArICkgaXMgbmVlZGVkLCBpbiBjb21iaW5hdGlvbiB3aXRoIHNvbWUgUyBzbGljaW5nLCB0b1xuICAgICAgLy8gc2ltdWxhdGUgdGhlICd5JyBmbGFnLlxuICAgICAgdmFyIHNwbGl0dGVyID0gbmV3IEMoVU5TVVBQT1JURURfWSA/ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJyA6IHJ4LCBmbGFncyk7XG4gICAgICB2YXIgbGltID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmIChsaW0gPT09IDApIHJldHVybiBbXTtcbiAgICAgIGlmIChTLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBTKSA9PT0gbnVsbCA/IFtTXSA6IFtdO1xuICAgICAgdmFyIHAgPSAwO1xuICAgICAgdmFyIHEgPSAwO1xuICAgICAgdmFyIEEgPSBbXTtcbiAgICAgIHdoaWxlIChxIDwgUy5sZW5ndGgpIHtcbiAgICAgICAgc3BsaXR0ZXIubGFzdEluZGV4ID0gVU5TVVBQT1JURURfWSA/IDAgOiBxO1xuICAgICAgICB2YXIgeiA9IGNhbGxSZWdFeHBFeGVjKHNwbGl0dGVyLCBVTlNVUFBPUlRFRF9ZID8gc3RyaW5nU2xpY2UoUywgcSkgOiBTKTtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgKGUgPSBtaW4odG9MZW5ndGgoc3BsaXR0ZXIubGFzdEluZGV4ICsgKFVOU1VQUE9SVEVEX1kgPyBxIDogMCkpLCBTLmxlbmd0aCkpID09PSBwXG4gICAgICAgICkge1xuICAgICAgICAgIHEgPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgcSwgdW5pY29kZU1hdGNoaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdXNoKEEsIHN0cmluZ1NsaWNlKFMsIHAsIHEpKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHB1c2goQSwgeltpXSk7XG4gICAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHEgPSBwID0gZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHVzaChBLCBzdHJpbmdTbGljZShTLCBwKSk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIF07XG59LCAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDLCBVTlNVUFBPUlRFRF9ZKTtcblxudmFyIG1vZGFsJGIgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIkNvbm5lY3QgWW91ciBXYWxsZXRcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIldoYXQgaXMgYSBXYWxsZXQ/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIlNlY3VyZSAmIE1hbmFnZSBZb3VyIERpZ2l0YWwgQXNzZXRzXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiU2FmZWx5IHN0b3JlIGFuZCB0cmFuc2ZlciB5b3VyIGNyeXB0byBhbmQgTkZUcy5cIixcblx0XHRsb2dJblRvQW55OiBcIkxvZyBJbiB0byBBbnkgTkVBUiBBcHBcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJObyBuZWVkIHRvIGNyZWF0ZSBuZXcgYWNjb3VudHMgb3IgY3JlZGVudGlhbHMuIENvbm5lY3QgeW91ciB3YWxsZXQgYW5kIHlvdSBhcmUgZ29vZCB0byBnbyFcIixcblx0XHRnZXRBV2FsbGV0OiBcIkdldCBhIFdhbGxldFwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiVXNlIGEgd2FsbGV0IHRvIHNlY3VyZSBhbmQgbWFuYWdlIHlvdXIgTkVBUiBhc3NldHMsIGFuZCB0byBsb2cgaW4gdG8gYW55IE5FQVIgYXBwIHdpdGhvdXQgdGhlIG5lZWQgZm9yIHVzZXJuYW1lcyBhbmQgcGFzc3dvcmRzLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiQ29ubmVjdGlvbiBGYWlsZWRcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJDb25uZWN0aW9uIFN1Y2Nlc3NmdWxcIixcblx0XHRjb25uZWN0ZWQ6IFwiQ29ubmVjdGVkXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIkNvbm5lY3RpbmcgdG9cIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiQ29uZmlybSB0aGUgY29ubmVjdGlvbiBpbiB0aGUgZXh0ZW5zaW9uIHdpbmRvd1wiLFxuXHRcdFx0YnJvd3NlcjogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSB3YWxsZXQgYWZ0ZXIgcmVkaXJlY3RcIixcblx0XHRcdGhhcmR3YXJlOiBcIkNvbmZpcm0gdGhlIGNvbm5lY3Rpb24gaW4gdGhlIGxlZGdlciBkZXZpY2VcIixcblx0XHRcdGJyaWRnZTogXCJDb25maXJtIHRoZSBjb25uZWN0aW9uIGluIHRoZSB3YWxsZXRcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiQ29ubmVjdCB3aXRoIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJNYWtlIHN1cmUgeW91ciBMZWRnZXIgaXMgY29ubmVjdGVkIHNlY3VyZWx5LCBhbmQgdGhhdCB0aGUgTkVBUiBhcHAgaXMgb3BlbiBvbiB5b3VyIGRldmljZVwiLFxuXHRcdFwiY29udGludWVcIjogXCJDb250aW51ZVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiU3BlY2lmeSBIRCBQYXRoXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIkVudGVyIHlvdXIgcHJlZmVycmVkIEhEIHBhdGgsIHRoZW4gc2NhbiBmb3IgYW55IGFjdGl2ZSBhY2NvdW50cy5cIixcblx0XHRzY2FuOiBcIlNjYW5cIixcblx0XHRyZXRyeTogXCJSZXRyeVwiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkxlZGdlciBpcyBub3QgYXZhaWxhYmxlXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiQWNjZXNzIGRlbmllZCB0byB1c2UgTGVkZ2VyIGRldmljZVwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCJObyBBY2NvdW50cyBGb3VuZFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJTZWxlY3QgWW91ciBBY2NvdW50c1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJDb25uZWN0aW5nIDEgQWNjb3VudFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJDYW4ndCBmaW5kIGFueSBhY2NvdW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIExlZGdlci4gUGxlYXNlIGNyZWF0ZSBhIG5ldyBORUFSIGFjY291bnQgb25cIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwib3IgY29ubmVjdCBhbiBhbm90aGVyIExlZGdlci5cIixcblx0XHRjb25uZWN0aW5nOiBcIkNvbm5lY3RpbmdcIixcblx0XHRvZkFjY291bnRzOiBcIm9mIEFjY291bnRzXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIkZhaWxlZCB0byBhdXRvbWF0aWNhbGx5IGZpbmQgYWNjb3VudCBpZC4gUHJvdmlkZSBpdCBtYW51YWxseTpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiT3ZlcnZpZXcgdGhlIGxpc3Qgb2YgYXV0aG9yaXplZCBhY2NvdW50KHMpLCBjb21wbGV0ZSBzaWduIGluIGJ5IGNsaWNraW5nIHRoZSBidXR0b24gYmVsb3cuXCIsXG5cdFx0ZmluaXNoOiBcIkZpbmlzaFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwiWW91J2xsIG5lZWQgdG8gaW5zdGFsbFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwidG8gY29udGludWUuIEFmdGVyIGluc3RhbGxpbmdcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCJyZWZyZXNoIHRoZSBwYWdlLlwiLFxuXHRcdG9wZW46IFwiT3BlblwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwiQ29waWVkIHRvIGNsaXBib2FyZFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJGYWlsZWQgdG8gY29weSB0byBjbGlwYm9hcmRcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiU2NhbiB3aXRoIFlvdXIgTW9iaWxlIERldmljZVwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgQ29weSB0byBjbGlwYm9hcmRcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJQcmVmZXIgdGhlIG9mZmljaWFsIGRpYWxvZ3VlIG9mXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIkNob29zZSBhIFdhbGxldFwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcIlRyYW5zZmVyIFlvdXIgQWNjb3VudHNcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIlNlbGVjdCBhIHdhbGxldCB0aGF0IGZpdHMgeW91ciBuZWVkcyBhbmQgc3VwcG9ydHMgeW91ciBjb25uZWN0ZWQgYWNjb3VudHMuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIlNlbGVjdCBZb3VyIEFjY291bnRzXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiQWZ0ZXIgeW91IGRlY2lkZSBvbiBhIHdhbGxldCwgeW91IGNhbiBzZWxlY3Qgd2hpY2ggYWNjb3VudHMgeW91IHdhbnQgdG8gdHJhbnNmZXIuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJZb3Ugd29u4oCZdCBiZSBhYmxlIHRvIHRyYW5zZmVyIGFjY291bnRzIHRoYXQgaGF2ZSBuZXZlciBiZWVuIGZ1bmRlZCBvciB1c2VkIG9uIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCJkb2VzIG5vdCBzdXBwb3J0IGFjY291bnQgZXhwb3J0IGF0IHRoaXMgdGltZS4gUGxlYXNlIHNlbGVjdCBhbm90aGVyIHdhbGxldC5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIlNlbGVjdCBBY2NvdW50cyB0byBUcmFuc2ZlclwiLFxuXHRcdFx0YnV0dG9uOiBcIkNvbnRpbnVlXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCJEZXNlbGVjdCBBbGxcIixcblx0XHRcdHNlbGVjdEFsbDogXCJTZWxlY3QgQWxsXCIsXG5cdFx0XHR1bmF2YWlsYWJsZTogXCJUcmFuc2ZlciBVbmF2YWlsYWJsZVwiLFxuXHRcdFx0ZXJyb3I6IFwiQWNjb3VudCBkb2VzIG5vdCBleGlzdFwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJMZWRnZXIgc3VwcG9ydCByZXF1aXJlZFwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIkFjY291bnQgbm90IGZ1bmRlZFwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCJDb3B5IFRlbXBvcmFyeSBQYXNzd29yZFwiLFxuXHRcdFx0ZGVzYzogXCJZb3XigJlsbCBuZWVkIHRvIGVudGVyIHRoaXMgcGFzc3dvcmQgd2hlbiB5b3UgYmVnaW4gZXhwb3J0aW5nIHlvdXIgYWNjb3VudHMgdG8gYSBkaWZmZXJlbnQgd2FsbGV0LlwiLFxuXHRcdFx0YnV0dG9uOiBcIkNvbnRpbnVlXCIsXG5cdFx0XHR0cmFuc2ZlckJ1dHRvbjogXCJUcmFuc2ZlciBBY2NvdW50c1wiLFxuXHRcdFx0bGFiZWw6IFwiQ2xpY2sgdG8gQ29weVwiLFxuXHRcdFx0Y2hlY2tMYWJlbDogXCJJIGNvcGllZCBvciB3cm90ZSBkb3duIHRoZSBwYXNzd29yZFwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiQ29tcGxldGUgdGhlIFRyYW5zZmVyXCIsXG5cdFx0XHRkZXNjT25lOiBcIllvdSB3aWxsIG5vdyBiZSByZWRpcmVjdGVkIHRvIHRoZSB3YWxsZXQgeW91IHNlbGVjdGVkIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2Zlci5cIixcblx0XHRcdGRlc2NUd286IFwiT25jZSBpbXBvcnQgcGFydCBvZiBwcm9jZXNzIGlzIGNvbXBsZXRlZCBmcm9tIHNlbGVjdGVkIHdhbGxldCwgcHJlc3MgYnV0dG9uIHRvIGNvbXBsZXRlIHRoZSB0cmFuc2ZlciBwcm9jZXNzLlwiLFxuXHRcdFx0c3RhcnRPdmVyQnV0dG9uOiBcIlN0YXJ0IE92ZXJcIixcblx0XHRcdGJ1dHRvbjogXCJDb21wbGV0ZVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIGNvbXBvbmVudCQxID0ge1xuXHRjbGlja1RvQ29weToge1xuXHRcdGxhYmVsOiBcIkNvcGllZFwiLFxuXHRcdHRvb2x0aXA6IFwiQ2xpY2sgdG8gY29weVwiXG5cdH1cbn07XG52YXIgZW4gPSB7XG5cdG1vZGFsOiBtb2RhbCRiLFxuXHRjb21wb25lbnQ6IGNvbXBvbmVudCQxXG59O1xuXG52YXIgbW9kYWwkYSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwiQ29uZWN0YSBUdSBCaWxsZXRlcmFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIsK/UXVlIGVzIHVuYSBCaWxsZXRlcmE/XCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIlJlc2d1YXJkYSB5IEFkbWluaXN0cmFyIFR1cyBBY3Rpdm9zIERpZ2l0YWxlc1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcIkFsbWFjZW5hIGRlIGZvcm1hIHNlZ3VyYSB5IHRyYW5zZmllcmUgdHVzIGNyeXB0b3MgeSBORlQnc1wiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiSW5pY2llIHNlc2nDs24gZW4gQ3VhbHF1aWVyIEFwbGljYWNpb24gTkVBUlwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIk5vIGVzIG5lY2VzYXJpbyBjcmVhciBudWV2YXMgY3VlbnRhcyBvIGNyZWRlbmNpYWxlcywgwqFDb25lY3RhIHR1IGJpbGxldGVyYSB5IGxpc3RvIVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiT2J0ZW4gdW5hIEJpbGxldGVyYVwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwiVXNhIHR1IEJpbGxldGVyYSBwYXJhIHJlc2d1YXJkYXIgeSBhZG1pbmlzdHJhciB0dXMgYWN0aXZvcyBlbiBORUFSLCBlIEluaWNpYXIgc2VzacOzbiBlbiBjdWFscXVpZXIgYXBsaWNhY2lvbiBORUFSIHNpbiBsYSBuZWNlc2lkYWQgZGUgbm9tYnJlcyBkZSB1c3VhcmlvcyB5IGNvbnRyYXNlw7Fhc1wiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiQ29uZXhpw7NuIEZhbGxpZGFcIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCJDb25leGnDs24gRXhpc3Rvc2FcIixcblx0XHRjb25uZWN0ZWQ6IFwiQ29uZWN0YWRvXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcIkNvbmVjdGFuZG8gYSBcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiQ29uZmlybWUgbGEgY29uZXhpw7NuIGVuIGxhIHZlbnRhbmEgZGUgZXh0ZW5zacOzblwiLFxuXHRcdFx0YnJvd3NlcjogXCJDb25maXJtZSBsYSBjb25leGnDs24gZW4gbGEgYmlsbGV0ZXJhIGRlc3B1w6lzIGRlIGxhIHJlZGlyZWNjacOzblwiLFxuXHRcdFx0aGFyZHdhcmU6IFwiQ29uZmlybWUgbGEgY29uZXhpw7NuIGVuIGVsIGRpc3Bvc2l0aXZvIGRlIGxpYnJvIG1heW9yXCIsXG5cdFx0XHRicmlkZ2U6IFwiQ29uZmlybWFyIGxhIGNvbmV4acOzbiBlbiBsYSBiaWxsZXRlcmFcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwiQ29uZWN0YXIgY29uIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJBc2Vnw7pyZXNlIGRlIHF1ZSBzdSBsZWRnZXIgZXN0w6EgY29uZWN0YWRhIGRlIGZvcm1hIHNlZ3VyYSB5IHF1ZSBsYSBhcGxpY2FjaW9uIE5FQVIgZXN0w6kgYWJpZXJ0YSBlbiBzdSBkaXNwb3NpdGl2b1wiLFxuXHRcdFwiY29udGludWVcIjogXCJDb250aW51YXJcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkVzcGVjaWZpcXVlIGxhIHJ1dGEgSERcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiSW5ncmVzZSBzdSBydXRhIEhEIHByZXJpZGEseSBsdWVnbyBidXNxdWUgY3VhbHF1aWVyIGN1ZW50YSBhY3RpdmEuXCIsXG5cdFx0c2NhbjogXCJFc2NhbmVhclwiLFxuXHRcdHJldHJ5OiBcIlJlaW50ZW50YXJcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJFbCBMZWRnZXIgbm8gZXN0w6EgZGlzcG9uaWJsZVwiLFxuXHRcdGFjY2Vzc0RlbmllZFRvVXNlTGVkZ2VyRGV2aWNlOiBcIkFjY2VzbyBkZW5lZ2FkbyBwYXJhIHVzYXIgZWwgZGlzcG9zaXRpdm8gbGVkZ2VyXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5vIHNlIGVuY29udHJhcm9uIGN1ZW50YXNcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiU2VsZWNjaW9uYSB0dXMgY3VlbnRhc1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJDb25lY3RhbmRvIGEgMSBjdWVudGFcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwiTm8gc2UgcHVkbyBlbmNvbnRyYXIgbmluZ3VuYSBjdWVudGEgYXNvY2lhZGEgY29uIGVzdGUgbGVkZ2VyLFBvciBmYXZvciBjcmVhIHVuYSBudWV2YSBjdWVudGEgZW4gTkVBUlwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJvIGNvbmVjdGEgb3RybyBsZWRnZXJcIixcblx0XHRjb25uZWN0aW5nOiBcIkNvbmVjdGFuZG9cIixcblx0XHRvZkFjY291bnRzOiBcImRlIEN1ZW50YXNcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwiTm8gc2UgcHVkbyBlbmNvbnRyYXIgYXV0b21hdGljYW1lbnRlIGVsIGlkIGRlIGxhIGN1ZW50YSxJbmdyZXNhbG8gbWFudWFsbWVudGU6XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIlJldmlzZSBsYSBsaXN0YSBkZSBsYXMgY3VlbnRhcyBhdXRvcml6YWRhcyxDb21wbGV0ZSBlbCBpbmljaW8gZGUgc2VzacOzbiBoYWNpZWRvIGNsaWNrIGEgY291bnRpbnVhY2lvbi5cIixcblx0XHRmaW5pc2g6IFwiRmluYWxpemFyXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJUZW5kcsOhcyBxdWUgaW5zdGFsYXJcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIlBhcmEgY29udGludWFyLCBEZXNwdWVzIGRlIGluc3RhbGFyXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwiUmVjYXJnYSBsYSBwYWdpbmFcIixcblx0XHRvcGVuOiBcIkFicmlyXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJDb3BpYWRvIGFsIFBvcnRhcGFwZWxlc1wiLFxuXHRcdGZhaWxlZFRvQ29weTogXCJGYWxsw7MgbGEgY29waWEgYWwgUG9ydGFwYXBlbGVzXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIkJ1c2NhIGNvbiB0dSBkaXNwb3NpdGl2byBtb3ZpbFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCIgQ29waWFyIGFsIFBvcnRhcGFwZWxlc1wiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIsK/UHJlZmlyZXMgZWwgZGnDoWxvZ28gb2ZpY2lhbCBkZVwiLFxuXHRcdG9wZW46IFwiQWJyaXJcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGVzID0ge1xuXHRtb2RhbDogbW9kYWwkYVxufTtcblxudmFyIG1vZGFsJDkgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIui/nuaOpeS9oOeahOmSseWMhVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi5LuA5LmI5piv6ZKx5YyF77yfXCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcIuS/neaKpOWSjOeuoeeQhuS9oOeahOaVsOWtl+i1hOS6p1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcIuWuieWFqOWtmOWCqOWSjOi9rOenu+S9oOeahOWKoOWvhui0p+W4geWSjE5GVFwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi55m75b2V5Lu75L2VIE5FQVIg5bqU55SoXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi5LiN6ZyA6KaB5Yib5bu65paw6LSm5oi35oiW5a+G56CB44CC6L+e5o6l5L2g55qE6ZKx5YyF77yM5Y2z5Y+v5byA5aeL5L2/55So77yBXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLojrflj5bmlrDotKbmiLdcIixcblx0XHR1c2VBV2FsbGV0OiBcIuS9v+eUqOmSseWMheadpeS/neaKpOWSjOeuoeeQhuS9oOeahCBORUFSIOi1hOS6p++8jOaXoOmcgOeUqOaIt+WQjeWSjOWvhueggeWNs+WPr+eZu+W9leS7u+S9lSBORUFSIOW6lOeUqFwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi6L+e5o6l5aSx6LSlXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi6L+e5o6l5oiQ5YqfXCIsXG5cdFx0Y29ubmVjdGVkOiBcIuW3sui/nuaOpVwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLmraPlnKjov57mjqVcIlxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLov57mjqUgTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIuehruS/neS9oOeahCBMZWRnZXIg5bey57uP5a6J5YWo6L+e5o6l77yM5bm25LiUIE5FQVIg5bqU55So5bey57uP5Zyo5L2g6K6+5aSH5LiK5omT5byAXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIue7p+e7rVwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi5oyH5a6aIEhEIOi3r+W+hFwiLFxuXHRcdGVudGVyWW91clByZWZlcnJlZEhEUGF0aDogXCLovpPlhaXkvaDlgY/lpb3nmoQgSEQg6Lev5b6E77yM54S25ZCO5Li65Lu75oSP5rS76LeD6LSm5oi35omr56CBXCIsXG5cdFx0c2NhbjogXCLmiavnoIFcIixcblx0XHRyZXRyeTogXCLph43or5VcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCJMZWRnZXIg5LiN5Y+v55SoXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi6K6/6ZeuIExlZGdlciDorr7lpIfooqvmi5Lnu51cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi5rKh5pyJ5om+5Yiw6LSm5oi3XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIumAieaLqeS9oOeahOi0puaIt1wiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLmraPlnKjov57mjqUx5Liq6LSm5oi3XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIuayoeacieaJvuWIsOS7u+S9leS4jui/meS4qiBMZWRnZXIg55u45YWz6IGU55qE6LSm5oi344CC6K+35Yib5bu65paw6LSm5oi35LqOXCIsXG5cdFx0XCJvckNvbm5lY3RBbkFub3RoZXJMZWRnZXIuXCI6IFwi5oiW6L+e5o6l5Y+m5LiA5LiqIExlZGdlclwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi5q2j5Zyo6L+e5o6lXCIsXG5cdFx0b2ZBY2NvdW50czogXCLkuKrotKbmiLdcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi5peg5rOV6Ieq5Yqo5om+5Yiw6LSm5oi3SUTvvIzor7fkuLvliqjmj5DkvpvvvJpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi6K+35p+l55yL5bey5o6I5p2D55qE6LSm5oi35YiX6KGo77yM54K55Ye75Lul5LiL5oyJ6ZKu5a6M5oiQ55m75b2VXCIsXG5cdFx0ZmluaXNoOiBcIuWujOaIkFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi5L2g5bCG6ZyA6KaB5a6J6KOFXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLku6Xnu6fnu63jgILlronoo4XlroxcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLor7fliLfmlrDpobXpnaJcIixcblx0XHRvcGVuOiBcIuaJk+W8gFwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi5aSN5Yi25Yiw5LqG5Ymq6LS05p2/XCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcIuWkjeWItuWIsOWJqui0tOadv+Wksei0pVwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLnlKjkvaDnmoTnp7vliqjorr7lpIfmiavnoIFcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIOWkjeWItuWIsOWJqui0tOadv1wiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcIuW4jOacm+S9v+eUqOWumOaWueWvueivneahhuS6jlwiLFxuXHRcdG9wZW46IFwi5omT5byAXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fVxufTtcbnZhciB6aCA9IHtcblx0bW9kYWw6IG1vZGFsJDlcbn07XG5cbnZhciBtb2RhbCQ4ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLQodCy0YrRgNC20LXRgtC1INCy0LDRiNC40Y8g0J/QvtGA0YLRhNC10LnQu1wiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi0JrQsNC60LLQviDQtSDQn9C+0YDRgtGE0LXQudC7P1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCLQl9Cw0YnQuNGC0LXRgtC1INC4INGD0L/RgNCw0LLQu9GP0LLQsNC50YLQtSDQtNC40LPQuNGC0LDQu9C90LjRgtC1INGB0Lgg0LDQutGC0LjQstC4XCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi0KHRitGF0YDQsNC90Y/QstCw0LnRgtC1INC4INC/0YDQtdGF0LLRitGA0LvRj9C50YLQtSDQsdC10LfQvtC/0LDRgdC90L4g0LLQsNGI0LjRgtC1INC60YDQuNC/0YLQviDQuCBORlQuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCLQmNC30L/QvtC70LfQstCw0LnRgtC1INCy0YHRj9C60L4g0L/RgNC40LvQvtC20LXQvdC40LUg0L3QsCBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi0J3Rj9C80LAg0L3Rg9C20LTQsCDQtNCwINGB0YrQt9C00LDQstCw0YLQtSDQvdC+0LLQuCDQv9GA0L7RhNC40LvQuC4g0KHQstGK0YDQttC10YLQtSDQv9C+0YDRgtGE0LXQudC70LAg0YHQuCDQuCDRgdGC0LUg0LPQvtGC0L7QstC4IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi0KHRitC30LTQsNC50YLQtSDQn9C+0YDRgtGE0LXQudC7XCIsXG5cdFx0dXNlQVdhbGxldDogXCLQmNC30L/QvtC70LfQstCw0LnRgtC1INC/0L7RgNGC0YTQtdC50LvQsCwg0LfQsCDQtNCwINC30LDRidC40YLQuNGC0LUg0Lgg0YPQv9GA0LDQstC70Y/QstCw0YLQtSDQsNC60YLQuNCy0LjRgtC1INGB0Lgg0L3QsCBORUFSINC60LDQutGC0L4g0Lgg0LTQsCDQuNC30L/QvtC70LfQstCw0YLQtSDQstGB0Y/QutC+INC/0YDQuNC70L7QttC10L3QuNC1INC90LAgTkVBUiDQsdC10Lcg0L3Rg9C20LTQsCDQvtGCINC/0L7RgtGA0LXQsdC40YLQtdC70YHQutC4INC40LzQtdC90LAg0Lgg0L/QsNGA0L7Qu9C4LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0KHQstGK0YDQt9Cy0LDQvdC10YLQviDQvdC10YPRgdC/0LXRiNC90L5cIixcblx0XHRjb25uZWN0aW9uU3VjY2Vzc2Z1bDogXCLQodCy0YrRgNC30LLQsNC90LXRgtC+INGD0YHQv9C10YjQvdC+XCIsXG5cdFx0Y29ubmVjdGVkOiBcItCh0LLRitGA0LfQsNC9XCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItCh0LLRitGA0LfQstCw0L3QtSDQutGK0LxcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDQv9GA0L7Qt9C+0YDQtdGG0LAg0L3QsCDRgNCw0LfRiNC40YDQtdC90LjQtdGC0L5cIixcblx0XHRcdGJyb3dzZXI6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDQv9C+0YDRgtGE0LXQudC70LAg0YHQu9C10LQg0L/RgNC10L3QsNGB0L7Rh9Cy0LDQvdC10YLQvlwiLFxuXHRcdFx0aGFyZHdhcmU6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0YHQstGK0YDQt9Cy0LDQvdC10YLQviDQsiDRhdCw0YDQtNGD0LXRgNC90LjRjyDQv9C+0YDRgtGE0LXQudC7XCIsXG5cdFx0XHRicmlkZ2U6IFwi0J/QvtGC0LLRitGA0LTQtdGC0LUg0LLRgNGK0LfQutCw0YLQsCDQsiDQv9C+0YDRgtGE0LXQudC70LBcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi0KHQstGK0YDQttC10YLQtSDRgdC1INGBIExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLQo9Cy0LXRgNC10YLQtSDRgdC1LCDRh9C1INCy0LDRiNC40Y/RgiBMZWRnZXIg0LUg0YHQstGK0YDQt9Cw0L0g0Lgg0YfQtSDQv9GA0LjQu9C+0LbQtdC90LjQtdGC0L4gTkVBUiDQtSDQvtGC0LLQvtGA0LXQvdC+INC9YSDQvdC10LPQvi5cIixcblx0XHRcImNvbnRpbnVlXCI6IFwi0J/RgNC+0LTRitC70LbQtdGC0LVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItCf0L7RgdC+0YfQtdGC0LUgSEQg0L/RitGCXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCS0YrQstC10LTQtdGC0LUg0L/RgNC10LTQv9C+0YfQuNGC0LDQvdC40Y8gSEQg0L/RitGCLCDRgdC70LXQtCDQutC+0LXRgtC+INGB0LrQsNC90LjRgNCw0LnRgtC1INC30LAg0LDQutGC0LjQstC90Lgg0LDQutCw0YPQvdGC0LguXCIsXG5cdFx0c2NhbjogXCLQodC60LDQvdC40YDQsNC50YLQtVwiLFxuXHRcdHJldHJ5OiBcItCe0L/QuNGC0LDQudGC0LUg0L7RgtC90L7QstC+XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyINGD0YHRgtGA0L7QudGB0YLQstC+0YLQviDQvdC1INC1INC00L7RgdGC0YrQv9C90L5cIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCLQlNC+0YHRgtGK0L/RitGCINC30LAg0LjQt9C/0L7Qu9C30LLQsNC90LUg0L3QsCBMZWRnZXIg0LUg0L7RgtC60LDQt9Cw0L1cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3Rj9C80LAg0L3QsNC80LXRgNC10L3QuCDQv9GA0L7RhNC40LvQuFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LHQtdGA0LXRgtC1INCy0LDRiNC40YLQtSDQv9GA0L7RhNC40LvQuFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLQodCy0YrRgNC30LLQsNC90LUg0L3QsCAxINC/0YDQvtGE0LjQu1wiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCLQndGP0LzQsCDQvdCw0LzQtdGA0LXQvdC4INC/0YDQvtGE0LjQu9C4LCDRgdGK0LLRgNC30LDQvdC4INGBINGC0L7Qt9C4IExlZGdlci4g0JzQvtC70Y8sINGB0YrQt9C00LDQudGC0LUg0L3QvtCyIE5FQVIg0L/RgNC+0YTQuNC7INC90LBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INGB0LLRitGA0LbQtdGC0LUg0LTRgNGD0LMgTGVkZ2VyLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi0KHQstGK0YDQt9Cy0LDQvdC1XCIsXG5cdFx0b2ZBY2NvdW50czogXCLQvtGCINC/0YDQvtGE0LjQu9C4XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcItCQ0LLRgtC+0LzQsNGC0LjRh9C90L7RgtC+INC90LDQvNC40YDQsNC90LUg0L3QsCDQv9GA0L7RhNC40LvQsCDQvdC1INCx0LUg0YPRgdC/0LXRiNC90L4uINCS0YrQstC10LTQtdGC0LUg0LPQviDRgNGK0YfQvdC+OlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLQn9GA0LXQs9C70LXQtNCw0LnRgtC1INGB0L/QuNGB0YrQutCwINGBINGD0L/RitC70L3QvtC80L7RidC10L3QuCDQv9GA0L7RhNC40LvQuCwg0LfQsNCy0YrRgNGI0LXRgtC1INCy0LvQuNC30LDQvdC10YLQviwg0LrQsNGC0L4g0YnRgNCw0LrQvdC10YLQtSDQstGK0YDRhdGDINCx0YPRgtC+0L3QsCDQv9C+LdC00L7Qu9GDLi5cIixcblx0XHRmaW5pc2g6IFwi0JfQsNCy0YrRgNGI0LXRgtC1XCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCLQqdC1INGC0YDRj9Cx0LLQsCDQtNCwINC40L3RgdGC0LDQu9C40YDQsNGC0LVcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItC30LAg0LTQsCDQv9GA0L7QtNGK0LvQttC40YLQtS4g0KHQu9C10LQg0LjQvdGB0YLQsNC70LjRgNCw0L3QtVwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItC/0YDQtdC30LDRgNC10LTQtdGC0LUg0YHRgtGA0LDQvdC40YbQsNGC0LAuXCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LXRgtC1XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDQvdC+INCyINC60LvQuNC/0LHQvtGA0LTQsFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQndC10YPRgdC/0LXRiNC90L4g0LrQvtC/0LjRgNCw0L3QtSDQsiDQutC70LjQv9Cx0L7RgNC00LBcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiINCh0LrQsNC90LjRgNCw0LnRgtC1INGBINC80L7QsdC40LvQvdC+0YLQviDRgdC4INGD0YHRgtGA0L7QudGB0YLQstC+XCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiDQmtC+0L/QuNGA0LDQudGC0LUg0LIg0LrQu9C40L/QsdC+0YDQtNCwXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwi0J/RgNC10LTQv9C+0YfQuNGC0LDQvSDQtdC30LjQuiDQt9CwINC60L7RgNC10YHQv9C+0L3QtNC10L3RhtC40Y9cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGJnID0ge1xuXHRtb2RhbDogbW9kYWwkOFxufTtcblxudmFyIG1vZGFsJDcgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIuyngOqwkSDsl7DqsrDtlZjquLBcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIuyngOqwkeydgCDrrLTsiqgg7Jet7ZWg7J2EIO2VmOuCmOyalD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi64u57Iug7J2YIOuUlOyngO2EuCDsnpDsgrDsnYQg67O07Zi47ZWY6rOgIOq0gOumrO2VqeuLiOuLpC5cIixcblx0XHRzYWZlbHlTdG9yZTogXCLslZTtmLjtmZTtj5DsmYAgTkZU66W8IOyViOyghO2VmOqyjCDsoIDsnqXtlZjqs6Ag7KCE7Iah7ZWgIOyImCDsnojsirXri4jri6QuXCIsXG5cdFx0bG9nSW5Ub0FueTogXCJORUFSIEFwcOyXkCDroZzqt7jsnbjtlanri4jri6QuXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi7IOI66Gc7Jq0IOqzhOygleydtOuCmCDruYTrsIDrsojtmLjrpbwg66eM65OkIO2VhOyalCDsl4bsnbQg7KeA6rCR7J2EIOyXsOqysO2VnCDtm4Qg67CU66GcIOyCrOyaqe2VoCDsiJgg7J6I7Iq164uI64ukLlwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi7KeA6rCRIOqwgOyguOyYpOq4sFwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi7KeA6rCR7J2EIOyCrOyaqe2VmOyXrCBORUFSIOyekOyCsOydhCDrs7TtmLjCt+q0gOumrO2VmOqzoCwg7JWE7J2065SU7JmAIOu5hOuwgOuyiO2YuCDsl4bsnbQgTkVBUiDslbHsl5Ag66Gc6re47J247ZWgIOyImCDsnojsirXri4jri6QuXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLsl7DqsrAg7Iuk7YyoXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi7Jew6rKwIOyEseqztVwiLFxuXHRcdGNvbm5lY3RlZDogXCJDb25uZWN0ZWRcIixcblx0XHRjb25uZWN0aW5nVG86IFwi7Jew6rKwIOykkTogXCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIuydteyKpO2FkOyFmCDssL3sl5DshJwg7Jew6rKw7J2EIO2ZleyduO2VmOyEuOyalFwiLFxuXHRcdFx0YnJvd3NlcjogXCLrpqzri6TsnbTroIntirgg65CcIOyngOqwkeyXkOyEnCDsl7DqsrDsnYQg7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XHRoYXJkd2FyZTogXCJMZWRnZXIg6riw6riw7JeQ7IScIOyXsOqysOydhCDtmZXsnbjtlZjshLjsmpRcIixcblx0XHRcdGJyaWRnZTogXCLsp4DqsJHsl5DshJwg7Jew6rKwIO2ZleyduFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJMZWRnZXIg7Jew6rKw7ZWY6riwXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIkxlZGdlcuqwgCDslYjsoITtlZjqsowg7Jew6rKw65CY7Ja0IOyeiOqzoCwgTkVBUiDslbHsnbQg7Je066CkIOyeiOuKlCDsp4Ag7ZmV7J247ZWY7IS47JqUXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIuqzhOyGje2VmOq4sFwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiSEQgUGF0aCDsp4DsoJXtlZjquLBcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi7JuQ7ZWY64qUIEhEIFBhdGjrpbwg7ISg7YOd7ZWY6rOgLCDtmZzshLHtmZTrkJwg6rOE7KCV7J20IOyeiOuKlCDsp4Ag6rKA7IOJ7ZWY7IS47JqUXCIsXG5cdFx0c2NhbjogXCLqsoDsg4lcIixcblx0XHRyZXRyeTogXCLri6Tsi5wg7Iuc64+EXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2Vy66W8IOyCrOyaqe2VoCDsiJgg7JeG7Iq164uI64ukXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiTGVkZ2VyIOq4sOq4sCDsoJHqt7wg6raM7ZWc7J20IOqxsOu2gOuQmOyXiOyKteuLiOuLpFwiLFxuXHRcdG5vQWNjb3VudHNGb3VuZDogXCLqs4TsoJXsnYQg7LC+7J2EIOyImCDsl4bsirXri4jri6RcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi6rOE7KCVIOyEoO2Dne2VmOq4sFwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLtlZjrgpjsnZgg6rOE7KCV7JeQIOyXsOqysFwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJMZWRnZXLsmYAg7Jew6rKw65CcIOqzhOygleydhCDssL7snYQg7IiYIOyXhuyKteuLiOuLpC4g7IOI66Gc7Jq0IOqzhOygleydhCDsg53shLHtlZjqsbDrgpggXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcIuuLpOuluCBMZWRnZXLrpbwg7Jew6rKw7ZWY7IS47JqUXCIsXG5cdFx0Y29ubmVjdGluZzogXCLqs4TsoJUg7Jew6rKw7ZWY6riwOiBcIixcblx0XHRvZkFjY291bnRzOiBcIuqwnCDqs4TsoJXsnYQg7LC+7JWY7Iq164uI64ukXCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIuqzhOyglSBJROulvCDssL7sp4Ag66q77ZaI7Iq164uI64ukLiDsiJjrj5nsnLzroZwg7J6F66Cl7ZW07KO87IS47JqULlwiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLsnbjspp3rkJwg6rOE7KCVIOuqqeuhneydhCDtmZXsnbjtlZwg7ZuEIOyVhOuemCDrsoTtirzsnYQg7YG066at7ZWY7JesIOuhnOq3uOyduOydhCDsmYTro4ztlZjshLjsmpRcIixcblx0XHRmaW5pc2g6IFwi7JmE66OMXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCLtlZjrk5zsm6jslrQg7KeA6rCRXCIsXG5cdFx0YnJvd3NlcjogXCLruIzrnbzsmrDsoIAg7KeA6rCRXCIsXG5cdFx0aW5qZWN0ZWQ6IFwi7KeA6rCRIO2ZleyepVwiLFxuXHRcdGJyaWRnZTogXCLruIzrpqzsp4Ag7KeA6rCRXCIsXG5cdFx0bW9iaWxlOiBcIuuqqOuwlOydvCDsp4DqsJFcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIuyduOyKpO2EtO2KuCDsp4DqsJFcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIuuLpOydjCDtmZXsnqUg7ZSE66Gc6re4656o7J2EIOyEpOy5mO2VtOyjvOyEuOyalDpcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIi4g7ISk7LmYIOyZhOujjCDtm4Qg7Y6Y7J207KeAIOyDiOuhnCDqs6DsuajsnbQg7ZWE7JqU7ZWp64uI64ukLiBcIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLsg4jroZwg6rOg7LmoXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLtgbTrpr3rs7Trk5zsl5Ag67O17IKsIOyZhOujjFwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLtgbTrpr3rs7Trk5zsl5Ag67O17IKsIOyLpO2MqFwiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCLrqqjrsJTsnbwg7J6l7LmY66W8IOyCrOyaqe2VmOyXrCDsiqTsupTtlbTso7zshLjsmpRcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIO2BtOumveuztOuTnOyXkCDrs7XsgqztlZjquLBcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLri6TsnYwg7ZSE66Gc6re4656o7JeQ7IScIOygnOqzte2VmOuKlCDqs7Xsi50g7ZSE66Gc7IS47Iqk66W8IOyEoO2YuO2VmOyLreuLiOq5jDogXCIsXG5cdFx0b3BlbjogXCJPcGVuXCJcblx0fVxufTtcbnZhciBrbyA9IHtcblx0bW9kYWw6IG1vZGFsJDdcbn07XG5cbnZhciBtb2RhbCQ2ID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCJL4bq/dCBu4buRaSB2w60gY+G7p2EgYuG6oW5cIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIlbDrSBsw6AgZ8OsP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJC4bqjbyBt4bqtdCAmIFF14bqjbiBsw70gdMOgaSBz4bqjbiBz4buRIGPhu6dhIGLhuqFuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwiTMawdSB0cuG7ryB2w6AgY2h1eeG7g24gdGnhu4FuIMSRaeG7h24gdOG7rSB2w6AgTkZUIGPhu6dhIGLhuqFuIG3hu5l0IGPDoWNoIGFuIHRvw6BuLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwixJDEg25nIG5o4bqtcCB2w6BvIGLhuqV0IGvhu7Mg4bupbmcgZOG7pW5nIHRyw6puIE5FQVJcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCJLaMO0bmcgY+G6p24gdOG6oW8gdMOgaSBraG/huqNuIGhv4bq3YyB0aMO0bmcgdGluIMSRxINuZyBuaOG6rXAgbeG7m2kuIEvhur90IG7hu5FpIHbDrSBj4bunYSBi4bqhbiB2w6AgYuG6r3QgxJHhuqd1IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwiVOG6oW8gVsOtXCIsXG5cdFx0dXNlQVdhbGxldDogXCJT4butIGThu6VuZyB2w60gxJHhu4MgYuG6o28gbeG6rXQgdsOgIHF14bqjbiBsw70gdMOgaSBz4bqjbiB0csOqbiBORUFSIGPhu6dhIGLhuqFuIHbDoCDEkcSDbmcgbmjhuq1wIHbDoG8gYuG6pXQga+G7syDhu6luZyBk4bulbmcgTkVBUiBuw6BvLCBraMO0bmcgY+G6p24gdMOqbiBuZ8aw4budaSBkw7luZyB2w6AgbeG6rXQga2jhuql1LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiS+G6v3QgbuG7kWkgdGjhuqV0IGLhuqFpXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiS+G6v3QgbuG7kWkgdGjDoG5oIGPDtG5nXCIsXG5cdFx0Y29ubmVjdGVkOiBcIsSQw6Mga+G6v3QgbuG7kWlcIixcblx0XHRjb25uZWN0aW5nVG86IFwixJBhbmcga+G6v3QgbuG7kWkgdOG7m2lcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgdHJvbmcgY+G7rWEgc+G7lSB0aeG7h24gw61jaCBt4bufIHLhu5luZ1wiLFxuXHRcdFx0YnJvd3NlcjogXCJYw6FjIG5o4bqtbiBr4bq/dCBu4buRaSB0cm9uZyB2w60gc2F1IGtoaSDEkcaw4bujYyBjaHV54buDbiBoxrDhu5tuZ1wiLFxuXHRcdFx0aGFyZHdhcmU6IFwiWMOhYyBuaOG6rW4ga+G6v3QgbuG7kWkgduG7m2kgdsOtIGzhuqFuaFwiLFxuXHRcdFx0YnJpZGdlOiBcIljDoWMgbmjhuq1uIGvhur90IG7hu5FpIHRyb25nIHbDrVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJL4bq/dCBu4buRaSB2w60gTGVkZ2VyXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcIsSQ4bqjbSBi4bqjbyBMZWRnZXIgY+G7p2EgYuG6oW4gxJHGsOG7o2Mga+G6v3QgbuG7kWkgYW4gdG/DoG4gdsOgIOG7qW5nIGThu6VuZyBORUFSIMSRYW5nIG3hu58gc+G6tW4gdHLDqm4gdGhp4bq/dCBi4buLXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcIlRp4bq/cCB04bulY1wiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwiQ2jhu4kgxJHhu4tuaCBIRCBQYXRoXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcIk5o4bqtcCBIRCBQYXRoIGPhu6dhIGLhuqFuLCBzYXUgxJHDsyBxdcOpdCB0w6xtIGPDoWMgdMOgaSBraG/huqNuIGhv4bqhdCDEkeG7mW5nXCIsXG5cdFx0c2NhbjogXCJRdcOpdFwiLFxuXHRcdHJldHJ5OiBcIlRo4butIGzhuqFpXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIGtow7RuZyBraOG6oyBk4bulbmdcIixcblx0XHRhY2Nlc3NEZW5pZWRUb1VzZUxlZGdlckRldmljZTogXCJUcnV5IGPhuq1wIExlZGdlciBi4buLIHThu6sgY2jhu5FpXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIktow7RuZyB0w6xtIHRo4bqleSB0w6BpIGtob+G6o25cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiQ2jhu41uIHTDoGkga2hv4bqjbiBj4bunYSBi4bqhblwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCLEkGFuZyBr4bq/dCBu4buRaSAxIHTDoGkga2hv4bqjblwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJLaMO0bmcgdGjhu4MgdMOsbSB0aOG6pXkgYuG6pXQga+G7syB0w6BpIGtob+G6o24gbsOgbyDEkcaw4bujYyBsacOqbiBr4bq/dCB24bubaSBMZWRnZXIgbsOgeS4gVnVpIGzDsm5nIHThuqFvIG3hu5l0IHTDoGkga2hv4bqjbiBORUFSIG3hu5tpXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcImhv4bq3YyBr4bq/dCBu4buRaSB24bubaSB2w60gTGVkZ2VyIGtow6FjLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwixJBhbmcga+G6v3QgbuG7kWlcIixcblx0XHRvZkFjY291bnRzOiBcImPhu6dhIHTDoGkga2hv4bqjblwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJLaMO0bmcgdGjhu4MgdOG7sSDEkeG7mW5nIHTDrG0gaWQgdMOgaSBraG/huqNuLiBOaOG6rXAgdGjhu6cgY8O0bmc6XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIlThu5VuZyBxdWFuIGRhbmggc8OhY2ggY8OhYyB0w6BpIGtob+G6o24gxJHGsOG7o2Mg4buneSBxdXnhu4FuLCBob8OgbiB04bqldCDEkcSDbmcgbmjhuq1wIGLhurFuZyBjw6FjaCBi4bqlbSB2w6BvIG7DunQgYsOqbiBkxrDhu5tpLlwiLFxuXHRcdGZpbmlzaDogXCJIb8OgbiB0aMOgbmhcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIkLhuqFuIHPhur0gY+G6p24gY8OgaSDEkeG6t3RcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcIsSR4buDIGLhuq90IMSR4bqndS4gU2F1IGtoaSBjw6BpIMSR4bq3dCB4b25nXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwiVOG6o2kgbOG6oWkgdHJhbmcuXCIsXG5cdFx0b3BlbjogXCJN4bufXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLEkMOjIHNhbyBjaMOpcCB2w6BvIGLhuqNuZyBnaGkgdOG6oW1cIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiU2FvIGNow6lwIHbDoG8gYuG6o25nIGdoaSB04bqhbSB0aOG6pXQgYuG6oWlcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwiUXXDqXQgduG7m2kgxJFp4buHbiB0aG/huqFpIGPhu6dhIGLhuqFuXCIsXG5cdFx0Y29weVRvQ2xpcGJvYXJkOiBcIiBTYW8gY2jDqXAgdsOgbyBi4bqjbmcgZ2hpIHThuqFtXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiRGlhbG9ndWUgY2jDrW5oIHRo4bupYyBj4bunYVwiLFxuXHRcdG9wZW46IFwiTeG7n1wiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiVsOtIGzhuqFuaFwiLFxuXHRcdGJyb3dzZXI6IFwiVsOtIHRyw6xuaCBkdXnhu4d0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiVsOtIHRp4buHbiDDrWNoIG3hu58gcuG7mW5nXCIsXG5cdFx0YnJpZGdlOiBcIlbDrSBD4bqndVwiLFxuXHRcdG1vYmlsZTogXCJWw60gTW9iaWxlXCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJWw60gdOG7qWMgdGjDrFwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCJDaOG7jW4gdsOtXCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiQ2h1eeG7g24gdMOgaSBraG/huqNuXCIsXG5cdFx0c2VsZWN0QVdhbGxldDogXCJDaOG7jW4gdsOtIHBow7kgaOG7o3AgduG7m2kgbmh1IGPhuqd1IGPhu6dhIGLhuqFuLCB2w60gxJHGsOG7o2MgY2jhu41uIGPhuqduIGjhu5cgdHLhu6MgY8OhYyB0w6BpIGtob+G6o24gxJFhbmcgc+G7rSBk4bulbmcuXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcIkNo4buNbiB0w6BpIGtob+G6o25cIixcblx0XHRhZnRlckRlY2lkZTogXCJTYXUga2hpIGNo4buNbiDEkcaw4bujYyB0w6BpIGtob+G6o24gYuG6oW4gY8OzIGNodXnhu4NuLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiQuG6oW4ga2jDtG5nIHRo4buDIGNodXnhu4NuIHTDoGkga2hv4bqjbiBu4bq/dSB0w6BpIGtob+G6o24gxJHDsyBjaMawYSDEkcaw4bujYyBuaOG6rW4gdGnhu4FuIGhv4bq3YyBjaMawYSBwaMOhdCBzaW5oIGdpYW8gZOG7i2NoIHRyw6puIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCJraMO0bmcgaOG7lyB0cuG7oyB4deG6pXQgdMOgaSBraG/huqNuLiBWdWkgbMOybmcgY2jhu41uIHbDrSBraMOhYy5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiVsOtIGzhuqFuaFwiLFxuXHRcdFx0YnJvd3NlcjogXCJWw60gdHLDrG5oIGR1eeG7h3RcIixcblx0XHRcdGluamVjdGVkOiBcIlbDrSB0aeG7h24gw61jaCBt4bufIHLhu5luZ1wiLFxuXHRcdFx0YnJpZGdlOiBcIlbDrSBD4bqndVwiLFxuXHRcdFx0bW9iaWxlOiBcIlbDrSBNb2JpbGVcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIkNo4buNbiB0w6BpIGtob+G6o24gxJHhu4MgY2h1eeG7g25cIixcblx0XHRcdGJ1dHRvbjogXCJM4bqleSBj4bulbSBt4bqtdCBraOG6qXVcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIkLhu48gY2jhu41uIHThuqV0IGPhuqNcIixcblx0XHRcdHNlbGVjdEFsbDogXCJDaOG7jW4gdOG6pXQgY+G6o1wiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiQ2h1eeG7g24ga2jDtG5nIGto4bqjIGThu6VuZ1wiLFxuXHRcdFx0ZXJyb3I6IFwiVMOgaSBraG/huqNuIGtow7RuZyB04buTbiB04bqhaVwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJZw6p1IGPhuqd1IGjhu5cgdHLhu6MgTGVkZ2VyXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiVMOgaSBraG/huqNuIHRy4buRbmdcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiU2FvIGNow6lwIG3huq10IGto4bqpdSB04bqhbSB0aOG7nWlcIixcblx0XHRcdGRlc2M6IFwiQuG6oW4gc+G6vSBj4bqnbiBuaOG6rXAgbeG6rXQga2jhuql1IGtoaSBi4bqvdCDEkeG6p3UgeHXhuqV0IGPDoWMga2hv4bqjbiB04bubaSB2w60ga2jDoWMuXCIsXG5cdFx0XHRidXR0b246IFwiVGnhur9wIHThu6VjXCIsXG5cdFx0XHRsYWJlbDogXCJC4bqlbSDEkeG7gyBzYW8gY2jDqXBcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiVMO0aSDEkcOjIGNow6lwIGhv4bq3YyBnaGkgbOG6oWkgbeG6rXQga2jhuql1XCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCJIb8OgbiB0aMOgbmggY2h1eeG7g25cIixcblx0XHRcdGRlc2NPbmU6IFwiQuG6oW4gc+G6vSDEkcaw4bujYyBjaHV54buDbiBoxrDhu5tuZyB04bubaSB0w6BpIGtob+G6o24gxJHDoyBjaOG7jW4gxJHhu4MgaG/DoG4gdOG6pXQgcXXDoSB0csOsbmguXCIsXG5cdFx0XHRkZXNjVHdvOiBcIlNhdSBraGkgbmjhuq1wLCBuaOG6pW4gbsO6dCDEkeG7gyBob8OgbiB04bqldCBxdXkgdHLDrG5oIGNodXnhu4NuLlwiLFxuXHRcdFx0YnV0dG9uOiBcIkhvw6BuIHRow6BuaFwiXG5cdFx0fVxuXHR9XG59O1xudmFyIGNvbXBvbmVudCA9IHtcblx0Y2xpY2tUb0NvcHk6IHtcblx0XHRsYWJlbDogXCLEkMOjIHNhbyBjaMOpcFwiLFxuXHRcdHRvb2x0aXA6IFwiQuG6pW0gxJHhu4Mgc2FvIGNow6lwXCJcblx0fVxufTtcbnZhciB2aSA9IHtcblx0bW9kYWw6IG1vZGFsJDYsXG5cdGNvbXBvbmVudDogY29tcG9uZW50XG59O1xuXG52YXIgbW9kYWwkNSA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi4KSF4KSq4KSo4KS+IOCkteClieCksuClh+CknyAoV2FsbGV0KSDgpJXgpKjgpYfgpJXgpY3gpJ8g4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLgpLXgpYngpLLgpYfgpJ8g4KSV4KWN4KSv4KS+IOCkueCliD9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCklOCksCDgpKrgpY3gpLDgpKzgpILgpKfgpL/gpKQg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi4KSF4KSq4KSo4KWAIOCkleCljeCksOCkv+CkquCljeCkn+Cli+CkleCksOClh+CkguCkuOClgCDgpJTgpLAg4KSP4KSo4KSP4KSr4KSf4KWAIOCkleCliyDgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpLjgpY3gpJ/gpYvgpLAg4KSU4KSwIOCkn+CljeCksOCkvuCkguCkuOCkq+CksCDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRsb2dJblRvQW55OiBcIk5FQVIg4KSq4KSwIOCkleCkv+CkuOClgCDgpK3gpYAg4KSQ4KSqIOCkruClh+CkgiDgpLjgpL7gpIfgpKgg4KSH4KSoIOCkleCksOClh+CkguClpFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcIuCkqOCkjyDgpJbgpL7gpKTgpYcg4KSv4KS+IOCksuClieCkl+Ckv+CkqCDgpKzgpKjgpL7gpKjgpYcg4KSV4KWAIOCkhuCkteCktuCljeCkr+CkleCkpOCkviDgpKjgpLngpYDgpIIg4KS54KWI4KWkIOCkheCkquCkqOCkviDgpLXgpYngpLLgpYfgpJ8oTkVBUiBXYWxsZXQp4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkgiDgpJTgpLAg4KSG4KSw4KSC4KStIOCkleCksOClh+CkguClpFwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi4KSP4KSVIOCkteClieCksuClh+CknyDgpKzgpKjgpL7gpI/gpIHgpaRcIixcblx0XHR1c2VBV2FsbGV0OiBcIuCkheCkquCkqOClgCBORUFSIOCkuOCkguCkquCkpOCljeCkpOCkv+Ckr+Cli+CkgiDgpJXgpYsg4KS44KWB4KSw4KSV4KWN4KS34KS/4KSkIOCklOCksCDgpKrgpY3gpLDgpKzgpILgpKfgpL/gpKQg4KSV4KSw4KSo4KWHIOCkleClhyDgpLLgpL/gpI8g4KS14KWJ4KSy4KWH4KSfIOCkleCkviDgpIngpKrgpK/gpYvgpJcg4KSV4KSw4KWH4KSCIOCklOCksCDgpJXgpL/gpLjgpYAg4KSt4KWAIE5FQVIg4KSQ4KSqIChhcHApIOCkruClh+CkgiDgpLLgpYngpJcg4KSH4KSoIOCkleCksOClh+Ckgiwg4KSV4KS/4KS44KWAIOCkieCkquCkr+Cli+Ckl+CkleCksOCljeCkpOCkviAodXNlcikg4KSo4KS+4KSuIOCklOCksCDgpKrgpL7gpLjgpLXgpLDgpY3gpKEg4KSV4KWAIOCkhuCkteCktuCljeCkr+CkleCkpOCkviDgpKjgpLngpYDgpIIg4KS54KWI4KWkXCIsXG5cdFx0Y29ubmVjdGlvbkZhaWxlZDogXCLgpJXgpKjgpYfgpJXgpY3gpLbgpKgg4KS14KS/4KSr4KSyfFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcIuCkleCkqOClh+CkleCljeCktuCkqCDgpLjgpKvgpLJ8XCIsXG5cdFx0Y29ubmVjdGVkOiBcIuCkteClieCksuClh+CknyDgpJzgpYHgpZwg4KSX4KSv4KS+fFwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCLgpLXgpYngpLLgpYfgpJ8g4KSc4KWB4KWcIOCksOCkueCkviDgpLngpYd8XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIuCkj+CkleCljeCkuOCkn+Clh+CkguCktuCkqCDgpLXgpL/gpILgpKHgpYsg4KSu4KWH4KSCIOCkleCkqOClh+CkleCljeCktuCkqCDgpJXgpYAg4KSq4KWB4KS34KWN4KSf4KS/IOCkleCksOClh+CkgnxcIixcblx0XHRcdGJyb3dzZXI6IFwi4KSw4KWA4KSh4KS+4KSv4KSw4KWH4KSV4KWN4KSfIOCkueCli+CkqOClhyDgpJXgpYcg4KSs4KS+4KSmIOCkteClieCksuClh+CknyDgpK7gpYfgpIIg4KSV4KSo4KWH4KSV4KWN4KS24KSoIOCkleClgCDgpKrgpYHgpLfgpY3gpJ/gpL8g4KSV4KSw4KWH4KSCfFwiLFxuXHRcdFx0aGFyZHdhcmU6IFwi4KSV4KWL4KSy4KWN4KShIOCkteClieCksuClh+CknyDgpJXgpYcg4KS44KS+4KSlIOCkleCkqOClh+CkleCljeCktuCkqCDgpJXgpYAg4KSq4KWB4KS34KWN4KSf4KS/IOCkleCksOClh+CkgnxcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi4KSy4KWH4KSc4KSwKExlZGdlcingpLXgpYngpLLgpYfgpJ8g4KSV4KSo4KWH4KSV4KWN4KSfIOCkleCksOClh+CkgnxcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi4KS44KWB4KSo4KS/4KS24KWN4KSa4KS/4KSkIOCkleCksOClh+CkgiDgpJXgpL8g4KSG4KSq4KSV4KS+IOCksuClh+CknOCksCDgpLjgpYHgpLDgpJXgpY3gpLfgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpJzgpYHgpKHgpLzgpL4g4KS54KWB4KSGIOCkueCliCDgpJTgpLAgTkVBUiDgpJDgpKog4KSG4KSq4KSV4KWHIOCkoeCkv+CkteCkvuCkh+CkuCAoRGV2aWNlKeCkquCksCDgpKrgpLngpLLgpYcg4KS44KWHIOCkueClgCDgpJbgpYHgpLLgpL4g4KS54KWIfFwiLFxuXHRcdFwiY29udGludWVcIjogXCLgpJzgpL7gpLDgpYAg4KSw4KSW4KWHfFwiLFxuXHRcdHNwZWNpZnlIRFBhdGg6IFwi4KS54KS+4KSw4KWN4KShIOCkoeCkv+CkuOCljeCklShIYXJkIERpc2sp4KSq4KSlKFBhdGgp4KSo4KS/4KSw4KWN4KSn4KS+4KSw4KS/4KSkIOCkleCksOClh3xcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwi4KSF4KSq4KSo4KS+IOCkj+CkmuCkoeClgCDgpKrgpKUg4KSm4KSw4KWN4KScIOCkleCksOClh+Ckgiwg4KSr4KS/4KSwIOCkuOCkleCljeCksOCkv+CkryDgpJbgpL7gpKTgpYvgpIIg4KSV4KWHIOCksuCkv+CkjyDgpLjgpY3gpJXgpYjgpKgg4KSV4KSw4KWH4KSCfFwiLFxuXHRcdHNjYW46IFwi4KS44KWN4KSV4KWI4KSoIOCkleCksOClh3xcIixcblx0XHRyZXRyeTogXCLgpKbgpYvgpKzgpL7gpLDgpL4g4KSq4KWN4KSw4KSv4KS+4KS4IOCkleCksOClh3xcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLgpLLgpYfgpJzgpLAg4KSJ4KSq4KSy4KSs4KWN4KSnIOCkqOCkueClgOCkgiDgpLngpYh8XCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi4KSy4KWH4KSc4KSwIOCkoeCkv+CkteCkvuCkh+CkuCDgpJXgpL4g4KSJ4KSq4KSv4KWL4KSXIOCkleCksOCkqOClhyDgpJXgpYcg4KSy4KS/4KSPIOCkquCljeCksOCkteClh+CktiDgpKjgpL/gpLfgpYfgpKd8XCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIuCkluCkvuCkpOCkviDgpKjgpLngpYDgpIIg4KSu4KS/4KSy4KS+fFwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLgpIXgpKrgpKjgpYcg4KSW4KS+4KSk4KWHIOCkmuClgeCkqOClh+CkgnxcIixcblx0XHRjb25uZWN0aW5nMUFjY291bnQ6IFwi4KSP4KSVIOCkluCkvuCkpOCkviDgpJXgpKjgpYfgpJXgpY3gpJ8g4KS54KWLIOCksOCkueCkviDgpLngpYh8XCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIuCkh+CkuCDgpLLgpYfgpJzgpLAg4KS44KWHIOCknOClgeCkoeCkvOCkviDgpJXgpYvgpIgg4KSW4KS+4KSk4KS+IOCkqOCkueClgOCkgiDgpK7gpL/gpLLgpL7gpaQg4KSV4KWD4KSq4KSv4KS+IOCkj+CklSDgpKjgpK/gpL4gTkVBUiDgpJbgpL7gpKTgpL4g4KSs4KSo4KS+4KSP4KSBfFwiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCLgpIXgpKXgpLXgpL4g4KSm4KWC4KS44KSw4KWHIOCksuClh+CknOCksCDgpLXgpYngpLLgpYfgpJ8g4KS44KWHIOCkleCkqOClh+CkleCljeCknyDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRjb25uZWN0aW5nOiBcIuCknOClgeClnCDgpLDgpLngpL4g4KS54KWHfFwiLFxuXHRcdG9mQWNjb3VudHM6IFwi4KSW4KS+4KSk4KS+IOCkheCkrCDgpJzgpYHgpZzgpL4g4KSo4KS54KWA4KSCIOCkueClh3xcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi4KSW4KS+4KSk4KS+IOCkhuCkiOCkoeClgCDgpLjgpY3gpLXgpJrgpL7gpLLgpL/gpKQg4KSw4KWC4KSqIOCkuOClhyDgpJbgpYvgpJzgpKjgpYcg4KSu4KWH4KSCIOCkheCkuOCkruCksOCljeCkpeClpCDgpK7gpYjgpKjgpY3gpK/gpYHgpIXgpLIgKE1hbnVhbGwpIOCksOClguCkqiDgpLjgpYcg4KSV4KWL4KS24KS/4KS2IOCkleCksOClh+CkgnxcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi4KSF4KS14KSy4KWL4KSV4KSoIOCkheCkp+Ckv+CkleClg+CkpCDgpJXgpYAg4KS44KWC4KSa4KWALCDgpKjgpYDgpJrgpYcg4KSm4KS/4KSPIOCkl+CkjyDgpKzgpJ/gpKgg4KSq4KSwIOCkleCljeCksuCkv+CklSDgpJXgpLDgpJXgpYcg4KSy4KWJ4KSX4KS/4KSoIOCkquClguCksOCkviDgpJXgpLDgpYfgpILgpaRcIixcblx0XHRmaW5pc2g6IFwi4KS44KSu4KS+4KSq4KWN4KSkfFwiXG5cdH0sXG5cdGluc3RhbGw6IHtcblx0XHR5b3VsbE5lZWRUb0luc3RhbGw6IFwi4KSG4KSq4KSV4KWLIOCkh+CkguCkuOCljeCkn+ClieCksiDgpJXgpLDgpKjgpL4g4KS54KWL4KSX4KS+fFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwi4KSH4KSC4KS44KWN4KSf4KWJ4KSyIOCkleCksOCkqOClhyDgpJXgpYcg4KSs4KS+4KSmIOCknOCkvuCksOClgCDgpLDgpJbgpYd8XCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi4KSq4KWB4KSoOiDgpLLgpYvgpKEg4KSV4KSw4KWH4KSC4KWkXCIsXG5cdFx0b3BlbjogXCLgpJbgpYvgpLLgpYd8XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLgpJXgpY3gpLLgpL/gpKrgpKzgpYvgpLDgpY3gpKEoQ2xpcGJvYXJkKeCkquCksCDgpJXgpYngpKrgpYAg4KSV4KS/4KSv4KS+IOCkl+Ckr+CkvnxcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwi4KSV4KWN4KSy4KS/4KSq4KSs4KWL4KSw4KWN4KShIOCkquCksCDgpJXgpYngpKrgpYAg4KSV4KSw4KSo4KS+IOCkteCkv+Ckq+CksiDgpLDgpLngpL58XCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIuCkheCkquCkqOClhyDgpKvgpYvgpKggKE1vYmlsZSngpLjgpYcg4KS44KWN4KSV4KWI4KSoIOCkleCksOClh+CkgnxcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIOCkleCljeCksuCkv+CkquCkrOCli+CksOCljeCkoSDgpKrgpLAg4KSV4KWJ4KSq4KWAIOCkleCksOClh+CkgnxcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLgpIbgpKfgpL/gpJXgpL7gpLDgpL/gpJUg4KS44KSC4KS14KS+4KSmIOCkleCliyDgpKrgpY3gpLDgpL7gpKXgpK7gpL/gpJXgpKTgpL4g4KSm4KWH4KSCfFwiLFxuXHRcdG9wZW46IFwi4KSW4KWL4KSy4KWHfFwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0YnJvd3NlcjogXCJCcm93c2VyIFdhbGxldFwiLFxuXHRcdGluamVjdGVkOiBcIldhbGxldCBFeHRlbnNpb25cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbGUgV2FsbGV0XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCJJbnN0YW50IFdhbGxldFwiXG5cdH1cbn07XG52YXIgaGkgPSB7XG5cdG1vZGFsOiBtb2RhbCQ1XG59O1xuXG52YXIgbW9kYWwkNCA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi2LXZhCDZhdit2YHYuNiq2YNcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcItmF2Kcg2YfZiiDYp9mE2YXYrdmB2LjYqdifXCIsXG5cdFx0c2VjdXJlQW5kTWFuYWdlOiBcItiq2KPZhdmK2YYg2YjYpdiv2KfYsdipINin2YTZhdmF2KrZhNmD2KfYqiDYp9mE2LHZgtmF2YrYqSDYp9mE2K7Yp9i12Kkg2KjZg1wiLFxuXHRcdHNhZmVseVN0b3JlOiBcItmC2YUg2KjYqtiu2LLZitmGINmIINin2LHYs9in2YQg2LnZhdmE2KfYqtmDINmIINij2LXZiNmE2YMg2KfZhNix2YLZhdmK2Kkg2KjYo9mF2KfZhlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi2LPYrNmEINin2YTYr9iu2YjZhCDYpdmE2Ykg2KPZiiDYqti32KjZitmCINmK2LPYqtiu2K/ZhSDZhtmK2LFcIixcblx0XHRub05lZWRUb0NyZWF0ZTogXCIu2YTYpyDYr9in2LnZiiDZhNil2YbYtNin2KEg2K3Ys9in2Kgg2KzYr9mK2K8uINmB2YLYtyDZgtmFINio2KrZiNi12YrZhCDZhdit2YHYuNiq2YMg2YjYp9mG2LfZhNmCXCIsXG5cdFx0Z2V0QVdhbGxldDogXCLYp9it2LXZhCDYudmE2Ykg2YXYrdmB2LjYqVwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi2KfYs9iq2K7Yr9mFINmF2K3Zgdi42Kkg2YTYqtij2YXZitmGINmI2KXYr9in2LHYqSDYo9i12YjZhCDZhtmK2LEg2KfZhNiu2KfYtdipINio2YPYjCDZiNin2K/YrtmEINmE2KPZiiDYqti32KjZitmCINmK2LPYqtiu2K/ZhSDZhtmK2LEg2K/ZiNmGINin2YTYrdin2KzYqSDYpdmE2Ykg2KfYs9mFINin2YTZhdiz2KrYrtiv2YUg2YjZg9mE2YXYqdin2YTZhdix2YjYsVwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi2KfYqti12KfZhCDZgdin2LTZhFwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItin2KrYtdin2YQg2YbYp9is2K1cIixcblx0XHRjb25uZWN0ZWQ6IFwi2YXYqti12YRcIixcblx0XHRjb25uZWN0aW5nVG86IFwi2KzYp9ix2Yog2KfZhNin2KrYtdin2YQg2KhcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2YbYp9mB2LDYqSDYp9mE2KXYttin2YHYqVwiLFxuXHRcdFx0YnJvd3NlcjogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDYp9mE2YXYrdmB2LjYqSDYqNi52K8g2KXYudin2K/YqSDYqtmI2KzZitmHXCIsXG5cdFx0XHRoYXJkd2FyZTogXCLZiNin2YHZgiDYudmE2Ykg2KfZhNin2KrYtdin2YQg2YHZiiDYrNmH2KfYsiDZhNmK2K/YrNixXCIsXG5cdFx0XHRicmlkZ2U6IFwi2YjYp9mB2YIg2LnZhNmJINin2YTYp9iq2LXYp9mEINmB2Yog2KfZhNmF2K3Zgdi42KlcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi2KfYqti12YQg2YXYuSDZhNmK2K/YrNixXCIsXG5cdFx0bWFrZVN1cmVZb3VyTGVkZ2VyOiBcItiq2KPZg9ivINij2YYg2YTZitiv2KzYsSDZhdiq2LXZhCDYqNij2YXYp9mGLCDZiCDYo9mGINiq2LfYqNmK2YIg2YbZitixINmF2YHYqtmI2K0g2YHZiiDYrNmH2KfYstmDXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItiq2KfYqNi5XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLYrdiv2K8g2YXYs9in2LEg2KfZhNit2LPYp9ioXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItij2K/YrtmEINmF2LPYp9ixINin2YTYrdiz2KfYqCDYp9mE2YXZgdi22YTYjCDYq9mFINin2KjYrdirINi52YYg2YPZhCDYp9mE2K3Ys9in2KjYp9iqINin2YTZhti02LfYqVwiLFxuXHRcdHNjYW46IFwi2YXYs9itXCIsXG5cdFx0cmV0cnk6IFwi2KPYudivINin2YTZhdit2KfZiNmE2KlcIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLZhNmK2K/YrNixINi62YrYsSDZhdiq2YjZgdixXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi2KrZhSDYsdmB2LYg2KfZhNin2KrYtdin2YQg2KjZhNmK2K/YrNixXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcItmE2YUg2YrYqtmFINin2YTYudir2YjYsSDYudmE2Ykg2KPZiiDYrdiz2KfYqNin2KpcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwi2K3Yr9ivINit2LPYp9io2KfYqtmDXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItis2KfYsdmKINin2YTYp9iq2LXYp9mEINio2K3Ys9in2Kgg2YjYp9it2K9cIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi2YTYpyDZitmF2YPZhiDYp9mE2LnYq9mI2LEg2LnZhNmJINij2Yog2K3Ys9in2Kgg2YXYsdiq2KjYtyDYqNmH2LDYpyDZhNmK2K/YrNixINin2YTYsdis2KfYoSDYpdmG2LTYp9ihINit2LPYp9ioINmG2YrYsSDYrNiv2YrYryDYudmE2YlcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi2KfZiCDYp9ix2KjYtyDYrNmH2KfYsiDZhNmK2K/YrNixINii2K7YsVwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwi2KzYp9ix2Yog2KfZhNin2KrYtdin2YRcIixcblx0XHRvZkFjY291bnRzOiBcItmF2YYg2KfZhNit2LPYp9io2KfYqlwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLZgdi02YQg2YHZiiDYp9mE2KfYqti12KfZhCDYqNin2YTYrdiz2KfYqCDYqtmE2YLYp9im2YrYpy4g2YrYsdis2Ykg2KfZhNin2KrYtdin2YQg2KjYp9mE2K3Ys9in2Kgg2YrYr9mI2YrYp1wiLFxuXHRcdG92ZXJ2aWV3VGhlTGlzdE9mQXV0aG9yaXplZDogXCLZhNin2KbYrdipINin2YTYrdiz2KfYqNin2Kog2KfZhNmF2LXYsditINio2YfYpywg2KPZg9mF2YQg2KrYs9is2YrZhCDYp9mE2K/YrtmI2YQg2KjYp9mE2YbZgtixINi52YTZiSDYp9mE2LLYsSDYo9iv2YbYp9mHXCIsXG5cdFx0ZmluaXNoOiBcItil2YbZh9in2KFcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItiz2KrYrdiq2KfYrCDZhNiq2KvYqNmK2KpcIixcblx0XHR0b0NvbnRpbnVlQWZ0ZXJJbnN0YWxsaW5nOiBcItmE2YTYp9iz2KrZg9mF2KfZhC4g2KjYudivINin2YTYqtir2KjZitiqXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwi2YLZhSDYqNiq2K3Yr9mK2Ksg2KfZhNi12YHYrdipXCIsXG5cdFx0b3BlbjogXCLYp9mB2KrYrVwiXG5cdH0sXG5cdHFyOiB7XG5cdFx0Y29waWVkVG9DbGlwYm9hcmQ6IFwi2KrZhSDYp9mE2YbYs9iuXCIsXG5cdFx0ZmFpbGVkVG9Db3B5OiBcItmB2LTZhCDYp9mE2YbYs9iuXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcItin2YXYs9itINio2KzZh9in2LLZgyDYp9mE2YXYrdmF2YjZhFwiLFxuXHRcdGNvcHlUb0NsaXBib2FyZDogXCLZhtiz2K5cIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCLYqtmB2LbZhCDYp9mE2K3ZiNin2LEg2KfZhNix2LPZhdmKINmEXCIsXG5cdFx0b3BlbjogXCLZgdiq2K1cIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcIkhhcmR3YXJlIFdhbGxldFwiLFxuXHRcdGJyb3dzZXI6IFwiQnJvd3NlciBXYWxsZXRcIixcblx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0YnJpZGdlOiBcIkJyaWRnZSBXYWxsZXRcIixcblx0XHRtb2JpbGU6IFwiTW9iaWxlIFdhbGxldFwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiSW5zdGFudCBXYWxsZXRcIlxuXHR9XG59O1xudmFyIGFyID0ge1xuXHRtb2RhbDogbW9kYWwkNFxufTtcblxudmFyIG1vZGFsJDMgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIlNwb2ppdGUgY3J5cHRvIG5vdsSNYW5payFcIixcblx0XHR3aGF0SXNBV2FsbGV0OiBcIsWgdG8gamUgdG8gY3J5cHRvIG5vdsSNYW5paz9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwiT3NpZ3VyYWp0ZSBpIHVwcmF2bGphanRlIHN2b2pvbSBkaWdpdGFsbm9tIGltb3Zpbm9tLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIlNpZ3Vybm8gcG9ocmFuaXRlIGkgcHJlYmFjaXRlIHN2b2ogY3J5cHRvIGkgTkZULWV2ZS5cIixcblx0XHRsb2dJblRvQW55OiBcIiBQcmlqYXZpdGUgc2UgdSBiaWxvIGtvanUgTkVBUiBhcGxpa2FjaWp1XCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTmVtYSBwb3RyZWJlIHphIHN0dmFyYW5qZW0gbm92aWggbmFsb2dhIGlsaSBrb3Jpc25pxI1raWggcG9kYXRha2EuIFNwb2ppdGUgc3ZvaiBjcnlwdG8gbm92xI1hbmlrIGkgc3ByZW1uaSBzdGUhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJPdHZvcml0ZSBjcnlwdG8gbm92xI1hbmlrXCIsXG5cdFx0dXNlQVdhbGxldDogXCJLb3Jpc3RpdGUgY3J5cHRvIG5vdsSNYW5payBkYSBiaXN0ZSBvc2lndXJhbGkgaSB1cHJhdmxqYWxpIHN2b2pvbSBORUFSIGltb3Zpbm9tLCB0ZSBzZSBwcmlqYXZpdGUgdSBiaWxvIGtvanUgTkVBUiBhcGxpa2FjaWp1IGJleiBrb3Jpc25pxI1rb2cgaW1lbmEgaSBsb3ppbmtlLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwiTmV1c3BqZcWhbm8gcG92ZXppdmFuamUuXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiVXNwamXFoW5vIHBvdmV6aXZhbmplLlwiLFxuXHRcdGNvbm5lY3RlZDogXCJQb3ZlemFuby5cIixcblx0XHRjb25uZWN0aW5nVG86IFwiUG92ZXppdmFuamUgdSB0aWpla3VcIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwiUG90dnJkaXRlIHZlenUgdSBla3N0ZXJub20gcHJvem9ydVwiLFxuXHRcdFx0YnJvd3NlcjogXCJOYWtvbiByZWRpcmVrY2lqZSwgcG90dnJkaXRlIHZlenUgdSBub3bEjWFuaWt1XCIsXG5cdFx0XHRoYXJkd2FyZTogXCJQb3R2cmRpdGUgdmV6dSBzYSBub3bEjWFuaWtvbVwiLFxuXHRcdFx0YnJpZGdlOiBcIlBvdHZyZGl0ZSB2ZXp1IHUgbm92xI1hbmlrdVwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCJQb3Zlxb5pdGUgc2UgaGFyZHZlcnNraW0gbm92xI1hbmlrb21cIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwiT3NpZ3VyYWp0ZSBzaWd1cm51IHZlenUgcyBoYXJkdmVyc2tpbSBub3bEjWFuaWtvbSwgdGUgZGEgamUgTkVBUiBhcGxpa2FjaWphIG90dm9yZW5hIG5hIHZhxaFlbSB1cmXEkWFqdVwiLFxuXHRcdFwiY29udGludWVcIjogXCJOYXN0YXZpdGVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIlNwZWNpZmljaXJhanRlIEhEIHB1dGFuanVcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiVXBpxaFpdGUgcHJlZmVyaXJhbnUgSEQgcHV0YW5qdSwgemF0aW0gc2tlbmlyYWp0ZSBha3Rpdm5lIG5hbG9nZVwiLFxuXHRcdHNjYW46IFwiU2tlbmlyYWp0ZVwiLFxuXHRcdHJldHJ5OiBcIlBva3XFoWFqdGUgcG9ub3Zub1wiLFxuXHRcdGxlZGdlcklzTm90QXZhaWxhYmxlOiBcIkhhcmR2ZXJza2kgbm92xI1hbmlrIG5pamUgZG9zdHVwYW4uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiT2RiaWplbiBwcmlzdHVwIHphIGtvcmnFoXRlbmplbSBoYXJkdmVyc2tvZyBub3bEjWFuaWthXCIsXG5cdFx0bm9BY2NvdW50c0ZvdW5kOiBcIk5hbG96aSBuaXN1IHByb25hxJFlbmlcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiT2RhYmVyaXRlIHN2b2plIG5hbG9nZVwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJQb3Zleml2YW5qZSAxIG5hbG9nYVwiLFxuXHRcdGNhbnRGaW5kQW55QWNjb3VudDogXCJOaWplIG1vZ3XEh2UgcHJvbmHEh2kgbml0aSBqZWRhbiBuYWxvZyBwb3ZlemFuIHMgb3ZpbSBoYXJkdmVyc2tpbSBub3bEjWFuaWtvbS4gTW9saW1vIHZhcywga3JlaXJhanRlIG5vdmkgTkVBUiBuYWxvZ1wiLFxuXHRcdG9yQ29ubmVjdEFuQW5vdGhlckxlZGdlcjogXCJJbGkgcG92ZcW+aXRlIGRydWdpIGhhcmR2ZXJza2kgbm92xI1hbmlrLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiUG92ZXppdmFuamVcIixcblx0XHRvZkFjY291bnRzOiBcIm5hbG9nYVwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCJOZXVzcGplxaFubyBhdXRvbWF0c2tvIHByb25hbGHFvmVuamUgSUQgbmFsb2dhLiBVbmVzaXRlIHJ1xI1ubzpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwiUHJlZ2xlZGFqdGUgcG9waXMgb2RvYnJlbmloIG5hbG9nYSwgemF2csWhaXRlIHByaWphdnUgcHJpdGlza29tIG5hIG5pxb5lIHByaWthemFuaSBndW1iLlwiLFxuXHRcdGZpbmlzaDogXCJaYXZyxaFpdGVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcIiBQb3RyZWJubyBqZSBpbnN0YWxpcmF0aSBtb2RhbFwiLFxuXHRcdHRvQ29udGludWVBZnRlckluc3RhbGxpbmc6IFwiemEgbmFzdGF2YWsuIE5ha29uIGluc3RhbGFjaWplXCIsXG5cdFx0cmVmcmVzaFRoZVBhZ2U6IFwib3N2amXFvml0ZSBzdHJhbmljdS5cIixcblx0XHRvcGVuOiBcIk90dm9yaXRlIFFSIG1vZGFsXCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCJLb3BpcmFubyB1IG1lxJF1c3ByZW1uaWtcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiTmV1cHNqZcWhbm8ga29waXJhbmplIHUgbWXEkXVzcHJlbW5pa1wiLFxuXHRcdHNjYW5XaXRoWW91ck1vYmlsZTogXCJTa2VuaXJhanRlIHN2b2ppbSBtb2JpbG5pbSB1cmXEkWFqZW1cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIEtvcGlyYWp0ZSB1IG1lxJF1c3ByZW1uaWtcIixcblx0XHRwcmVmZXJUaGVPZmZpY2lhbDogXCJPZGFiZXJpdGUgc2x1xb5iZW5pIGRpamFsb2dcIixcblx0XHRvcGVuOiBcIk90dm9yaXRlXCJcblx0fSxcblx0d2FsbGV0VHlwZXM6IHtcblx0XHRoYXJkd2FyZTogXCJIYXJkd2FyZSBXYWxsZXRcIixcblx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0aW5qZWN0ZWQ6IFwiV2FsbGV0IEV4dGVuc2lvblwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2UgV2FsbGV0XCIsXG5cdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIixcblx0XHRcImluc3RhbnQtbGlua1wiOiBcIkluc3RhbnQgV2FsbGV0XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcIk9kYWJlcmkgV2FsbGV0XCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiUHJlbmVzaSBzdm9qZSBuYWxvZ2VcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIk9kYWJlcml0ZSB3YWxsZXQga29qaSBvZGdvdmFyYSB2YcWhaW0gcG90cmViYW1hIGkgcG9kcsW+YXZhIHZhxaFlIHBvdmV6YW5lIG5hbG9nZS5cIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiT2RhYmVyaSBzdm9qZSBuYWxvZ2VcIixcblx0XHRhZnRlckRlY2lkZTogXCJOYWtvbiDFoXRvIG9kbHXEjWl0ZSBrb2ppIHdhbGxldCBrb3Jpc3RpdGUsIG1vxb5ldGUgb2RhYnJhdGkga29qZSByYcSNdW5lIMW+ZWxpdGUgcHJlYmFjaXRpLlwiLFxuXHRcdGRpc2NsYWltZXI6IFwiTmXEh2V0ZSBtb8SHaSBwcmViYWNpdGkgbmFsb2dlIGtvamkgbmlzdSBuaWthZGEgYmlsaSBrb3JpxaF0ZW5pIG5hIE5FQVItdS5cIixcblx0XHR3YXJuaW5nOiBcIm5lIHBvZHLFvmF2YSBpenZveiBuYWxvZ2EgdSBvdm9tIHRyZW51dGt1LiBNb2xpbW8gb2RhYmVyaXRlIGRydWdpIHdhbGxldC5cIixcblx0XHR3YWxsZXRUeXBlczoge1xuXHRcdFx0aGFyZHdhcmU6IFwiSGFyZHdhcmUgV2FsbGV0XCIsXG5cdFx0XHRicm93c2VyOiBcIkJyb3dzZXIgV2FsbGV0XCIsXG5cdFx0XHRpbmplY3RlZDogXCJXYWxsZXQgRXh0ZW5zaW9uXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlIFdhbGxldFwiLFxuXHRcdFx0bW9iaWxlOiBcIk1vYmlsZSBXYWxsZXRcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIk9kYWJlcmkgbmFsb2dlIHphIHByaWplbm9zXCIsXG5cdFx0XHRidXR0b246IFwiR2VuZXJpcmFqIGxvemlua3VcIixcblx0XHRcdGRlc2VsZWN0QWxsOiBcIk1ha25pIG9kYWJpciBzYSBzdmloXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiT2RhYmVyaSBzdmVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcIlByaWplbm9zIG5pamUgZG9zdHVwYW5cIixcblx0XHRcdGVycm9yOiBcIk5hbG9nIG5lIHBvc3RvamlcIixcblx0XHRcdHdhcm5pbmdMZWRnZXI6IFwiUG90cmVibmEgbGVkZ2VyIHBvZHLFoWthXCIsXG5cdFx0XHRub0JhbGFuY2U6IFwiTmFsb2cgbmVtYSBzcmVkc3RhdmFcIlxuXHRcdH0sXG5cdFx0Z2V0UGFzc3BocmFzZToge1xuXHRcdFx0dGl0bGU6IFwiS29waXJhaiBwcml2cmVtZW51IGxvemlua3VcIixcblx0XHRcdGRlc2M6IFwiQml0IMSHZSBwb3RyZWJubyB1bmlqZXRpIG92dSBsb3ppbmt1IG5hIHBvxI1ldGt1IGl6dm96YSBuYWxvZ2EgbmEgZHJ1Z2kgd2FsbGV0LlwiLFxuXHRcdFx0YnV0dG9uOiBcIk5hc3RhdmlcIixcblx0XHRcdGxhYmVsOiBcIktsaWtuaSB6YSBrb3BpanVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiS29waXJhbyBzYW0gaWxpIHphcGlzYW8gbG96aW5rdVwiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwiWmF2csWhaSBwcmlqZW5vc1wiLFxuXHRcdFx0ZGVzY09uZTogXCJZb3Ugd2lsbCBub3cgYmUgcmVkaXJlY3RlZCB0byB0aGUgd2FsbGV0IHlvdSBzZWxlY3RlZCB0byBjb21wbGV0ZSB0aGUgdHJhbnNmZXIuXCIsXG5cdFx0XHRkZXNjVHdvOiBcIkthZGEgamUgdW5vcyBzIG9kYWJyYW5vZyB3YWxsZXRhIHphdnLFoWVuLCBwcml0aXNuaXRlIGd1bWIgZGEgYmlzdGUgemF2csWhaWxpIHByaWplbm9zLlwiLFxuXHRcdFx0YnV0dG9uOiBcIlphdnLFoWlcIlxuXHRcdH1cblx0fVxufTtcbnZhciBociA9IHtcblx0bW9kYWw6IG1vZGFsJDNcbn07XG5cbnZhciBtb2RhbCQyID0ge1xuXHR3YWxsZXQ6IHtcblx0XHRjb25uZWN0WW91cldhbGxldDogXCLQn9C+0LLRgNC30LXRgtC1INCz0L4g0LLQsNGI0LjQvtGCINC90L7QstGH0LDQvdC40LohXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCLQqNGC0L4g0LUg0L3QvtCy0YfQsNC90LjQuj9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi0JfQsNGI0YLQuNGC0LXRgtC1INCz0Lgg0Lgg0YPQv9GA0LDQstGD0LLQsNGY0YLQtSDRgdC+INCy0LDRiNC40YLQtSDQtNC40LPQuNGC0LDQu9C90Lgg0YHRgNC10LTRgdGC0LLQsC5cIixcblx0XHRzYWZlbHlTdG9yZTogXCLQkdC10LfQsdC10LTQvdC+INGB0LrQu9Cw0LTQuNGA0LDRmNGC0LUg0Lgg0LjQt9Cy0YDRiNGD0LLQsNGY0YLQtSDRgtGA0LDQvdGB0LDQutGG0LjQuCDRgdC+INCy0LDRiNC40YLQtSDQutGA0LjQv9GC0L4g0LggTkZULlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi0J3QsNGY0LDQstC10YLQtSDRgdC1INC90LAg0LrQvtGY0LAg0LHQuNC70L4gTkVBUiDQsNC/0LvQuNC60LDRhtC40ZjQsFwiLFxuXHRcdG5vTmVlZFRvQ3JlYXRlOiBcItCd0LXQvNCwINC/0L7RgtGA0LXQsdCwINC00LAg0LrRgNC10LjRgNCw0YLQtSDQvdC+0LLQuCDRgdC80LXRgtC60Lgg0LjQu9C4INC40L3Qs9C10YDQtdC90YbQuNC4LiDQn9C+0LLRgNC30LXRgtC1INCz0L4g0LLQsNGI0LjQvtGCINC/0LDRgNC40YfQvdC40Log0Lgg0YHRgtC1INC/0L7QtNCz0L7RgtCy0LXQvdC4IVwiLFxuXHRcdGdldEFXYWxsZXQ6IFwi0J3QsNC/0YDQsNCy0LXRgtC1INC90L7QstGH0LDQvdC40LpcIixcblx0XHR1c2VBV2FsbGV0OiBcItCa0L7RgNC40YHRgtC10YLQtSDQv9Cw0YDQuNGH0L3QuNC6INC30LAg0LTQsCDQs9C4INC30LDRiNGC0LjRgtC40YLQtSDQuCDRg9C/0YDQsNCy0YPQstCw0YLQtSDQstCw0YjQuNGC0LUgTkVBUiDRgdGA0LXQtNGB0YLQstCwINC4INC00LAg0YHQtSDQvdCw0ZjQsNCy0LjRgtC1INC90LAg0LrQvtGY0LAg0LHQuNC70L4gTkVBUiDQsNC/0LvQuNC60LDRhtC40ZjQsCDQsdC10Lcg0L/QvtGC0YDQtdCx0LAg0L7QtCDQutC+0YDQuNGB0L3QuNGH0LrQuCDQuNC80LjRmtCwINC4INC70L7Qt9C40L3QutC4LlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0J/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INC90LUg0LHQtdGI0LUg0YPRgdC/0LXRiNC90L4uXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwi0KPRgdC/0LXRiNC90L4g0L/QvtCy0YDQt9GD0LLQsNGa0LUuXCIsXG5cdFx0Y29ubmVjdGVkOiBcItCf0L7QstGA0LfQsNC90L4uXCIsXG5cdFx0Y29ubmVjdGluZ1RvOiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1INGB0L5cIixcblx0XHRjb25uZWN0aW5nTWVzc2FnZToge1xuXHRcdFx0aW5qZWN0ZWQ6IFwi0J/QvtGC0LLRgNC00LXRgtC1INCz0L4g0L/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INCy0L4g0LXQutGB0YLQtdGA0L3QuNC+0YIg0L/RgNC+0LfQvtGA0LXRhlwiLFxuXHRcdFx0YnJvd3NlcjogXCLQn9C+INC/0YDQtdGD0YHQvNC10YDRg9Cy0LDRmtC10YLQviwg0L/QvtGC0LLRgNC00LXRgtC1INCz0L4g0L/QvtCy0YDQt9GD0LLQsNGa0LXRgtC+INC+0LQg0L3QvtCy0YfQsNC90LjQvtC60YJcIixcblx0XHRcdGhhcmR3YXJlOiBcItCf0L7RgtCy0YDQtNC10YLQtSDQs9C+INC/0L7QstGA0LfRg9Cy0LDRmtC10YLQviDRgdC+INC70LDQtNC10L0g0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJpZGdlOiBcItCf0L7RgtCy0YDQtNC10YLQtSDRmNCwINCy0YDRgdC60LDRgtCwINCy0L4g0L3QvtCy0YfQsNC90LjQutC+0YJcIlxuXHRcdH1cblx0fSxcblx0bGVkZ2VyOiB7XG5cdFx0Y29ubmVjdFdpdGhMZWRnZXI6IFwi0J/QvtCy0YDQt9C10YLQtSDRgdC1INGB0L4g0JvQtdGf0LXRgFwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCLQntGB0LjQs9GD0YDQsNGY0YLQtSDRgdC1INC00LXQutCwINCy0LDRiNC40L7RgiDQm9C10Z/QtdGAINC1INC/0L7QstGA0LfQsNC9INCx0LXQt9Cx0LXQtNC90L4sINC4INC00LXQutCwIE5FQVIg0LDQv9C70LjQutCw0YbQuNGY0LDRgtCwINC1INC+0YLQstC+0YDQtdC90LAg0L3QsCDQstCw0YjQuNC+0YIg0YPRgNC10LRcIixcblx0XHRcImNvbnRpbnVlXCI6IFwi0J/RgNC+0LTQvtC70LbQtdGC0LVcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcItCd0LDQstC10LTQtdGC0LUg0KXQlCDQu9C+0LrQsNGG0LjRmNCwXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCS0L3QtdGB0LXRgtC1INGY0LAg0LLQsNGI0LDRgtCwINC/0YDQtdGE0LXRgNC40YDQsNC90LAg0KXQlCDQu9C+0LrQsNGG0LjRmNCwLCDQsCDQv9C+0YLQvtCwINGB0LrQtdC90LjRgNCw0ZjRgtC1INC00LAg0LPQuCDQvdCw0ZjQtNC10YLQtSDQsNC60YLQuNCy0L3QuNGC0LUg0YHQvNC10YLQutC4LlwiLFxuXHRcdHNjYW46IFwi0KHQutC10L3QuNGA0LDRmNGC0LVcIixcblx0XHRyZXRyeTogXCLQntCx0LjQtNC10YLQtSDRgdC1INC/0L7QstGC0L7RgNC90L5cIixcblx0XHRsZWRnZXJJc05vdEF2YWlsYWJsZTogXCLQm9C10Z/QtdGA0L7RgiDQvdC1INC1INC00L7RgdGC0LDQv9C10L0uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi0J/RgNC40YHRgtCw0L/QvtGCINC30LAg0LrQvtGA0LjRgdGC0LXRmtC1INC90LAg0JvQtdGf0LXRgCDRg9GA0LXQtCDQtSDQvtC00LHQuNC10L1cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3QtdC80LAg0L3QsNGY0LTQtdC90Lgg0YHQvNC10YLQutC4XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsdC10YDQtdGC0LUg0LPQuCDQstCw0YjQuNGC0LUg0YHQvNC10YLQutC4XCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1INC90LAg0LXQtNC90LAg0YHQvNC10YLQutCwXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcItCd0LUg0YHQtSDQvdCw0ZjQtNC10L3QuCDRgdC80LXRgtC60Lgg0L/QvtCy0YDQt9Cw0L3QuCDRgdC+INC+0LLQvtGYINCb0LXRn9C10YAuINCS0LUg0LzQvtC70LjQvNC1INC60YDQtdC40YDQsNGY0YLQtSDQvdC+0LLQsCBORUFSINGB0LzQtdGC0LrQsCBcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INC/0L7QstGA0LfQtdGC0LUg0LTRgNGD0LMg0JvQtdGf0LXRgC5cIixcblx0XHRjb25uZWN0aW5nOiBcItCf0L7QstGA0LfRg9Cy0LDRmtC1XCIsXG5cdFx0b2ZBY2NvdW50czogXCLQvdCwINGB0LzQtdGC0LrQuFwiLFxuXHRcdGZhaWxlZFRvQXV0b21hdGljYWxseTogXCLQndC10YPRgdC/0LXRiNC90L4g0LDQstGC0L7QvNCw0YLRgdC60L4g0LHQsNGA0LDRmtC1INC90LAg0JjQlCDQvdCwINGB0LzQtdGC0LrQsNGC0LAuINCS0L3QtdGB0LXRgtC1INCz0L4g0YDQsNGH0L3QvjpcIixcblx0XHRvdmVydmlld1RoZUxpc3RPZkF1dGhvcml6ZWQ6IFwi0J/RgNC10LPQu9C10LQg0L3QsCDQu9C40YHRgtCw0YLQsCDQvdCwINC+0LLQu9Cw0YHRgtC10L3QuCDRgdC80LXRgtC60LgsINC30LDQstGA0YjQtdGC0LUg0YHQtSDQvdCw0ZjQsNCy0LDRgtCwINGB0L4g0LrQu9C40LrQvdGD0LLQsNGa0LUg0L3QsCDQutC+0L/Rh9C10YLQviDQv9C+0LTQvtC70YMuXCIsXG5cdFx0ZmluaXNoOiBcItCX0LDQstGA0YjQtdGC0LVcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItCi0YDQtdCx0LAg0LTQsCDQuNC90YHRgtCw0LvQuNGA0LDRgtC1XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLQt9CwINC00LAg0L/RgNC+0LTQvtC70LbQuNGC0LUuINCf0L4g0LjQvdGB0YLQsNC70LjRgNCw0ZrQtdGC0L5cIixcblx0XHRyZWZyZXNoVGhlUGFnZTogXCLQntGB0LLQtdC20LXRgtC1INGY0LAg0YHRgtGA0LDQvdCw0YLQsC5cIixcblx0XHRvcGVuOiBcItCe0YLQstC+0YDQtdGC0LVcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcItCa0L7Qv9C40YDQsNC90L4g0L3QsCDQutC70LjQv9Cx0L7RgNC00L7RglwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQndC10YPRgdC/0LXRiNC90L4g0LrQvtC/0LjRgNCw0ZrQtSDQvdCwINC60LvQuNC/0LHQvtGA0LRcIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi0KHQutC10L3QuNGA0LDRmNGC0LUg0YHQviDQstCw0YjQuNC+0YIg0YLQtdC70LXRhNC+0L3RgdC60Lgg0YPRgNC10LRcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwi0JrQvtC/0LjRgNCw0ZjRgtC1INC90LAg0LrQu9C40L/QsdC+0YDQtFwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItCf0YDQtdGE0LXRgNC40YDQsNGY0YLQtSDQvtGE0LjRhtC40ZjQsNC70LXQvSDQtNC40LDQu9C+0LMg0L3QsFwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC10YLQtVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwi0KXQsNGA0LTQstC10YDRgdC60Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQvdCwINC40L3RgtC10YDQvdC10YIg0L/RgNC10LvQuNGB0YLRg9Cy0LDRh1wiLFxuXHRcdGluamVjdGVkOiBcItCV0LrRgdGC0LXQvdC30LjRmNCwINC30LAg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdGJyaWRnZTogXCJCcmlkZ2Ug0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70LXQvSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XCJpbnN0YW50LWxpbmtcIjogXCLQmNC90YHRgtCw0L3RgiDQv9Cw0YDQuNGH0L3QuNC6XCJcblx0fSxcblx0ZXhwb3J0QWNjb3VudHM6IHtcblx0XHRjaG9vc2VBV2FsbGV0OiBcItCe0LTQsdC10YDQtdGC0LUg0L/QsNGA0LjRh9C90LjQulwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcItCf0YDQtdGE0YDQu9C10YLQtSDQs9C4INCy0LDRiNC40YLQtSDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60LhcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcItCY0LfQsdC10YDQtdGC0LXQvSDQvdC+0LLRh9Cw0L3QuNC6INC60L7RmCDQs9C4INC30LDQtNC+0LLQvtC70YPQstCwINCy0LDRiNC40YLQtSDQsdCw0YDQsNC90ZrQsCDQuCDQs9C4INC/0L7QtNC00YDQttGD0LLQsCDQstCw0YjQuNGC0LUg0L/QvtCy0YDQt9Cw0L3QuCDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60LguXCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsdC10YDQtdGC0LUg0LPQuCDQstCw0YjQuNGC0LUg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4XCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwi0J7QtNC60LDQutC+INGc0LUg0LjQt9Cx0LXRgNC10YLQtSDQvdC+0LLRh9Cw0L3QuNC6LCDQvNC+0LbQtdGC0LUg0LTQsCDQuNC30LHQtdGA0LXRgtC1INC60L7QuCDQutC+0YDQuNGB0L3QuNGH0LrQuCDRgdC80LXRgtC60Lgg0YHQsNC60LDRgtC1INC00LAg0LPQuCDQv9GA0LXRhNGA0LvQuNGC0LUuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCLQndC1INC80L7QttC10YLQtSDQtNCwINC/0YDRhNGA0LvQsNGC0LUg0LrQvtGA0LjRgdC90LjRh9C60Lgg0YHQvNC10YLQutC4INC60L7QuCDQvdC40LrQvtCz0LDRiCDQvdC1INCx0LjQu9C1INC90LDQtNC+0L/QvtC70L3QsNGC0Lgg0LjQu9C4INC60L7RgNC40YHRgtC10L3QuCDQvdCwIE5FQVIuXCIsXG5cdFx0d2FybmluZzogXCLQvdC1INC/0L7QtNC00YDQttGD0LLQsCDQuNC30LLQtdC30YPQstCw0ZrQtSDQvdCwINC60L7RgNC40YHQvdC40YfQutC4INGB0LzQtdGC0LrQuCDQstC+INC+0LLQvtGYINC80L7QvNC10L3Rgi4g0JLQtSDQvNC+0LvQuNC80LUg0LjQt9Cx0LXRgNC10YLQtSDQtNGA0YPQsyDQvdC+0LLRh9Cw0L3QuNC6LlwiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCLQpdCw0YDQtNCy0LXRgNGB0LrQuCDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L3QsCDQuNC90YLQtdGA0L3QtdGCINC/0YDQtdC70LjRgdGC0YPQstCw0YdcIixcblx0XHRcdGluamVjdGVkOiBcItCV0LrRgdGC0LXQvdC30LjRmNCwINC30LAg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFx0YnJpZGdlOiBcIkJyaWRnZSDQvdC+0LLRh9Cw0L3QuNC6XCIsXG5cdFx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C10L0g0L3QvtCy0YfQsNC90LjQulwiXG5cdFx0fSxcblx0XHRzZWxlY3RBY2NvdW50czoge1xuXHRcdFx0dGl0bGU6IFwi0JjQt9Cx0LXRgNC10YLQtSDQs9C4INC60L7RgNC40YHQvdC40YfQutC40YLQtSDRgdC80LXRgtC60Lgg0LfQsCDQtNCwINCz0Lgg0L/RgNC10YTRgNC70LjRgtC1LlwiLFxuXHRcdFx0YnV0dG9uOiBcItCU0L7QsdC40ZjRgtC1INC70L7Qt9C40L3QutCwXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCLQntGC0YHQtdC70LXQutGC0LjRgNCw0ZjRgtC1INGB0LVcIixcblx0XHRcdHNlbGVjdEFsbDogXCLQmNC30LHQtdGA0LXRgtC1INGB0LVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcItCi0YDQsNC90YHRhNC10YDQvtGCINC1INC90LXQtNC+0YHRgtCw0L/QtdC9XCIsXG5cdFx0XHRlcnJvcjogXCLQmtC+0YDQuNGB0L3QuNGH0LrQsNGC0LAg0YHQvNC10YLQutCwINC90LUg0L/QvtGB0YLQvtC4XCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcItCf0L7RgtGA0LXQsdC90LAg0LUg0L/QvtC00LTRgNGI0LrQsCDQvtC0INCb0LXRn9C10YBcIixcblx0XHRcdG5vQmFsYW5jZTogXCLQodC80LXRgtC60LDRgtCwINC90LUg0LUg0YTQuNC90LDQvdGB0LjRgNCw0L3QsFwiXG5cdFx0fSxcblx0XHRnZXRQYXNzcGhyYXNlOiB7XG5cdFx0XHR0aXRsZTogXCLQmtC+0L/QuNGA0LDRmNGC0LUg0ZjQsCDQv9GA0LjQstGA0LXQvNC10L3QsNGC0LAg0LvQvtC30LjQvdC60LBcIixcblx0XHRcdGRlc2M6IFwi0IzQtSDRgtGA0LXQsdCwINC00LAg0ZjQsCDQstC90LXRgdC10YLQtSDQvtCy0LDQsCDQu9C+0LfQuNC90LrQsCDQutC+0LPQsCDRnNC1INC30LDQv9C+0YfQvdC10YLQtSDQtNCwINCz0Lgg0LjQt9Cy0LXQt9GD0LLQsNGC0LUg0LLQsNGI0LjRgtC1INGB0LzQtdGC0LrQuCDQvdCwINC00YDRg9CzINC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0XHRidXR0b246IFwi0J/RgNC+0LTQvtC70LbQtdGC0LVcIixcblx0XHRcdGxhYmVsOiBcItCa0LvQuNC60L3QtdGC0LUg0LfQsCDQtNCwINC60L7Qv9C40YDQsNGC0LVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwi0IjQsCDQutC+0L/QuNGA0LDQsiDQuNC70Lgg0LfQsNC/0LjRiNCw0LIg0LvQvtC30LjQvdC60LDRgtCwXCJcblx0XHR9LFxuXHRcdGNvbXBsZXRlOiB7XG5cdFx0XHR0aXRsZTogXCLQl9Cw0LLRgNGI0LXRgtC1INCz0L4g0L/RgNC10L3QvtGB0L7RglwiLFxuXHRcdFx0ZGVzY09uZTogXCLQodC10LPQsCDRnNC1INCx0LjQtNC10YLQtSDQv9GA0LXQvdCw0YHQvtGH0LXQvdC4INC90LAg0LjQt9Cx0YDQsNC90LjQvtGCINC90L7QstGH0LDQvdC40Log0LfQsCDQt9Cw0LLRgNGI0YPQstCw0ZrQtSDQvdCwINC/0YDQtdC90L7RgdC+0YIuXCIsXG5cdFx0XHRkZXNjVHdvOiBcItCe0YLQutCw0LrQviDRnNC1INC30LDQstGA0YjQuCDRg9Cy0L7Qt9C+0YIg0L7QtCDQuNC30LHRgNCw0L3QuNC+0YIg0L3QvtCy0YfQsNC90LjQuiwg0L/RgNC40YLQuNGB0L3QtdGC0LUg0LPQviDQutC+0L/Rh9C10YLQviDQt9CwINC00LAg0LPQviDQt9Cw0LLRgNGI0LjRgtC1INC/0YDQtdC90L7RgdC+0YIuXCIsXG5cdFx0XHRidXR0b246IFwi0JfQsNCy0YDRiNC10YLQtVwiXG5cdFx0fVxuXHR9XG59O1xudmFyIG1rID0ge1xuXHRtb2RhbDogbW9kYWwkMlxufTtcblxudmFyIG1vZGFsJDEgPSB7XG5cdHdhbGxldDoge1xuXHRcdGNvbm5lY3RZb3VyV2FsbGV0OiBcIlBvdmXFvml0ZSBzdm9qbyBkZW5hcm5pY28hXCIsXG5cdFx0d2hhdElzQVdhbGxldDogXCJLYWogamUgZGVuYXJuaWNhP1wiLFxuXHRcdHNlY3VyZUFuZE1hbmFnZTogXCJaYXZhcnVqdGUgaW4gdXByYXZsamFqdGUgc3ZvamEgZGlnaXRhbG5hIHNyZWRzdHZhLlwiLFxuXHRcdHNhZmVseVN0b3JlOiBcIlZhcm5vIHNocmFuanVqdGUgaW4gcHJlbmHFoWFqdGUgc3ZvamUga3JpcHRvdmFsdXRlIGluIE5GVGplLlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwiUHJpamF2aXRlIHNlIHYga2F0ZXJvIGtvbGkgYXBsaWthY2lqbyBuYSBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwiTmkgdmFtIHRyZWJhIHVzdHZhcmphdGkgbm92aWggcmHEjXVub3YuIFBvdmXFvml0ZSBzdm9qbyBkZW5hcm5pY28gaW4gemHEjW5pdGUhXCIsXG5cdFx0Z2V0QVdhbGxldDogXCJVc3R2YXJpdGUgZGVuYXJuaWNvXCIsXG5cdFx0dXNlQVdhbGxldDogXCJVcG9yYWJpdGUgZGVuYXJuaWNvLCBkYSBiaSB6YXZhcm92YWxpIGluIHVwcmF2bGphbGkgcyBzdm9qYSBORUFSIGRpZ2l0YWxuYSBzcmVkc3R2YSwgaW4gc2UgcHJpamF2aXRlIHYga2F0ZXJvIGtvbGkgYXBsaWthY2lqbyBla29zaXN0ZW1hIE5FQVJcIixcblx0XHRjb25uZWN0aW9uRmFpbGVkOiBcIlBvdmV6YXZhIG5pIGJpbGEgdXNwZcWhbmEuXCIsXG5cdFx0Y29ubmVjdGlvblN1Y2Nlc3NmdWw6IFwiUG92ZXphdmEgamUgYmlsYSB1c3BlxaFuYS5cIixcblx0XHRjb25uZWN0ZWQ6IFwiVmHFoWEgZGVuYXJuaWNhIGplIHBvdmV6YW5hLlwiLFxuXHRcdGNvbm5lY3RpbmdUbzogXCJQb3Zlem92YW5qZSB6XCIsXG5cdFx0Y29ubmVjdGluZ01lc3NhZ2U6IHtcblx0XHRcdGluamVjdGVkOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHYgb2tudSByYXrFoWlyaXR2ZVwiLFxuXHRcdFx0YnJvd3NlcjogXCJQbyBwcmV1c21lcml0dmkgcG90cmRpdGUgcG92ZXphdm8gdiBkZW5hcm5pY2lcIixcblx0XHRcdGhhcmR3YXJlOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHMgaGxhZG5vIGRlbmFybmljb1wiLFxuXHRcdFx0YnJpZGdlOiBcIlBvdHJkaXRlIHBvdmV6YXZvIHYgZGVuYXJuaWNpXCJcblx0XHR9XG5cdH0sXG5cdGxlZGdlcjoge1xuXHRcdGNvbm5lY3RXaXRoTGVkZ2VyOiBcIlBvdmXFvml0ZSBzZSB6IExlZGdlclwiLFxuXHRcdG1ha2VTdXJlWW91ckxlZGdlcjogXCJQcmVwcmnEjWFqdGUgc2UsIGRhIGplIHZhxaEgTGVkZ2VyIHZhcm5vIHBvdmV6YW4gaW4gZGEgamUgYXBsaWthY2lqYSBORUFSIG9kcHJ0YSB2IHZhxaFpIG5hcHJhdmlcIixcblx0XHRcImNvbnRpbnVlXCI6IFwiTmFkYWxqdWpcIixcblx0XHRzcGVjaWZ5SERQYXRoOiBcIkRvbG/EjWl0ZSBIRCBwb3RcIixcblx0XHRlbnRlcllvdXJQcmVmZXJyZWRIRFBhdGg6IFwiVm5lc2l0ZSDFvmVsZW5vIEhEIHBvdCwgbmF0byBwb2nFocSNaXRlIHZzZSBha3Rpdm5lIHJhxI11bmUuXCIsXG5cdFx0c2NhbjogXCJTa2VuaXJhanRlXCIsXG5cdFx0cmV0cnk6IFwiUG9za3VzaXRlIHpub3ZhXCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyIG5pIG5hIHZvbGpvXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwiRG9zdG9wIHphIHVwb3JhYm8gbmFwcmF2ZSBMZWRnZXIgemF2cm5qZW5cIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwiTmkgbmFqZGVuaWggcmHEjXVub3ZcIixcblx0XHRzZWxlY3RZb3VyQWNjb3VudHM6IFwiSXpiZXJpdGUgVmHFoWkgcmHEjXVuaVwiLFxuXHRcdGNvbm5lY3RpbmcxQWNjb3VudDogXCJQb3Zlem92YW5qZSBlbmVnYSByYcSNdW5hXCIsXG5cdFx0Y2FudEZpbmRBbnlBY2NvdW50OiBcIk5pIG1vZ2/EjWUgbmFqdGkgbm9iZW5lZ2EgcmHEjXVuYSwgcG92ZXphbmVnYSBzIHRlbSBMZWRnZXJqZW0uIFVzdHZhcml0ZSBub3YgTkVBUiByYcSNdW4gXCIsXG5cdFx0b3JDb25uZWN0QW5Bbm90aGVyTGVkZ2VyOiBcImFsaSBwb3Zlxb5pdGUgZHJ1ZyBMZWRnZXIuLlwiLFxuXHRcdGNvbm5lY3Rpbmc6IFwiUG92ZXpvdmFuamVcIixcblx0XHRvZkFjY291bnRzOiBcInJhxI11bm92XCIsXG5cdFx0ZmFpbGVkVG9BdXRvbWF0aWNhbGx5OiBcIklELWphIHJhxI11bmEgbmkgYmlsbyBtb2dvxI1lIHNhbW9kZWpubyBuYWp0aS4gWmFnb3Rvdml0ZSBnYSByb8SNbm86XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcIk9nbGVqdGUgc2kgc2V6bmFtIHBvb2JsYcWhxI1lbmloIHJhxI11bm92LCBkb2tvbsSNYWp0ZSBwcmlqYXZvIHMga2xpa29tIG5hIHNwb2RuamkgZ3VtYi5cIixcblx0XHRmaW5pc2g6IFwiS29uxI1hanRlXCJcblx0fSxcblx0aW5zdGFsbDoge1xuXHRcdHlvdWxsTmVlZFRvSW5zdGFsbDogXCJNb3JhbGkgZ2EgYm9zdGUgbmFtZXN0aXRpXCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCJuYWRhbGpldmF0aS4gUG8gbmFtZXN0aXR2aVwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcIk9zdmXFvml0ZSBzdHJhbi5cIixcblx0XHRvcGVuOiBcIk9kcHJpdGVcIlxuXHR9LFxuXHRxcjoge1xuXHRcdGNvcGllZFRvQ2xpcGJvYXJkOiBcIktvcGlyYW5vIHYgcG9kbG/Fvm5pIG1hcGlcIixcblx0XHRmYWlsZWRUb0NvcHk6IFwiS29waXJhbmplIHYgcG9kbG/Fvm5pIG1hcGkgbmkgdXNwZWxvXCIsXG5cdFx0c2NhbldpdGhZb3VyTW9iaWxlOiBcIlNrZW5pcmFqdGUgcyBzdm9qbyBtb2JpbG5vIG5hcHJhdm9cIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiIEtvcGlyYWp0ZSB2IHBvZGxvxb5uaSBtYXBpXCIsXG5cdFx0cHJlZmVyVGhlT2ZmaWNpYWw6IFwiUHJlZmVyaXJhanRlIHVyYWRubyBwb2dvdm9ybm8gb2tub1wiLFxuXHRcdG9wZW46IFwiT2Rwcml0ZVwiXG5cdH0sXG5cdHdhbGxldFR5cGVzOiB7XG5cdFx0aGFyZHdhcmU6IFwiSGxhZG5hIGRlbmFybmljYVwiLFxuXHRcdGJyb3dzZXI6IFwiRGVuYXJuaWNhIGJyc2thbG5pa2FcIixcblx0XHRpbmplY3RlZDogXCJSYXrFoWlyaXRldiB6YSBkZW5hcm5pY29cIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlIGRlbmFybmljYVwiLFxuXHRcdG1vYmlsZTogXCJNb2JpbG5hIGRlbmFybmljYVwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwiVGFrb2rFoW5qYSBkZW5hcm5pY2FcIlxuXHR9LFxuXHRleHBvcnRBY2NvdW50czoge1xuXHRcdGNob29zZUFXYWxsZXQ6IFwiSXpiZXJpdGUgZGVuYXJuaWNvXCIsXG5cdFx0dHJhbnNmZXJZb3VyQWNjb3VudHM6IFwiUHJlbmVzaXRlIHN2b2plIHJhxI11bmVcIixcblx0XHRzZWxlY3RBV2FsbGV0OiBcIkl6YmVyaXRlIGRlbmFybmljbywga2kgdXN0cmV6YSB2YcWhaW0gcG90cmViYW0gaW4gcG9kcGlyYSB2YcWhZSBwb3ZlemFuZSByYcSNdW5lLlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCJJemJlcml0ZSB2YcWhaSByYcSNdW5pXCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwiS28gc2Ugb2Rsb8SNaXRlIHphIGRlbmFybmljbywgbGFoa28gaXpiZXJldGUsIGthdGVyZSByYcSNdW5lIMW+ZWxpdGUgcHJlbmVzdGkuXCIsXG5cdFx0ZGlzY2xhaW1lcjogXCJOZSBib3N0ZSBtb2dsaSBwcmVuZXN0aSBSYcSNdW5vdiwga2kgbmlrb2xpIG5pc28gYmlsaSBmaW5hbmNpcmFuaSBhbGkgdXBvcmFibGplbmkgbmEgTkVBUi5cIixcblx0XHR3YXJuaW5nOiBcInRyZW51dG5vIG5lIHBvZHBpcmEgaXp2b3phIHJhxI11bmEuIEl6YmVyaXRlIGRydWdvIGRlbmFybmljb1wiLFxuXHRcdHdhbGxldFR5cGVzOiB7XG5cdFx0XHRoYXJkd2FyZTogXCJIbGFkbmEgZGVuYXJuaWNhXCIsXG5cdFx0XHRicm93c2VyOiBcIkRlbmFybmljYSBicnNrYWxuaWthXCIsXG5cdFx0XHRpbmplY3RlZDogXCJSYXrFoWlyaXRldiB6YSBkZW5hcm5pY29cIixcblx0XHRcdGJyaWRnZTogXCJCcmlkZ2UgZGVuYXJuaWNhXCIsXG5cdFx0XHRtb2JpbGU6IFwiTW9iaWxuYSBkZW5hcm5pY2FcIlxuXHRcdH0sXG5cdFx0c2VsZWN0QWNjb3VudHM6IHtcblx0XHRcdHRpdGxlOiBcIkl6YmVyaXRlIHJhxI11bmkgemEgcHJlbm9zLlwiLFxuXHRcdFx0YnV0dG9uOiBcIlByaWRvYml0ZSBnZXNsb1wiLFxuXHRcdFx0ZGVzZWxlY3RBbGw6IFwiUHJla2xpxI1pIGl6YmlybyB2c2VoXCIsXG5cdFx0XHRzZWxlY3RBbGw6IFwiSXpiZXJpIHZzZVwiLFxuXHRcdFx0dW5hdmFpbGFibGU6IFwiUHJlbm9zIG5pIG5hIHZvbGpvXCIsXG5cdFx0XHRlcnJvcjogXCJSYcSNdW4gbmUgb2JzdGFqYVwiLFxuXHRcdFx0d2FybmluZ0xlZGdlcjogXCJQb3RyZWJuYSBqZSBwb2Rwb3JhIHphIExlZGdlclwiLFxuXHRcdFx0bm9CYWxhbmNlOiBcIlJhxI11biBuaSBmaW5hbmNpcmFuXCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcIktvcGlyYWogemHEjWFzbm8gZ2VzbG9cIixcblx0XHRcdGRlc2M6IFwiVG8gZ2VzbG8gYm9zdGUgbW9yYWxpIHZuZXN0aSwga28gYm9zdGUgemHEjWVsaSBpenZhxb5hdGkgc3ZvamUgcmHEjXVuZSB2IGRydWdvIGRlbmFybmljby5cIixcblx0XHRcdGJ1dHRvbjogXCJOYWRhbGp1anRlXCIsXG5cdFx0XHRsYWJlbDogXCJLbGlrbml0ZSB6YSBrb3BpcmFuamVcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwiR2VzbG8gc2VtIGtvcGlyYWwgYWxpIHphcGlzYWxcIlxuXHRcdH0sXG5cdFx0Y29tcGxldGU6IHtcblx0XHRcdHRpdGxlOiBcIkRva29uxI1hanRlIHByZW5vc1wiLFxuXHRcdFx0ZGVzY09uZTogXCJaZGFqIGJvc3RlIHByZXVzbWVyamVuaSB2IGRlbmFybmljbywga2kgc3RlIGpvIGl6YnJhbGkgemEgZG9rb27EjWFuamUgcHJlbm9zYS5cIixcblx0XHRcdGRlc2NUd286IFwiS28gamUgdXZvem5pIGRlbCBwb3N0b3BrYSBrb27EjWFuIGl6IGl6YnJhbmUgZGVuYXJuaWNlLCBwcml0aXNuaXRlIGd1bWIgemEgZG9rb27EjWFuamUgcG9zdG9wa2EgcHJlbm9zYS5cIixcblx0XHRcdGJ1dHRvbjogXCJLb27EjWFqdGVcIlxuXHRcdH1cblx0fVxufTtcbnZhciBzbCA9IHtcblx0bW9kYWw6IG1vZGFsJDFcbn07XG5cbnZhciBtb2RhbCA9IHtcblx0d2FsbGV0OiB7XG5cdFx0Y29ubmVjdFlvdXJXYWxsZXQ6IFwi0J/QvtCy0LXQttC40YLQtSDRgdCy0L7RmCDQvdC+0LLRh9Cw0L3QuNC6IVwiLFxuXHRcdHdoYXRJc0FXYWxsZXQ6IFwi0KjRgtCwINGY0LUg0L3QvtCy0YfQsNC90LjQuj9cIixcblx0XHRzZWN1cmVBbmRNYW5hZ2U6IFwi0J7QsdC10LfQsdC10LTQuNGC0LUg0Lgg0YPQv9GA0LDQstGZ0LDRmNGC0LUg0YHQstC+0ZjQvtC8INC00LjQs9C40YLQsNC70L3QvtC8INC40LzQvtCy0LjQvdC+0LwuXCIsXG5cdFx0c2FmZWx5U3RvcmU6IFwi0JHQtdC30LHQtdC00L3QviDRh9GD0LLQsNGY0YLQtSDQuCDQv9GA0LXQvdC+0YHQuNGC0LUg0YHQstC+0ZjQtSDQutGA0LjQv9GC0L7QstCw0LvRg9GC0LUg0LggTkZULlwiLFxuXHRcdGxvZ0luVG9Bbnk6IFwi0J/RgNC40ZjQsNCy0LjRgtC1INGB0LUg0L3QsCDQsdC40LvQviDQutC+0ZjRgyDQsNC/0LvQuNC60LDRhtC40ZjRgyBORUFSXCIsXG5cdFx0bm9OZWVkVG9DcmVhdGU6IFwi0J3QtdC80LAg0L/QvtGC0YDQtdCx0LUg0LTQsCDQutGA0LXQuNGA0LDRgtC1INC90L7QstC1INC90LDQu9C+0LPQtSDQuNC70Lgg0LDQutGA0LXQtNC40YLQuNCy0LUuINCf0L7QstC10LbQuNGC0LUg0L3QvtCy0YfQsNC90LjQuiDQuCDRgdC/0YDQtdC80L3QuCDRgdGCZSFcIixcblx0XHRnZXRBV2FsbGV0OiBcItCd0LDQsdCw0LLQuNGC0LUg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdHVzZUFXYWxsZXQ6IFwi0JrQvtGA0LjRgdGC0LjRgtC1INC90L7QstGH0LDQvdC40Log0LTQsCDQvtCx0LXQt9Cx0LXQtNC40YLQtSDQuCDRg9C/0YDQsNCy0ZnQsNGC0LUg0YHQstC+0ZjQuNC8IE5FQVIg0YHRgNC10LTRgdGC0LLQuNC80LAg0Lgg0LTQsCDRgdC1INC/0YDQuNGY0LDQstC40YLQtSDRgyDQsdC40LvQviDQutC+0ZjRgyDQsNC/0LvQuNC60LDRhtC40ZjRgyBORUFSINCx0LXQtyDQv9C+0YLRgNC10LHQtSDQt9CwINC60L7RgNC40YHQvdC40YfQutC40Lwg0LjQvNC10L3QuNC80LAg0Lgg0LvQvtC30LjQvdC60LDQvNCwLlwiLFxuXHRcdGNvbm5lY3Rpb25GYWlsZWQ6IFwi0JLQtdC30LAg0L3QuNGY0LUg0YPRgdC/0L7RgdGC0LDQstGZ0LXQvdCwLlwiLFxuXHRcdGNvbm5lY3Rpb25TdWNjZXNzZnVsOiBcItCS0LXQt9CwINGY0LUg0YPRgdC/0LXQu9CwLlwiLFxuXHRcdGNvbm5lY3RlZDogXCLQn9C+0LLQtdC30LDQvS5cIixcblx0XHRjb25uZWN0aW5nVG86IFwi0J/QvtCy0LXQt9C40LLQsNGa0LUg0L3QsFwiLFxuXHRcdGNvbm5lY3RpbmdNZXNzYWdlOiB7XG5cdFx0XHRpbmplY3RlZDogXCLQn9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YMg0YHQv9C+0ZnQvdC+0Lwg0L/RgNC+0LfQvtGA0YNcIixcblx0XHRcdGJyb3dzZXI6IFwi0J3QsNC60L7QvSDQv9GA0LXRg9GB0LzQtdGA0LDQstCw0ZrQsCwg0L/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGDINC90L7QstGH0LDQvdC40LrRg1wiLFxuXHRcdFx0aGFyZHdhcmU6IFwi0J/QvtGC0LLRgNC00LjRgtC1INCy0LXQt9GDINGB0LAg0YXQu9Cw0LTQvdC40Lwg0L3QvtCy0YfQsNC90LjQutC+0LxcIixcblx0XHRcdGJyaWRnZTogXCLQn9C+0YLQstGA0LTQuNGC0LUg0LLQtdC30YMg0YHQsCDQvdC+0LLRh9Cw0L3QuNC60L7QvFwiXG5cdFx0fVxuXHR9LFxuXHRsZWRnZXI6IHtcblx0XHRjb25uZWN0V2l0aExlZGdlcjogXCLQn9C+0LLQtdC20LjRgtC1INGB0LUg0YHQsCBMZWRnZXJcIixcblx0XHRtYWtlU3VyZVlvdXJMZWRnZXI6IFwi0KPQstC10YDQuNGC0LUg0YHQtSDQtNCwINGY0LUg0LLQsNGIIExlZGdlciDQsdC10LfQsdC10LTQvdC+INC/0L7QstC10LfQsNC9INC4INC00LAg0ZjQtSDQsNC/0LvQuNC60LDRhtC40ZjQsCBORUFSINC+0YLQstC+0YDQtdC90LAg0L3QsCDQstCw0YjQtdC8INGD0YDQtdGS0LDRmNGDXCIsXG5cdFx0XCJjb250aW51ZVwiOiBcItCd0LDRgdGC0LDQstC4XCIsXG5cdFx0c3BlY2lmeUhEUGF0aDogXCLQndCw0LLQtdC00LjRgtC1INCl0JQg0L/Rg9GC0LDRmtGDXCIsXG5cdFx0ZW50ZXJZb3VyUHJlZmVycmVkSERQYXRoOiBcItCj0L3QtdGB0LjRgtC1INC20LXRmdC10L3RgyDQttC10ZnQtdC90YMg0KXQlCDQv9GD0YLQsNGa0YMsINCwINC30LDRgtC40Lwg0YHQutC10L3QuNGA0LDRmNGC0LUg0YHQstC1INCw0LrRgtC40LLQvdC1INC90LDQu9C+0LPQtS5cIixcblx0XHRzY2FuOiBcItCh0LrQtdC90LjRgNCw0ZjRgtC1XCIsXG5cdFx0cmV0cnk6IFwi0J/QvtC60YPRiNCw0Zgg0L/QvtC90L7QstC+XCIsXG5cdFx0bGVkZ2VySXNOb3RBdmFpbGFibGU6IFwiTGVkZ2VyINC90LjRmNC1INC00L7RgdGC0YPQv9Cw0L0uXCIsXG5cdFx0YWNjZXNzRGVuaWVkVG9Vc2VMZWRnZXJEZXZpY2U6IFwi0J/RgNC40YHRgtGD0L8g0ZjQtSDQvtC00LHQuNGY0LXQvSDQt9CwINC60L7RgNC40YjRm9C10ZrQtSBMZWRnZXIg0YPRgNC10ZLQsNGY0LBcIixcblx0XHRub0FjY291bnRzRm91bmQ6IFwi0J3QsGzQvtC30Lgg0L3QuNGB0YMg0L/RgNC+0L3QsNGS0LXQvdC4XCIsXG5cdFx0c2VsZWN0WW91ckFjY291bnRzOiBcItCY0LfQsNCx0LXRgNC40YLQtSDQktCw0Ygg0L3QsGzQvtCzXCIsXG5cdFx0Y29ubmVjdGluZzFBY2NvdW50OiBcItCf0L7QstC10LfQsNGC0LggMSDQvdCwbNC+0LNcIixcblx0XHRjYW50RmluZEFueUFjY291bnQ6IFwi0J3QuNGY0LUg0LzQvtCz0YPRm9C1INC/0YDQvtC90LDRm9C4INC90LjRmNC10LTQsNC9INC90LBs0L7QsyDQv9C+0LLQtdC30LDQvSDRgdCwINC+0LLQuNC8IExlZGdlci3QvtC8LiDQndCw0L/RgNCw0LLQuNGC0LUg0L3QvtCy0LggTkVBUiDQvdCwbNC+0LNcIixcblx0XHRvckNvbm5lY3RBbkFub3RoZXJMZWRnZXI6IFwi0LjQu9C4INC/0L7QstC10LbQuNGC0LUg0LTRgNGD0LPQuCBMZWRnZXIuXCIsXG5cdFx0Y29ubmVjdGluZzogXCLQn9C+0LLQtdC30LjQstCw0ZrQtVwiLFxuXHRcdG9mQWNjb3VudHM6IFwi0L3QsGzQvtCz0LBcIixcblx0XHRmYWlsZWRUb0F1dG9tYXRpY2FsbHk6IFwi0JDRg9GC0L7QvNCw0YLRgdC60L4g0L/RgNC+0L3QsNC70LDQttC10ZrQtSBJRC1hINC90LBs0L7Qs9CwINC90LjRmNC1INGD0YHQv9C10LvQvi4g0J3QsNCy0LXQtNC40YLQtSDQs9CwINGA0YPRh9C90L46XCIsXG5cdFx0b3ZlcnZpZXdUaGVMaXN0T2ZBdXRob3JpemVkOiBcItCf0YDQtdCz0LvQtdC00LDRmNGC0LUg0LvQuNGB0YLRgyDQvtCy0LvQsNGI0ZvQtdC90LjRhSDRgNCw0YfRg9C90LAsINC30LDQstGA0YjQuNGC0LUg0L/RgNC40ZjQsNCy0YMg0LrQu9C40LrQvtC8INC90LAg0LTRg9Cz0LzQtSDQuNGB0L/QvtC0LlwiLFxuXHRcdGZpbmlzaDogXCLQl9Cw0LLRgNGI0LhcIlxuXHR9LFxuXHRpbnN0YWxsOiB7XG5cdFx0eW91bGxOZWVkVG9JbnN0YWxsOiBcItCc0L7RgNCw0ZvQtdGC0LUg0LTQsCDQuNC90YHRgtCw0LvQuNGA0LDRgtC1XCIsXG5cdFx0dG9Db250aW51ZUFmdGVySW5zdGFsbGluZzogXCLQt9CwINC90LDRgdGC0LDQstCw0LouINCd0LDQutC+0L0g0LjQvdGB0YLQsNC70LjRgNCw0ZrQsFwiLFxuXHRcdHJlZnJlc2hUaGVQYWdlOiBcItC/0L7QvdC+0LLQviDRg9GH0LjRgtCw0YLQuCDRgdGC0YDQsNC90LjRhtGDLlwiLFxuXHRcdG9wZW46IFwi0J7RgtCy0L7RgNC4XCJcblx0fSxcblx0cXI6IHtcblx0XHRjb3BpZWRUb0NsaXBib2FyZDogXCLQmtC+0L/QuNGA0LDQvdC+INGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQulwiLFxuXHRcdGZhaWxlZFRvQ29weTogXCLQmtC+0L/QuNGA0LDRmtC1INGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQuiDQvdC40ZjQtSDRg9GB0L/QtdC70L5cIixcblx0XHRzY2FuV2l0aFlvdXJNb2JpbGU6IFwi0KHQutC10L3QuNGA0LDRmNGC0LUg0L/QvtC80L7Rm9GDINC80L7QsdC40LvQvdC+0LMg0YPRgNC10ZLQsNGY0LBcIixcblx0XHRjb3B5VG9DbGlwYm9hcmQ6IFwiINCa0L7Qv9C40YDQsNGYINGDINC80LXRktGD0YHQv9GA0LXQvNC90LjQulwiLFxuXHRcdHByZWZlclRoZU9mZmljaWFsOiBcItCf0YDQtdGE0LXRgNC40YDQsNGC0LUg0LfQstCw0L3QuNGH0L3QuCDQtNC40ZjQsNC70L7QsyDQvtC0XCIsXG5cdFx0b3BlbjogXCLQntGC0LLQvtGA0LhcIlxuXHR9LFxuXHR3YWxsZXRUeXBlczoge1xuXHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRicm93c2VyOiBcItCd0L7QstGH0LDQvdC40Log0L/RgNC10YLRgNCw0LbQuNCy0LDRh9CwLFwiLFxuXHRcdGluamVjdGVkOiBcItCU0L7QtNCw0YLQsNC6INC30LAg0L3QvtCy0YfQsNC90LjQuixcIixcblx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRtb2JpbGU6IFwi0JzQvtCx0LjQu9C90Lgg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdFwiaW5zdGFudC1saW5rXCI6IFwi0JjQvdGB0YLQsNC90YIg0L3QvtCy0YfQsNC90LjQulwiXG5cdH0sXG5cdGV4cG9ydEFjY291bnRzOiB7XG5cdFx0Y2hvb3NlQVdhbGxldDogXCLQmNC30LDQsdC10YDQuNGC0LUg0L3QvtCy0YfQsNC90LjQulwiLFxuXHRcdHRyYW5zZmVyWW91ckFjY291bnRzOiBcItCf0YDQtdC90LXRgdC40YLQtSDRgdCy0L7RmNC1INC90LDQu9C+0LPQtVwiLFxuXHRcdHNlbGVjdEFXYWxsZXQ6IFwi0JjQt9Cw0LHQtdGA0LjRgtC1INC90L7QstGH0LDQvdC40Log0LrQvtGY0Lgg0L7QtNCz0L7QstCw0YDQsCDQstCw0YjQuNC8INC/0L7RgtGA0LXQsdCw0LzQsCDQuCDQutC+0ZjQuCDQv9C+0LTRgNC20LDQstCwINCy0LDRiNC1INC/0L7QstC10LfQsNC90LUg0L3QsNC70L7Qs9C1LlwiLFxuXHRcdHNlbGVjdFlvdXJBY2NvdW50czogXCLQmNC30LDQsdC10YDQuNGC0LUg0LLQsNGI0LUg0L3QsNC70L7Qs9C1XCIsXG5cdFx0YWZ0ZXJEZWNpZGU6IFwi0J3QsNC60L7QvSDRiNGC0L4g0YHQtSDQvtC00LvRg9GH0LjRgtC1INC30LAg0L3QvtCy0YfQsNC90LjQuiwg0LzQvtC20LXRgtC1INC40LfQsNCx0YDQsNGC0Lgg0LrQvtGY0LUg0L3QsNC70L7Qs9C1INC20LXQu9C40YLQtSDQtNCwINC/0YDQtdC90LXRgdC10YLQtS5cIixcblx0XHRkaXNjbGFpbWVyOiBcItCd0LXRm9C10YLQtSDQvNC+0ZvQuCDQtNCwINC/0YDQtdC90LXRgdC10YLQtSDQvdCw0LvQvtCz0LUg0LrQvtGY0Lgg0L3QuNC60LDQtNCwINC90LjRgdGDINCx0LjQu9C4INGE0LjQvdCw0L3RgdC40YDQsNC90Lgg0LjQu9C4INC60L7RgNC40YjRm9C10L3QuCDQvdCwICBORUFSLlwiLFxuXHRcdHdhcm5pbmc6IFwi0YLRgNC10L3Rg9GC0L3QviDQvdC1INC/0L7QtNGA0LbQsNCy0LAg0LjQt9Cy0L7QtyDQvdCw0LvQvtCz0LAuINCY0LfQsNCx0LXRgNC40YLQtSDQtNGA0YPQs9C4INC90L7QstGH0LDQvdC40LouXCIsXG5cdFx0d2FsbGV0VHlwZXM6IHtcblx0XHRcdGhhcmR3YXJlOiBcItCl0LDRgNC00LLQtdGA0YHQutC4INC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdGJyb3dzZXI6IFwi0J3QvtCy0YfQsNC90LjQuiDQv9GA0LXRgtGA0LDQttC40LLQsNGH0LAsXCIsXG5cdFx0XHRpbmplY3RlZDogXCLQlNC+0LTQsNGC0LDQuiDQt9CwINC90L7QstGH0LDQvdC40LosXCIsXG5cdFx0XHRicmlkZ2U6IFwiQnJpZGdlINC90L7QstGH0LDQvdC40LpcIixcblx0XHRcdG1vYmlsZTogXCLQnNC+0LHQuNC70L3QuCDQvdC+0LLRh9Cw0L3QuNC6XCJcblx0XHR9LFxuXHRcdHNlbGVjdEFjY291bnRzOiB7XG5cdFx0XHR0aXRsZTogXCLQmNC30LDQsdC10YDQuNGC0LUg0L3QsNC70L7Qs9C1INC30LAg0L/RgNC10L3QvtGBLlwiLFxuXHRcdFx0YnV0dG9uOiBcItCU0L7QsdC40ZjRgtC1INC/0YDQuNGB0YLRg9C/0L3RgyDRhNGA0LDQt9GDXCIsXG5cdFx0XHRkZXNlbGVjdEFsbDogXCLQn9C+0L3QuNGI0YLQuNGC0LUg0LjQt9Cx0L7RgFwiLFxuXHRcdFx0c2VsZWN0QWxsOiBcItCY0LfQsNCx0LXRgNC40YLQtSDRgdCy0LVcIixcblx0XHRcdHVuYXZhaWxhYmxlOiBcItCi0YDQsNC90YHRhNC10YAg0L3QuNGY0LUg0LTQvtGB0YLRg9C/0LDQvVwiLFxuXHRcdFx0ZXJyb3I6IFwi0J3QsNC70L7QsyDQvdC1INC/0L7RgdGC0L7RmNC4XCIsXG5cdFx0XHR3YXJuaW5nTGVkZ2VyOiBcItCf0L7RgtGA0LXQsdC90LAg0L/QvtC00YDRiNC60LAg0LfQsCBMZWRnZXJcIixcblx0XHRcdG5vQmFsYW5jZTogXCLQndCw0LvQvtCzINC90LjRmNC1INGE0LjQvdCw0L3RgdC40YDQsNC9XCJcblx0XHR9LFxuXHRcdGdldFBhc3NwaHJhc2U6IHtcblx0XHRcdHRpdGxlOiBcItCa0L7Qv9C40YDQsNGYINC/0YDQuNCy0YDQtdC80LXQvdGDINC70L7Qt9C40L3QutGDXCIsXG5cdFx0XHRkZXNjOiBcItCc0L7RgNCw0ZvQtdGC0LUg0LTQsCDRg9C90LXRgdC10YLQtSDQvtCy0YMg0LvQvtC30LjQvdC60YMg0LrQsNC00LAg0L/QvtGH0L3QtdGC0LUg0LTQsCDQuNC30LLQvtC30LjRgtC1INGB0LLQvtGY0LUg0L3QsNC70L7Qs9C1INGDINC00YDRg9Cz0Lgg0L3QvtCy0YfQsNC90LjQui5cIixcblx0XHRcdGJ1dHRvbjogXCLQndCw0YHRgtCw0LLQuNGC0LVcIixcblx0XHRcdGxhYmVsOiBcItCa0LvQuNC60L3QuNGC0LUg0LTQsCDQsdC40YHRgtC1INC60L7Qv9C40YDQsNC70LhcIixcblx0XHRcdGNoZWNrTGFiZWw6IFwi0JrQvtC/0LjRgNCw0L4g0YHQsNC8INC40LvQuCDQt9Cw0L/QuNGB0LDQviDQu9C+0LfQuNC90LrRg1wiXG5cdFx0fSxcblx0XHRjb21wbGV0ZToge1xuXHRcdFx0dGl0bGU6IFwi0JTQvtCy0YDRiNC40YLQtSDRgtGA0LDQvdGB0YTQtdGAXCIsXG5cdFx0XHRkZXNjT25lOiBcItCh0LDQtNCwINGb0LXRgtC1INCx0LjRgtC4INC/0YDQtdGD0YHQvNC10YDQtdC90Lgg0L3QsCDQvdC+0LLRh9Cw0L3QuNC6INC60L7RmNC4INGB0YLQtSDQuNC30LDQsdGA0LDQu9C4INC00LAg0LfQsNCy0YDRiNC40YLQtSDRgtGA0LDQvdGB0YTQtdGALlwiLFxuXHRcdFx0ZGVzY1R3bzogXCLQmtCw0LTQsCDRgdC1INC00LXQviDQv9GA0L7RhtC10YHQsCDRg9Cy0L7Qt9CwINC30LDQstGA0YjQuCDQuNC3INC40LfQsNCx0YDQsNC90L7QsyDQvdC+0LLRh9Cw0L3QuNC60LAsINC/0YDQuNGC0LjRgdC90LjRgtC1INC00YPQs9C80LUg0LTQsCDQt9Cw0LLRgNGI0LjRgtC1INC/0YDQvtGG0LXRgSDQv9GA0LXQvdC+0YHQsC5cIixcblx0XHRcdGJ1dHRvbjogXCLQl9Cw0LLRgNGI0LjRgtC1XCJcblx0XHR9XG5cdH1cbn07XG52YXIgc3IgPSB7XG5cdG1vZGFsOiBtb2RhbFxufTtcblxuY29uc3QgZ2V0TGFuZ3VhZ2UgPSBsYW5ndWFnZUNvZGUgPT4ge1xuICBzd2l0Y2ggKGxhbmd1YWdlQ29kZSkge1xuICAgIGNhc2UgXCJlblwiOlxuICAgICAgcmV0dXJuIGVuO1xuICAgIGNhc2UgXCJlc1wiOlxuICAgICAgcmV0dXJuIGVzO1xuICAgIGNhc2UgXCJ6aFwiOlxuICAgICAgcmV0dXJuIHpoO1xuICAgIGNhc2UgXCJiZ1wiOlxuICAgICAgcmV0dXJuIGJnO1xuICAgIGNhc2UgXCJrb1wiOlxuICAgICAgcmV0dXJuIGtvO1xuICAgIGNhc2UgXCJ2aVwiOlxuICAgICAgcmV0dXJuIHZpO1xuICAgIGNhc2UgXCJoaVwiOlxuICAgICAgcmV0dXJuIGhpO1xuICAgIGNhc2UgXCJhclwiOlxuICAgICAgcmV0dXJuIGFyO1xuICAgIGNhc2UgXCJoclwiOlxuICAgICAgcmV0dXJuIGhyO1xuICAgIGNhc2UgXCJta1wiOlxuICAgICAgcmV0dXJuIG1rO1xuICAgIGNhc2UgXCJzbFwiOlxuICAgICAgcmV0dXJuIHNsO1xuICAgIGNhc2UgXCJzclwiOlxuICAgICAgcmV0dXJuIHNyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZW47XG4gIH1cbn07XG5sZXQgY2hvc2VuTGFuZztcbmNvbnN0IGFsbG93T25seUxhbmd1YWdlID0gbGFuZ0NvZGUgPT4ge1xuICBjaG9zZW5MYW5nID0gbGFuZ0NvZGU7XG59O1xuLy8gKGkuZSBlbi1DQSByZXR1cm5zIGp1c3QgZW4pXG5jb25zdCBzaG9ydGVuTGFuZ3VhZ2VDb2RlID0gbGFuZyA9PiB7XG4gIHJldHVybiBsYW5nLmluZGV4T2YoXCItXCIpICE9PSAtMSA/IGxhbmcuc3BsaXQoXCItXCIpWzBdIDogbGFuZy5zcGxpdChcIl9cIilbMF07XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGZpbmRPYmplY3RQcm9wQnlTdHJpbmdQYXRoID0gKG9iaiwgcHJvcCkgPT4ge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IF9pbmRleCA9IHByb3AuaW5kZXhPZihcIi5cIik7XG4gIGlmIChfaW5kZXggPiAtMSkge1xuICAgIGNvbnN0IGN1cnJlbnRQcm9wID0gcHJvcC5zdWJzdHJpbmcoMCwgX2luZGV4KTtcbiAgICBjb25zdCBuZXh0UHJvcCA9IHByb3Auc3Vic3RyaW5nKF9pbmRleCArIDEpO1xuICAgIHJldHVybiBmaW5kT2JqZWN0UHJvcEJ5U3RyaW5nUGF0aChvYmpbY3VycmVudFByb3BdLCBuZXh0UHJvcCk7XG4gIH1cbiAgcmV0dXJuIG9ialtwcm9wXTtcbn07XG5jb25zdCB0cmFuc2xhdGUgPSBwYXRoID0+IHtcbiAgbGV0IGJyb3dzZXJMYW5nID0gd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXMgPyB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlc1swXSA6IG51bGw7XG4gIGJyb3dzZXJMYW5nID0gYnJvd3NlckxhbmcgfHwgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZTtcbiAgY29uc3QgbGFuZ3VhZ2VDb2RlID0gc2hvcnRlbkxhbmd1YWdlQ29kZShjaG9zZW5MYW5nIHx8IGJyb3dzZXJMYW5nKTtcbiAgY29uc3Qgc2VsZWN0ZWRMYW5ndWFnZSA9IGdldExhbmd1YWdlKGxhbmd1YWdlQ29kZSk7XG4gIGNvbnN0IHRleHQgPSBmaW5kT2JqZWN0UHJvcEJ5U3RyaW5nUGF0aChzZWxlY3RlZExhbmd1YWdlLCBwYXRoKTtcbiAgcmV0dXJuIHRleHQgJiYgdHlwZW9mIHRleHQgPT09IFwic3RyaW5nXCIgPyB0ZXh0IDogcGF0aDtcbn07XG5cbmV4cG9ydCB7IEV2ZW50RW1pdHRlciwgYWxsb3dPbmx5TGFuZ3VhZ2UsIGdldEFjdGl2ZUFjY291bnQsIGlzQ3VycmVudEJyb3dzZXJTdXBwb3J0ZWQsIHNlcmlhbGl6ZU5lcDQxMywgc2V0dXBXYWxsZXRTZWxlY3RvciwgdHJhbnNsYXRlLCB2ZXJpZnlGdWxsS2V5QmVsb25nc1RvVXNlciwgdmVyaWZ5U2lnbmF0dXJlLCB3YWl0Rm9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-wallet-selector+core@8.9.7_near-api-js@3.0.4/node_modules/@near-wallet-selector/core/index.js\n");

/***/ })

};
;