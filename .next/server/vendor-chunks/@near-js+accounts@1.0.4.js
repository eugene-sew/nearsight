"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-js+accounts@1.0.4";
exports.ids = ["vendor-chunks/@near-js+accounts@1.0.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account = void 0;\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@1.2.1/node_modules/@near-js/crypto/lib/index.js\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.1.1/node_modules/@near-js/providers/lib/index.js\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.1.2/node_modules/@near-js/transactions/lib/index.js\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.0.4/node_modules/@near-js/types/lib/index.js\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.1.0/node_modules/@near-js/utils/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst { addKey, createAccount, deleteAccount, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey, stake, transfer, } = transactions_1.actionCreators;\n// Default number of retries with different nonce before giving up on a transaction.\nconst TX_NONCE_RETRY_NUMBER = 12;\n// Default wait until next retry in millis.\nconst TX_NONCE_RETRY_WAIT = 500;\n// Exponential back off for waiting to retry.\nconst TX_NONCE_RETRY_WAIT_BACKOFF = 1.5;\nfunction parseJsonFromRawResponse(response) {\n    return JSON.parse(Buffer.from(response).toString());\n}\nfunction bytesJsonStringify(input) {\n    return Buffer.from(JSON.stringify(input));\n}\n/**\n * This class provides common account related RPC calls including signing transactions with a {@link \"@near-js/crypto\".key_pair.KeyPair | KeyPair}.\n */\nclass Account {\n    constructor(connection, accountId) {\n        /** @hidden */\n        this.accessKeyByPublicKeyCache = {};\n        this.connection = connection;\n        this.accountId = accountId;\n    }\n    /**\n     * Returns basic NEAR account information via the `view_account` RPC query method\n     * @see [https://docs.near.org/api/rpc/contracts#view-account](https://docs.near.org/api/rpc/contracts#view-account)\n     */\n    state() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.connection.provider.query({\n                request_type: 'view_account',\n                account_id: this.accountId,\n                finality: 'optimistic'\n            });\n        });\n    }\n    /**\n     * Create a signed transaction which can be broadcast to the network\n     * @param receiverId NEAR account receiving the transaction\n     * @param actions list of actions to perform as part of the transaction\n     * @see {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}\n     */\n    signTransaction(receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKeyInfo = yield this.findAccessKey(receiverId, actions);\n            if (!accessKeyInfo) {\n                throw new types_1.TypedError(`Can not sign transactions for account ${this.accountId} on network ${this.connection.networkId}, no matching key pair exists for this account`, 'KeyNotFound');\n            }\n            const { accessKey } = accessKeyInfo;\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = block.header.hash;\n            const nonce = accessKey.nonce.add(new bn_js_1.default(1));\n            return yield (0, transactions_1.signTransaction)(receiverId, nonce, actions, (0, utils_1.baseDecode)(blockHash), this.connection.signer, this.accountId, this.connection.networkId);\n        });\n    }\n    /**\n     * Sign a transaction to perform a list of actions and broadcast it using the RPC API.\n     * @see {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider | JsonRpcProvider }\n     *\n     * @param options The options for signing and sending the transaction.\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions The list of actions to be performed in the transaction.\n     * @param options.returnError Whether to return an error if the transaction fails.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    signAndSendTransaction({ receiverId, actions, returnError }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let txHash, signedTx;\n            // TODO: TX_NONCE (different constants for different uses of exponentialBackoff?)\n            const result = yield (0, providers_1.exponentialBackoff)(TX_NONCE_RETRY_WAIT, TX_NONCE_RETRY_NUMBER, TX_NONCE_RETRY_WAIT_BACKOFF, () => __awaiter(this, void 0, void 0, function* () {\n                [txHash, signedTx] = yield this.signTransaction(receiverId, actions);\n                const publicKey = signedTx.transaction.publicKey;\n                try {\n                    return yield this.connection.provider.sendTransaction(signedTx);\n                }\n                catch (error) {\n                    if (error.type === 'InvalidNonce') {\n                        utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} with new nonce.`);\n                        delete this.accessKeyByPublicKeyCache[publicKey.toString()];\n                        return null;\n                    }\n                    if (error.type === 'Expired') {\n                        utils_1.Logger.warn(`Retrying transaction ${receiverId}:${(0, utils_1.baseEncode)(txHash)} due to expired block hash`);\n                        return null;\n                    }\n                    error.context = new types_1.ErrorContext((0, utils_1.baseEncode)(txHash));\n                    throw error;\n                }\n            }));\n            if (!result) {\n                // TODO: This should have different code actually, as means \"transaction not submitted for sure\"\n                throw new types_1.TypedError('nonce retries exceeded for transaction. This usually means there are too many parallel requests with the same access key.', 'RetriesExceeded');\n            }\n            (0, utils_1.printTxOutcomeLogsAndFailures)({ contractId: signedTx.transaction.receiverId, outcome: result });\n            // Should be falsy if result.status.Failure is null\n            if (!returnError && typeof result.status === 'object' && typeof result.status.Failure === 'object' && result.status.Failure !== null) {\n                // if error data has error_message and error_type properties, we consider that node returned an error in the old format\n                if (result.status.Failure.error_message && result.status.Failure.error_type) {\n                    throw new types_1.TypedError(`Transaction ${result.transaction_outcome.id} failed. ${result.status.Failure.error_message}`, result.status.Failure.error_type);\n                }\n                else {\n                    throw (0, utils_1.parseResultError)(result);\n                }\n            }\n            // TODO: if Tx is Unknown or Started.\n            return result;\n        });\n    }\n    /**\n     * Finds the {@link AccessKeyView} associated with the accounts {@link PublicKey} stored in the {@link \"@near-js/keystores\".keystore.KeyStore | Keystore}.\n     *\n     * @todo Find matching access key based on transaction (i.e. receiverId and actions)\n     *\n     * @param receiverId currently unused (see todo)\n     * @param actions currently unused (see todo)\n     * @returns `{ publicKey PublicKey; accessKey: AccessKeyView }`\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    findAccessKey(receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Find matching access key based on transaction (i.e. receiverId and actions)\n            const publicKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n            if (!publicKey) {\n                throw new types_1.TypedError(`no matching key pair found in ${this.connection.signer}`, 'PublicKeyNotFound');\n            }\n            const cachedAccessKey = this.accessKeyByPublicKeyCache[publicKey.toString()];\n            if (cachedAccessKey !== undefined) {\n                return { publicKey, accessKey: cachedAccessKey };\n            }\n            try {\n                const rawAccessKey = yield this.connection.provider.query({\n                    request_type: 'view_access_key',\n                    account_id: this.accountId,\n                    public_key: publicKey.toString(),\n                    finality: 'optimistic'\n                });\n                // store nonce as BN to preserve precision on big number\n                const accessKey = Object.assign(Object.assign({}, rawAccessKey), { nonce: new bn_js_1.default(rawAccessKey.nonce) });\n                // this function can be called multiple times and retrieve the same access key\n                // this checks to see if the access key was already retrieved and cached while\n                // the above network call was in flight. To keep nonce values in line, we return\n                // the cached access key.\n                if (this.accessKeyByPublicKeyCache[publicKey.toString()]) {\n                    return { publicKey, accessKey: this.accessKeyByPublicKeyCache[publicKey.toString()] };\n                }\n                this.accessKeyByPublicKeyCache[publicKey.toString()] = accessKey;\n                return { publicKey, accessKey };\n            }\n            catch (e) {\n                if (e.type == 'AccessKeyDoesNotExist') {\n                    return null;\n                }\n                throw e;\n            }\n        });\n    }\n    /**\n     * Create a new account and deploy a contract to it\n     *\n     * @param contractId NEAR account where the contract is deployed\n     * @param publicKey The public key to add to the created contract account\n     * @param data The compiled contract code\n     * @param amount of NEAR to transfer to the created contract account. Transfer enough to pay for storage https://docs.near.org/docs/concepts/storage-staking\n     */\n    createAndDeployContract(contractId, publicKey, data, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKey = fullAccessKey();\n            yield this.signAndSendTransaction({\n                receiverId: contractId,\n                actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey), deployContract(data)]\n            });\n            const contractAccount = new Account(this.connection, contractId);\n            return contractAccount;\n        });\n    }\n    /**\n     * @param receiverId NEAR account receiving Ⓝ\n     * @param amount Amount to send in yoctoⓃ\n     */\n    sendMoney(receiverId, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId,\n                actions: [transfer(amount)]\n            });\n        });\n    }\n    /**\n     * @param newAccountId NEAR account name to be created\n     * @param publicKey A public key created from the masterAccount\n     */\n    createAccount(newAccountId, publicKey, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKey = fullAccessKey();\n            return this.signAndSendTransaction({\n                receiverId: newAccountId,\n                actions: [createAccount(), transfer(amount), addKey(crypto_1.PublicKey.from(publicKey), accessKey)]\n            });\n        });\n    }\n    /**\n     * @param beneficiaryId The NEAR account that will receive the remaining Ⓝ balance from the account being deleted\n     */\n    deleteAccount(beneficiaryId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            utils_1.Logger.log('Deleting an account does not automatically transfer NFTs and FTs to the beneficiary address. Ensure to transfer assets before deleting.');\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [deleteAccount(beneficiaryId)]\n            });\n        });\n    }\n    /**\n     * @param data The compiled contract code\n     */\n    deployContract(data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [deployContract(data)]\n            });\n        });\n    }\n    /** @hidden */\n    encodeJSContractArgs(contractId, method, args) {\n        return Buffer.concat([Buffer.from(contractId), Buffer.from([0]), Buffer.from(method), Buffer.from([0]), Buffer.from(args)]);\n    }\n    /**\n      * Execute a function call.\n      * @param options The options for the function call.\n      * @param options.contractId The NEAR account ID of the smart contract.\n      * @param options.methodName The name of the method to be called on the smart contract.\n      * @param options.args The arguments to be passed to the method.\n      * @param options.gas The maximum amount of gas to be used for the function call.\n      * @param options.attachedDeposit The amount of NEAR tokens to be attached to the function call.\n      * @param options.walletMeta Metadata for wallet integration.\n      * @param options.walletCallbackUrl The callback URL for wallet integration.\n      * @param options.stringify A function to convert input arguments into bytes array\n      * @param options.jsContract Whether the contract is from JS SDK, automatically encodes args from JS SDK to binary.\n      * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the function call.\n      */\n    functionCall({ contractId, methodName, args = {}, gas = utils_1.DEFAULT_FUNCTION_CALL_GAS, attachedDeposit, walletMeta, walletCallbackUrl, stringify, jsContract }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.validateArgs(args);\n            let functionCallArgs;\n            if (jsContract) {\n                const encodedArgs = this.encodeJSContractArgs(contractId, methodName, JSON.stringify(args));\n                functionCallArgs = ['call_js_contract', encodedArgs, gas, attachedDeposit, null, true];\n            }\n            else {\n                const stringifyArg = stringify === undefined ? transactions_1.stringifyJsonOrBytes : stringify;\n                functionCallArgs = [methodName, args, gas, attachedDeposit, stringifyArg, false];\n            }\n            return this.signAndSendTransaction({\n                receiverId: jsContract ? this.connection.jsvmAccountId : contractId,\n                // eslint-disable-next-line prefer-spread\n                actions: [functionCall.apply(void 0, functionCallArgs)],\n                walletMeta,\n                walletCallbackUrl\n            });\n        });\n    }\n    /**\n     * @see [https://docs.near.org/concepts/basics/accounts/access-keys](https://docs.near.org/concepts/basics/accounts/access-keys)\n     * @todo expand this API to support more options.\n     * @param publicKey A public key to be associated with the contract\n     * @param contractId NEAR account where the contract is deployed\n     * @param methodNames The method names on the contract that should be allowed to be called. Pass null for no method names and '' or [] for any method names.\n     * @param amount Payment in yoctoⓃ that is sent to the contract during this function call\n     */\n    addKey(publicKey, contractId, methodNames, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!methodNames) {\n                methodNames = [];\n            }\n            if (!Array.isArray(methodNames)) {\n                methodNames = [methodNames];\n            }\n            let accessKey;\n            if (!contractId) {\n                accessKey = fullAccessKey();\n            }\n            else {\n                accessKey = functionCallAccessKey(contractId, methodNames, amount);\n            }\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [addKey(crypto_1.PublicKey.from(publicKey), accessKey)]\n            });\n        });\n    }\n    /**\n     * @param publicKey The public key to be deleted\n     * @returns {Promise<FinalExecutionOutcome>}\n     */\n    deleteKey(publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [deleteKey(crypto_1.PublicKey.from(publicKey))]\n            });\n        });\n    }\n    /**\n     * @see [https://near-nodes.io/validator/staking-and-delegation](https://near-nodes.io/validator/staking-and-delegation)\n     *\n     * @param publicKey The public key for the account that's staking\n     * @param amount The account to stake in yoctoⓃ\n     */\n    stake(publicKey, amount) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions: [stake(amount, crypto_1.PublicKey.from(publicKey))]\n            });\n        });\n    }\n    /**\n     * Compose and sign a SignedDelegate action to be executed in a transaction on behalf of this Account instance\n     *\n     * @param options Options for the transaction.\n     * @param options.actions Actions to be included in the meta transaction\n     * @param options.blockHeightTtl Number of blocks past the current block height for which the SignedDelegate action may be included in a meta transaction\n     * @param options.receiverId Receiver account of the meta transaction\n     */\n    signedDelegate({ actions, blockHeightTtl, receiverId, }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { provider, signer } = this.connection;\n            const { header } = yield provider.block({ finality: 'final' });\n            const { accessKey, publicKey } = yield this.findAccessKey(null, null);\n            const delegateAction = (0, transactions_1.buildDelegateAction)({\n                actions,\n                maxBlockHeight: new bn_js_1.default(header.height).add(new bn_js_1.default(blockHeightTtl)),\n                nonce: new bn_js_1.default(accessKey.nonce).add(new bn_js_1.default(1)),\n                publicKey,\n                receiverId,\n                senderId: this.accountId,\n            });\n            const { signedDelegateAction } = yield (0, transactions_1.signDelegateAction)({\n                delegateAction,\n                signer: {\n                    sign: (message) => __awaiter(this, void 0, void 0, function* () {\n                        const { signature } = yield signer.signMessage(message, delegateAction.senderId, this.connection.networkId);\n                        return signature;\n                    }),\n                }\n            });\n            return signedDelegateAction;\n        });\n    }\n    /** @hidden */\n    validateArgs(args) {\n        const isUint8Array = args.byteLength !== undefined && args.byteLength === args.length;\n        if (isUint8Array) {\n            return;\n        }\n        if (Array.isArray(args) || typeof args !== 'object') {\n            throw new types_1.PositionalArgsError();\n        }\n    }\n    /**\n     * Invoke a contract view function using the RPC API.\n     * @see [https://docs.near.org/api/rpc/contracts#call-a-contract-function](https://docs.near.org/api/rpc/contracts#call-a-contract-function)\n     *\n     * @param options Function call options.\n     * @param options.contractId NEAR account where the contract is deployed\n     * @param options.methodName The view-only method (no state mutations) name on the contract as it is written in the contract code\n     * @param options.args Any arguments to the view contract method, wrapped in JSON\n     * @param options.parse Parse the result of the call. Receives a Buffer (bytes array) and converts it to any object. By default result will be treated as json.\n     * @param options.stringify Convert input arguments into a bytes array. By default the input is treated as a JSON.\n     * @param options.jsContract Is contract from JS SDK, automatically encodes args from JS SDK to binary.\n     * @param options.blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     * @returns {Promise<any>}\n     */\n    viewFunction({ contractId, methodName, args = {}, parse = parseJsonFromRawResponse, stringify = bytesJsonStringify, jsContract = false, blockQuery = { finality: 'optimistic' } }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let encodedArgs;\n            this.validateArgs(args);\n            if (jsContract) {\n                encodedArgs = this.encodeJSContractArgs(contractId, methodName, Object.keys(args).length > 0 ? JSON.stringify(args) : '');\n            }\n            else {\n                encodedArgs = stringify(args);\n            }\n            const result = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: 'call_function' }, blockQuery), { account_id: jsContract ? this.connection.jsvmAccountId : contractId, method_name: jsContract ? 'view_js_contract' : methodName, args_base64: encodedArgs.toString('base64') }));\n            if (result.logs) {\n                (0, utils_1.printTxOutcomeLogs)({ contractId, logs: result.logs });\n            }\n            return result.result && result.result.length > 0 && parse(Buffer.from(result.result));\n        });\n    }\n    /**\n     * Returns the state (key value pairs) of this account's contract based on the key prefix.\n     * Pass an empty string for prefix if you would like to return the entire state.\n     * @see [https://docs.near.org/api/rpc/contracts#view-contract-state](https://docs.near.org/api/rpc/contracts#view-contract-state)\n     *\n     * @param prefix allows to filter which keys should be returned. Empty prefix means all keys. String prefix is utf-8 encoded.\n     * @param blockQuery specifies which block to query state at. By default returns last \"optimistic\" block (i.e. not necessarily finalized).\n     */\n    viewState(prefix, blockQuery = { finality: 'optimistic' }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { values } = yield this.connection.provider.query(Object.assign(Object.assign({ request_type: 'view_state' }, blockQuery), { account_id: this.accountId, prefix_base64: Buffer.from(prefix).toString('base64') }));\n            return values.map(({ key, value }) => ({\n                key: Buffer.from(key, 'base64'),\n                value: Buffer.from(value, 'base64')\n            }));\n        });\n    }\n    /**\n     * Get all access keys for the account\n     * @see [https://docs.near.org/api/rpc/access-keys#view-access-key-list](https://docs.near.org/api/rpc/access-keys#view-access-key-list)\n     */\n    getAccessKeys() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.connection.provider.query({\n                request_type: 'view_access_key_list',\n                account_id: this.accountId,\n                finality: 'optimistic'\n            });\n            // Replace raw nonce into a new BN\n            return (_a = response === null || response === void 0 ? void 0 : response.keys) === null || _a === void 0 ? void 0 : _a.map((key) => (Object.assign(Object.assign({}, key), { access_key: Object.assign(Object.assign({}, key.access_key), { nonce: new bn_js_1.default(key.access_key.nonce) }) })));\n        });\n    }\n    /**\n     * Returns a list of authorized apps\n     * @todo update the response value to return all the different keys, not just app keys.\n     */\n    getAccountDetails() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: update the response value to return all the different keys, not just app keys.\n            // Also if we need this function, or getAccessKeys is good enough.\n            const accessKeys = yield this.getAccessKeys();\n            const authorizedApps = accessKeys\n                .filter(item => item.access_key.permission !== 'FullAccess')\n                .map(item => {\n                const perm = item.access_key.permission;\n                return {\n                    contractId: perm.FunctionCall.receiver_id,\n                    amount: perm.FunctionCall.allowance,\n                    publicKey: item.public_key,\n                };\n            });\n            return { authorizedApps };\n        });\n    }\n    /**\n     * Returns calculated account balance\n     */\n    getAccountBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const protocolConfig = yield this.connection.provider.experimental_protocolConfig({ finality: 'final' });\n            const state = yield this.state();\n            const costPerByte = new bn_js_1.default(protocolConfig.runtime_config.storage_amount_per_byte);\n            const stateStaked = new bn_js_1.default(state.storage_usage).mul(costPerByte);\n            const staked = new bn_js_1.default(state.locked);\n            const totalBalance = new bn_js_1.default(state.amount).add(staked);\n            const availableBalance = totalBalance.sub(bn_js_1.default.max(staked, stateStaked));\n            return {\n                total: totalBalance.toString(),\n                stateStaked: stateStaked.toString(),\n                staked: staked.toString(),\n                available: availableBalance.toString()\n            };\n        });\n    }\n    /**\n     * Returns the NEAR tokens balance and validators of a given account that is delegated to the staking pools that are part of the validators set in the current epoch.\n     *\n     * NOTE: If the tokens are delegated to a staking pool that is currently on pause or does not have enough tokens to participate in validation, they won't be accounted for.\n     * @returns {Promise<ActiveDelegatedStakeBalance>}\n     */\n    getActiveDelegatedStakeBalance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = block.header.hash;\n            const epochId = block.header.epoch_id;\n            const { current_validators, next_validators, current_proposals } = yield this.connection.provider.validators(epochId);\n            const pools = new Set();\n            [...current_validators, ...next_validators, ...current_proposals]\n                .forEach((validator) => pools.add(validator.account_id));\n            const uniquePools = [...pools];\n            const promises = uniquePools\n                .map((validator) => (this.viewFunction({\n                contractId: validator,\n                methodName: 'get_account_total_balance',\n                args: { account_id: this.accountId },\n                blockQuery: { blockId: blockHash }\n            })));\n            const results = yield Promise.allSettled(promises);\n            const hasTimeoutError = results.some((result) => {\n                if (result.status === 'rejected' && result.reason.type === 'TimeoutError') {\n                    return true;\n                }\n                return false;\n            });\n            // When RPC is down and return timeout error, throw error\n            if (hasTimeoutError) {\n                throw new Error('Failed to get delegated stake balance');\n            }\n            const summary = results.reduce((result, state, index) => {\n                const validatorId = uniquePools[index];\n                if (state.status === 'fulfilled') {\n                    const currentBN = new bn_js_1.default(state.value);\n                    if (!currentBN.isZero()) {\n                        return Object.assign(Object.assign({}, result), { stakedValidators: [...result.stakedValidators, { validatorId, amount: currentBN.toString() }], total: result.total.add(currentBN) });\n                    }\n                }\n                if (state.status === 'rejected') {\n                    return Object.assign(Object.assign({}, result), { failedValidators: [...result.failedValidators, { validatorId, error: state.reason }] });\n                }\n                return result;\n            }, { stakedValidators: [], failedValidators: [], total: new bn_js_1.default(0) });\n            return Object.assign(Object.assign({}, summary), { total: summary.total.toString() });\n        });\n    }\n}\nexports.Account = Account;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxtSEFBaUI7QUFDMUMsb0JBQW9CLG1CQUFPLENBQUMsNEhBQW9CO0FBQ2hELHVCQUF1QixtQkFBTyxDQUFDLHFJQUF1QjtBQUN0RCxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBZ0I7QUFDeEMsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3hDLGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DLFFBQVEsd0lBQXdJO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLG1EQUFtRDtBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixnQkFBZ0IsYUFBYSwwQkFBMEI7QUFDN0k7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxpRUFBaUUsbUJBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsV0FBVyxHQUFHLGlDQUFpQztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxXQUFXLEdBQUcsaUNBQWlDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsOERBQThEO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLCtCQUErQixVQUFVLG9DQUFvQztBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQiw4QkFBOEIsaUJBQWlCLGVBQWUsd0RBQXdEO0FBQzdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCLDBCQUEwQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSx1QkFBdUI7QUFDckc7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsZ0VBQWdFLG1CQUFtQixnREFBZ0Q7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRDtBQUNBLG1CQUFtQixpQ0FBaUMsa0hBQWtIO0FBQ3RLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0NBQXNDO0FBQzNEO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QyxvQkFBb0IsU0FBUyx5QkFBeUIsbUJBQW1CO0FBQ3pFLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsbUJBQW1CLGlDQUFpQyx1R0FBdUcsMEJBQTBCO0FBQ3JMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RiwrQkFBK0IsaUJBQWlCLDZLQUE2SztBQUMzVDtBQUNBLGtEQUFrRCwrQkFBK0I7QUFDakY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsd0JBQXdCO0FBQzdEO0FBQ0Esb0JBQW9CLFNBQVMscUVBQXFFLDRCQUE0QixpQkFBaUIsbUZBQW1GO0FBQ2xPLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdMQUFnTCxVQUFVLDBDQUEwQyxxQkFBcUIsa0RBQWtELEdBQUc7QUFDOVMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLG1CQUFtQjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsbUJBQW1CO0FBQ3BGO0FBQ0E7QUFDQSxvQkFBb0IseURBQXlEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNEJBQTRCO0FBQ3BELDhCQUE4QjtBQUM5QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxhQUFhLGlEQUFpRCwyQ0FBMkMsdUNBQXVDO0FBQzdNO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxhQUFhLGlEQUFpRCxrQ0FBa0MsR0FBRztBQUM1SjtBQUNBO0FBQ0EsYUFBYSxJQUFJLDJFQUEyRTtBQUM1RixpREFBaUQsY0FBYyxpQ0FBaUM7QUFDaEcsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjAuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2FjY291bnQuanM/YmZhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY2NvdW50ID0gdm9pZCAwO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5lYXItanMvY3J5cHRvXCIpO1xuY29uc3QgcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvcHJvdmlkZXJzXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25zXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdHJhbnNhY3Rpb25zXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90eXBlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCB7IGFkZEtleSwgY3JlYXRlQWNjb3VudCwgZGVsZXRlQWNjb3VudCwgZGVsZXRlS2V5LCBkZXBsb3lDb250cmFjdCwgZnVsbEFjY2Vzc0tleSwgZnVuY3Rpb25DYWxsLCBmdW5jdGlvbkNhbGxBY2Nlc3NLZXksIHN0YWtlLCB0cmFuc2ZlciwgfSA9IHRyYW5zYWN0aW9uc18xLmFjdGlvbkNyZWF0b3JzO1xuLy8gRGVmYXVsdCBudW1iZXIgb2YgcmV0cmllcyB3aXRoIGRpZmZlcmVudCBub25jZSBiZWZvcmUgZ2l2aW5nIHVwIG9uIGEgdHJhbnNhY3Rpb24uXG5jb25zdCBUWF9OT05DRV9SRVRSWV9OVU1CRVIgPSAxMjtcbi8vIERlZmF1bHQgd2FpdCB1bnRpbCBuZXh0IHJldHJ5IGluIG1pbGxpcy5cbmNvbnN0IFRYX05PTkNFX1JFVFJZX1dBSVQgPSA1MDA7XG4vLyBFeHBvbmVudGlhbCBiYWNrIG9mZiBmb3Igd2FpdGluZyB0byByZXRyeS5cbmNvbnN0IFRYX05PTkNFX1JFVFJZX1dBSVRfQkFDS09GRiA9IDEuNTtcbmZ1bmN0aW9uIHBhcnNlSnNvbkZyb21SYXdSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKHJlc3BvbnNlKS50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzSnNvblN0cmluZ2lmeShpbnB1dCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xufVxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGNvbW1vbiBhY2NvdW50IHJlbGF0ZWQgUlBDIGNhbGxzIGluY2x1ZGluZyBzaWduaW5nIHRyYW5zYWN0aW9ucyB3aXRoIGEge0BsaW5rIFwiQG5lYXItanMvY3J5cHRvXCIua2V5X3BhaXIuS2V5UGFpciB8IEtleVBhaXJ9LlxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBhY2NvdW50SWQpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlID0ge307XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuYWNjb3VudElkID0gYWNjb3VudElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGJhc2ljIE5FQVIgYWNjb3VudCBpbmZvcm1hdGlvbiB2aWEgdGhlIGB2aWV3X2FjY291bnRgIFJQQyBxdWVyeSBtZXRob2RcbiAgICAgKiBAc2VlIFtodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1hY2NvdW50XShodHRwczovL2RvY3MubmVhci5vcmcvYXBpL3JwYy9jb250cmFjdHMjdmlldy1hY2NvdW50KVxuICAgICAqL1xuICAgIHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2NvdW50JyxcbiAgICAgICAgICAgICAgICBhY2NvdW50X2lkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ29wdGltaXN0aWMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNpZ25lZCB0cmFuc2FjdGlvbiB3aGljaCBjYW4gYmUgYnJvYWRjYXN0IHRvIHRoZSBuZXR3b3JrXG4gICAgICogQHBhcmFtIHJlY2VpdmVySWQgTkVBUiBhY2NvdW50IHJlY2VpdmluZyB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYWN0aW9ucyBsaXN0IG9mIGFjdGlvbnMgdG8gcGVyZm9ybSBhcyBwYXJ0IG9mIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEBzZWUge0BsaW5rIFwiQG5lYXItanMvcHJvdmlkZXJzXCIuanNvbi1ycGMtcHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbiB8IEpzb25ScGNQcm92aWRlci5zZW5kVHJhbnNhY3Rpb259XG4gICAgICovXG4gICAgc2lnblRyYW5zYWN0aW9uKHJlY2VpdmVySWQsIGFjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleUluZm8gPSB5aWVsZCB0aGlzLmZpbmRBY2Nlc3NLZXkocmVjZWl2ZXJJZCwgYWN0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc0tleUluZm8pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBDYW4gbm90IHNpZ24gdHJhbnNhY3Rpb25zIGZvciBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgbm8gbWF0Y2hpbmcga2V5IHBhaXIgZXhpc3RzIGZvciB0aGlzIGFjY291bnRgLCAnS2V5Tm90Rm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgYWNjZXNzS2V5IH0gPSBhY2Nlc3NLZXlJbmZvO1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuYmxvY2soeyBmaW5hbGl0eTogJ2ZpbmFsJyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IGJsb2NrLmhlYWRlci5oYXNoO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBhY2Nlc3NLZXkubm9uY2UuYWRkKG5ldyBibl9qc18xLmRlZmF1bHQoMSkpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkICgwLCB0cmFuc2FjdGlvbnNfMS5zaWduVHJhbnNhY3Rpb24pKHJlY2VpdmVySWQsIG5vbmNlLCBhY3Rpb25zLCAoMCwgdXRpbHNfMS5iYXNlRGVjb2RlKShibG9ja0hhc2gpLCB0aGlzLmNvbm5lY3Rpb24uc2lnbmVyLCB0aGlzLmFjY291bnRJZCwgdGhpcy5jb25uZWN0aW9uLm5ldHdvcmtJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gdG8gcGVyZm9ybSBhIGxpc3Qgb2YgYWN0aW9ucyBhbmQgYnJvYWRjYXN0IGl0IHVzaW5nIHRoZSBSUEMgQVBJLlxuICAgICAqIEBzZWUge0BsaW5rIFwiQG5lYXItanMvcHJvdmlkZXJzXCIuanNvbi1ycGMtcHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyIHwgSnNvblJwY1Byb3ZpZGVyIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciBzaWduaW5nIGFuZCBzZW5kaW5nIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNlaXZlcklkIFRoZSBORUFSIGFjY291bnQgSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpdmVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFjdGlvbnMgVGhlIGxpc3Qgb2YgYWN0aW9ucyB0byBiZSBwZXJmb3JtZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJldHVybkVycm9yIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGVycm9yIGlmIHRoZSB0cmFuc2FjdGlvbiBmYWlscy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmluYWwgZXhlY3V0aW9uIG91dGNvbWUgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oeyByZWNlaXZlcklkLCBhY3Rpb25zLCByZXR1cm5FcnJvciB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgdHhIYXNoLCBzaWduZWRUeDtcbiAgICAgICAgICAgIC8vIFRPRE86IFRYX05PTkNFIChkaWZmZXJlbnQgY29uc3RhbnRzIGZvciBkaWZmZXJlbnQgdXNlcyBvZiBleHBvbmVudGlhbEJhY2tvZmY/KVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgKDAsIHByb3ZpZGVyc18xLmV4cG9uZW50aWFsQmFja29mZikoVFhfTk9OQ0VfUkVUUllfV0FJVCwgVFhfTk9OQ0VfUkVUUllfTlVNQkVSLCBUWF9OT05DRV9SRVRSWV9XQUlUX0JBQ0tPRkYsICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBbdHhIYXNoLCBzaWduZWRUeF0gPSB5aWVsZCB0aGlzLnNpZ25UcmFuc2FjdGlvbihyZWNlaXZlcklkLCBhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBzaWduZWRUeC50cmFuc2FjdGlvbi5wdWJsaWNLZXk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09ICdJbnZhbGlkTm9uY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1dGlsc18xLkxvZ2dlci53YXJuKGBSZXRyeWluZyB0cmFuc2FjdGlvbiAke3JlY2VpdmVySWR9OiR7KDAsIHV0aWxzXzEuYmFzZUVuY29kZSkodHhIYXNoKX0gd2l0aCBuZXcgbm9uY2UuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50eXBlID09PSAnRXhwaXJlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLndhcm4oYFJldHJ5aW5nIHRyYW5zYWN0aW9uICR7cmVjZWl2ZXJJZH06JHsoMCwgdXRpbHNfMS5iYXNlRW5jb2RlKSh0eEhhc2gpfSBkdWUgdG8gZXhwaXJlZCBibG9jayBoYXNoYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb250ZXh0ID0gbmV3IHR5cGVzXzEuRXJyb3JDb250ZXh0KCgwLCB1dGlsc18xLmJhc2VFbmNvZGUpKHR4SGFzaCkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIGhhdmUgZGlmZmVyZW50IGNvZGUgYWN0dWFsbHksIGFzIG1lYW5zIFwidHJhbnNhY3Rpb24gbm90IHN1Ym1pdHRlZCBmb3Igc3VyZVwiXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcignbm9uY2UgcmV0cmllcyBleGNlZWRlZCBmb3IgdHJhbnNhY3Rpb24uIFRoaXMgdXN1YWxseSBtZWFucyB0aGVyZSBhcmUgdG9vIG1hbnkgcGFyYWxsZWwgcmVxdWVzdHMgd2l0aCB0aGUgc2FtZSBhY2Nlc3Mga2V5LicsICdSZXRyaWVzRXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCB1dGlsc18xLnByaW50VHhPdXRjb21lTG9nc0FuZEZhaWx1cmVzKSh7IGNvbnRyYWN0SWQ6IHNpZ25lZFR4LnRyYW5zYWN0aW9uLnJlY2VpdmVySWQsIG91dGNvbWU6IHJlc3VsdCB9KTtcbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSBmYWxzeSBpZiByZXN1bHQuc3RhdHVzLkZhaWx1cmUgaXMgbnVsbFxuICAgICAgICAgICAgaWYgKCFyZXR1cm5FcnJvciAmJiB0eXBlb2YgcmVzdWx0LnN0YXR1cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJlc3VsdC5zdGF0dXMuRmFpbHVyZSA9PT0gJ29iamVjdCcgJiYgcmVzdWx0LnN0YXR1cy5GYWlsdXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZXJyb3IgZGF0YSBoYXMgZXJyb3JfbWVzc2FnZSBhbmQgZXJyb3JfdHlwZSBwcm9wZXJ0aWVzLCB3ZSBjb25zaWRlciB0aGF0IG5vZGUgcmV0dXJuZWQgYW4gZXJyb3IgaW4gdGhlIG9sZCBmb3JtYXRcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX21lc3NhZ2UgJiYgcmVzdWx0LnN0YXR1cy5GYWlsdXJlLmVycm9yX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcihgVHJhbnNhY3Rpb24gJHtyZXN1bHQudHJhbnNhY3Rpb25fb3V0Y29tZS5pZH0gZmFpbGVkLiAke3Jlc3VsdC5zdGF0dXMuRmFpbHVyZS5lcnJvcl9tZXNzYWdlfWAsIHJlc3VsdC5zdGF0dXMuRmFpbHVyZS5lcnJvcl90eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93ICgwLCB1dGlsc18xLnBhcnNlUmVzdWx0RXJyb3IpKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogaWYgVHggaXMgVW5rbm93biBvciBTdGFydGVkLlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSB7QGxpbmsgQWNjZXNzS2V5Vmlld30gYXNzb2NpYXRlZCB3aXRoIHRoZSBhY2NvdW50cyB7QGxpbmsgUHVibGljS2V5fSBzdG9yZWQgaW4gdGhlIHtAbGluayBcIkBuZWFyLWpzL2tleXN0b3Jlc1wiLmtleXN0b3JlLktleVN0b3JlIHwgS2V5c3RvcmV9LlxuICAgICAqXG4gICAgICogQHRvZG8gRmluZCBtYXRjaGluZyBhY2Nlc3Mga2V5IGJhc2VkIG9uIHRyYW5zYWN0aW9uIChpLmUuIHJlY2VpdmVySWQgYW5kIGFjdGlvbnMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCBjdXJyZW50bHkgdW51c2VkIChzZWUgdG9kbylcbiAgICAgKiBAcGFyYW0gYWN0aW9ucyBjdXJyZW50bHkgdW51c2VkIChzZWUgdG9kbylcbiAgICAgKiBAcmV0dXJucyBgeyBwdWJsaWNLZXkgUHVibGljS2V5OyBhY2Nlc3NLZXk6IEFjY2Vzc0tleVZpZXcgfWBcbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgZmluZEFjY2Vzc0tleShyZWNlaXZlcklkLCBhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBGaW5kIG1hdGNoaW5nIGFjY2VzcyBrZXkgYmFzZWQgb24gdHJhbnNhY3Rpb24gKGkuZS4gcmVjZWl2ZXJJZCBhbmQgYWN0aW9ucylcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5zaWduZXIuZ2V0UHVibGljS2V5KHRoaXMuYWNjb3VudElkLCB0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkKTtcbiAgICAgICAgICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcihgbm8gbWF0Y2hpbmcga2V5IHBhaXIgZm91bmQgaW4gJHt0aGlzLmNvbm5lY3Rpb24uc2lnbmVyfWAsICdQdWJsaWNLZXlOb3RGb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FjaGVkQWNjZXNzS2V5ID0gdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRBY2Nlc3NLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHB1YmxpY0tleSwgYWNjZXNzS2V5OiBjYWNoZWRBY2Nlc3NLZXkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3QWNjZXNzS2V5ID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF90eXBlOiAndmlld19hY2Nlc3Nfa2V5JyxcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudF9pZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpY19rZXk6IHB1YmxpY0tleS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBmaW5hbGl0eTogJ29wdGltaXN0aWMnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgbm9uY2UgYXMgQk4gdG8gcHJlc2VydmUgcHJlY2lzaW9uIG9uIGJpZyBudW1iZXJcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJhd0FjY2Vzc0tleSksIHsgbm9uY2U6IG5ldyBibl9qc18xLmRlZmF1bHQocmF3QWNjZXNzS2V5Lm5vbmNlKSB9KTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYW5kIHJldHJpZXZlIHRoZSBzYW1lIGFjY2VzcyBrZXlcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNoZWNrcyB0byBzZWUgaWYgdGhlIGFjY2VzcyBrZXkgd2FzIGFscmVhZHkgcmV0cmlldmVkIGFuZCBjYWNoZWQgd2hpbGVcbiAgICAgICAgICAgICAgICAvLyB0aGUgYWJvdmUgbmV0d29yayBjYWxsIHdhcyBpbiBmbGlnaHQuIFRvIGtlZXAgbm9uY2UgdmFsdWVzIGluIGxpbmUsIHdlIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjYWNoZWQgYWNjZXNzIGtleS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwdWJsaWNLZXksIGFjY2Vzc0tleTogdGhpcy5hY2Nlc3NLZXlCeVB1YmxpY0tleUNhY2hlW3B1YmxpY0tleS50b1N0cmluZygpXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFjY2Vzc0tleUJ5UHVibGljS2V5Q2FjaGVbcHVibGljS2V5LnRvU3RyaW5nKCldID0gYWNjZXNzS2V5O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHB1YmxpY0tleSwgYWNjZXNzS2V5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gJ0FjY2Vzc0tleURvZXNOb3RFeGlzdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYWNjb3VudCBhbmQgZGVwbG95IGEgY29udHJhY3QgdG8gaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdElkIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IHRvIGFkZCB0byB0aGUgY3JlYXRlZCBjb250cmFjdCBhY2NvdW50XG4gICAgICogQHBhcmFtIGRhdGEgVGhlIGNvbXBpbGVkIGNvbnRyYWN0IGNvZGVcbiAgICAgKiBAcGFyYW0gYW1vdW50IG9mIE5FQVIgdG8gdHJhbnNmZXIgdG8gdGhlIGNyZWF0ZWQgY29udHJhY3QgYWNjb3VudC4gVHJhbnNmZXIgZW5vdWdoIHRvIHBheSBmb3Igc3RvcmFnZSBodHRwczovL2RvY3MubmVhci5vcmcvZG9jcy9jb25jZXB0cy9zdG9yYWdlLXN0YWtpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVBbmREZXBsb3lDb250cmFjdChjb250cmFjdElkLCBwdWJsaWNLZXksIGRhdGEsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5ID0gZnVsbEFjY2Vzc0tleSgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiBjb250cmFjdElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtjcmVhdGVBY2NvdW50KCksIHRyYW5zZmVyKGFtb3VudCksIGFkZEtleShjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpLCBhY2Nlc3NLZXkpLCBkZXBsb3lDb250cmFjdChkYXRhKV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RBY2NvdW50ID0gbmV3IEFjY291bnQodGhpcy5jb25uZWN0aW9uLCBjb250cmFjdElkKTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdEFjY291bnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCBORUFSIGFjY291bnQgcmVjZWl2aW5nIOKTg1xuICAgICAqIEBwYXJhbSBhbW91bnQgQW1vdW50IHRvIHNlbmQgaW4geW9jdG/ik4NcbiAgICAgKi9cbiAgICBzZW5kTW9uZXkocmVjZWl2ZXJJZCwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFt0cmFuc2ZlcihhbW91bnQpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbmV3QWNjb3VudElkIE5FQVIgYWNjb3VudCBuYW1lIHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IEEgcHVibGljIGtleSBjcmVhdGVkIGZyb20gdGhlIG1hc3RlckFjY291bnRcbiAgICAgKi9cbiAgICBjcmVhdGVBY2NvdW50KG5ld0FjY291bnRJZCwgcHVibGljS2V5LCBhbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleSA9IGZ1bGxBY2Nlc3NLZXkoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IG5ld0FjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbY3JlYXRlQWNjb3VudCgpLCB0cmFuc2ZlcihhbW91bnQpLCBhZGRLZXkoY3J5cHRvXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSwgYWNjZXNzS2V5KV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGJlbmVmaWNpYXJ5SWQgVGhlIE5FQVIgYWNjb3VudCB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgcmVtYWluaW5nIOKTgyBiYWxhbmNlIGZyb20gdGhlIGFjY291bnQgYmVpbmcgZGVsZXRlZFxuICAgICAqL1xuICAgIGRlbGV0ZUFjY291bnQoYmVuZWZpY2lhcnlJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdXRpbHNfMS5Mb2dnZXIubG9nKCdEZWxldGluZyBhbiBhY2NvdW50IGRvZXMgbm90IGF1dG9tYXRpY2FsbHkgdHJhbnNmZXIgTkZUcyBhbmQgRlRzIHRvIHRoZSBiZW5lZmljaWFyeSBhZGRyZXNzLiBFbnN1cmUgdG8gdHJhbnNmZXIgYXNzZXRzIGJlZm9yZSBkZWxldGluZy4nKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtkZWxldGVBY2NvdW50KGJlbmVmaWNpYXJ5SWQpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgY29tcGlsZWQgY29udHJhY3QgY29kZVxuICAgICAqL1xuICAgIGRlcGxveUNvbnRyYWN0KGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtkZXBsb3lDb250cmFjdChkYXRhKV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBlbmNvZGVKU0NvbnRyYWN0QXJncyhjb250cmFjdElkLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKGNvbnRyYWN0SWQpLCBCdWZmZXIuZnJvbShbMF0pLCBCdWZmZXIuZnJvbShtZXRob2QpLCBCdWZmZXIuZnJvbShbMF0pLCBCdWZmZXIuZnJvbShhcmdzKV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgICogRXhlY3V0ZSBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RJZCBUaGUgTkVBUiBhY2NvdW50IElEIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgICogQHBhcmFtIG9wdGlvbnMubWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGJlIGNhbGxlZCBvbiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICAqIEBwYXJhbSBvcHRpb25zLmFyZ3MgVGhlIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZC5cbiAgICAgICogQHBhcmFtIG9wdGlvbnMuZ2FzIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBnYXMgdG8gYmUgdXNlZCBmb3IgdGhlIGZ1bmN0aW9uIGNhbGwuXG4gICAgICAqIEBwYXJhbSBvcHRpb25zLmF0dGFjaGVkRGVwb3NpdCBUaGUgYW1vdW50IG9mIE5FQVIgdG9rZW5zIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBmdW5jdGlvbiBjYWxsLlxuICAgICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXRNZXRhIE1ldGFkYXRhIGZvciB3YWxsZXQgaW50ZWdyYXRpb24uXG4gICAgICAqIEBwYXJhbSBvcHRpb25zLndhbGxldENhbGxiYWNrVXJsIFRoZSBjYWxsYmFjayBVUkwgZm9yIHdhbGxldCBpbnRlZ3JhdGlvbi5cbiAgICAgICogQHBhcmFtIG9wdGlvbnMuc3RyaW5naWZ5IEEgZnVuY3Rpb24gdG8gY29udmVydCBpbnB1dCBhcmd1bWVudHMgaW50byBieXRlcyBhcnJheVxuICAgICAgKiBAcGFyYW0gb3B0aW9ucy5qc0NvbnRyYWN0IFdoZXRoZXIgdGhlIGNvbnRyYWN0IGlzIGZyb20gSlMgU0RLLCBhdXRvbWF0aWNhbGx5IGVuY29kZXMgYXJncyBmcm9tIEpTIFNESyB0byBiaW5hcnkuXG4gICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgZnVuY3Rpb24gY2FsbC5cbiAgICAgICovXG4gICAgZnVuY3Rpb25DYWxsKHsgY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgYXJncyA9IHt9LCBnYXMgPSB1dGlsc18xLkRFRkFVTFRfRlVOQ1RJT05fQ0FMTF9HQVMsIGF0dGFjaGVkRGVwb3NpdCwgd2FsbGV0TWV0YSwgd2FsbGV0Q2FsbGJhY2tVcmwsIHN0cmluZ2lmeSwganNDb250cmFjdCB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQXJncyhhcmdzKTtcbiAgICAgICAgICAgIGxldCBmdW5jdGlvbkNhbGxBcmdzO1xuICAgICAgICAgICAgaWYgKGpzQ29udHJhY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVkQXJncyA9IHRoaXMuZW5jb2RlSlNDb250cmFjdEFyZ3MoY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbEFyZ3MgPSBbJ2NhbGxfanNfY29udHJhY3QnLCBlbmNvZGVkQXJncywgZ2FzLCBhdHRhY2hlZERlcG9zaXQsIG51bGwsIHRydWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5naWZ5QXJnID0gc3RyaW5naWZ5ID09PSB1bmRlZmluZWQgPyB0cmFuc2FjdGlvbnNfMS5zdHJpbmdpZnlKc29uT3JCeXRlcyA6IHN0cmluZ2lmeTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxBcmdzID0gW21ldGhvZE5hbWUsIGFyZ3MsIGdhcywgYXR0YWNoZWREZXBvc2l0LCBzdHJpbmdpZnlBcmcsIGZhbHNlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IGpzQ29udHJhY3QgPyB0aGlzLmNvbm5lY3Rpb24uanN2bUFjY291bnRJZCA6IGNvbnRyYWN0SWQsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1zcHJlYWRcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbZnVuY3Rpb25DYWxsLmFwcGx5KHZvaWQgMCwgZnVuY3Rpb25DYWxsQXJncyldLFxuICAgICAgICAgICAgICAgIHdhbGxldE1ldGEsXG4gICAgICAgICAgICAgICAgd2FsbGV0Q2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2NvbmNlcHRzL2Jhc2ljcy9hY2NvdW50cy9hY2Nlc3Mta2V5c10oaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2NvbmNlcHRzL2Jhc2ljcy9hY2NvdW50cy9hY2Nlc3Mta2V5cylcbiAgICAgKiBAdG9kbyBleHBhbmQgdGhpcyBBUEkgdG8gc3VwcG9ydCBtb3JlIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBBIHB1YmxpYyBrZXkgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSBjb250cmFjdElkIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gbWV0aG9kTmFtZXMgVGhlIG1ldGhvZCBuYW1lcyBvbiB0aGUgY29udHJhY3QgdGhhdCBzaG91bGQgYmUgYWxsb3dlZCB0byBiZSBjYWxsZWQuIFBhc3MgbnVsbCBmb3Igbm8gbWV0aG9kIG5hbWVzIGFuZCAnJyBvciBbXSBmb3IgYW55IG1ldGhvZCBuYW1lcy5cbiAgICAgKiBAcGFyYW0gYW1vdW50IFBheW1lbnQgaW4geW9jdG/ik4MgdGhhdCBpcyBzZW50IHRvIHRoZSBjb250cmFjdCBkdXJpbmcgdGhpcyBmdW5jdGlvbiBjYWxsXG4gICAgICovXG4gICAgYWRkS2V5KHB1YmxpY0tleSwgY29udHJhY3RJZCwgbWV0aG9kTmFtZXMsIGFtb3VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFtZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWVzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobWV0aG9kTmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZXMgPSBbbWV0aG9kTmFtZXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGFjY2Vzc0tleTtcbiAgICAgICAgICAgIGlmICghY29udHJhY3RJZCkge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0tleSA9IGZ1bGxBY2Nlc3NLZXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0tleSA9IGZ1bmN0aW9uQ2FsbEFjY2Vzc0tleShjb250cmFjdElkLCBtZXRob2ROYW1lcywgYW1vdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGFjdGlvbnM6IFthZGRLZXkoY3J5cHRvXzEuUHVibGljS2V5LmZyb20ocHVibGljS2V5KSwgYWNjZXNzS2V5KV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSB0byBiZSBkZWxldGVkXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmluYWxFeGVjdXRpb25PdXRjb21lPn1cbiAgICAgKi9cbiAgICBkZWxldGVLZXkocHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbZGVsZXRlS2V5KGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHB1YmxpY0tleSkpXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAc2VlIFtodHRwczovL25lYXItbm9kZXMuaW8vdmFsaWRhdG9yL3N0YWtpbmctYW5kLWRlbGVnYXRpb25dKGh0dHBzOi8vbmVhci1ub2Rlcy5pby92YWxpZGF0b3Ivc3Rha2luZy1hbmQtZGVsZWdhdGlvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBhY2NvdW50IHRoYXQncyBzdGFraW5nXG4gICAgICogQHBhcmFtIGFtb3VudCBUaGUgYWNjb3VudCB0byBzdGFrZSBpbiB5b2N0b+KTg1xuICAgICAqL1xuICAgIHN0YWtlKHB1YmxpY0tleSwgYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zOiBbc3Rha2UoYW1vdW50LCBjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNLZXkpKV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZSBhbmQgc2lnbiBhIFNpZ25lZERlbGVnYXRlIGFjdGlvbiB0byBiZSBleGVjdXRlZCBpbiBhIHRyYW5zYWN0aW9uIG9uIGJlaGFsZiBvZiB0aGlzIEFjY291bnQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hY3Rpb25zIEFjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIG1ldGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ibG9ja0hlaWdodFR0bCBOdW1iZXIgb2YgYmxvY2tzIHBhc3QgdGhlIGN1cnJlbnQgYmxvY2sgaGVpZ2h0IGZvciB3aGljaCB0aGUgU2lnbmVkRGVsZWdhdGUgYWN0aW9uIG1heSBiZSBpbmNsdWRlZCBpbiBhIG1ldGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWNlaXZlcklkIFJlY2VpdmVyIGFjY291bnQgb2YgdGhlIG1ldGEgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBzaWduZWREZWxlZ2F0ZSh7IGFjdGlvbnMsIGJsb2NrSGVpZ2h0VHRsLCByZWNlaXZlcklkLCB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBzaWduZXIgfSA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVhZGVyIH0gPSB5aWVsZCBwcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBhY2Nlc3NLZXksIHB1YmxpY0tleSB9ID0geWllbGQgdGhpcy5maW5kQWNjZXNzS2V5KG51bGwsIG51bGwpO1xuICAgICAgICAgICAgY29uc3QgZGVsZWdhdGVBY3Rpb24gPSAoMCwgdHJhbnNhY3Rpb25zXzEuYnVpbGREZWxlZ2F0ZUFjdGlvbikoe1xuICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgbWF4QmxvY2tIZWlnaHQ6IG5ldyBibl9qc18xLmRlZmF1bHQoaGVhZGVyLmhlaWdodCkuYWRkKG5ldyBibl9qc18xLmRlZmF1bHQoYmxvY2tIZWlnaHRUdGwpKSxcbiAgICAgICAgICAgICAgICBub25jZTogbmV3IGJuX2pzXzEuZGVmYXVsdChhY2Nlc3NLZXkubm9uY2UpLmFkZChuZXcgYm5fanNfMS5kZWZhdWx0KDEpKSxcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJJZCxcbiAgICAgICAgICAgICAgICBzZW5kZXJJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkRGVsZWdhdGVBY3Rpb24gfSA9IHlpZWxkICgwLCB0cmFuc2FjdGlvbnNfMS5zaWduRGVsZWdhdGVBY3Rpb24pKHtcbiAgICAgICAgICAgICAgICBkZWxlZ2F0ZUFjdGlvbixcbiAgICAgICAgICAgICAgICBzaWduZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbjogKG1lc3NhZ2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSB5aWVsZCBzaWduZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSwgZGVsZWdhdGVBY3Rpb24uc2VuZGVySWQsIHRoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmVkRGVsZWdhdGVBY3Rpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHZhbGlkYXRlQXJncyhhcmdzKSB7XG4gICAgICAgIGNvbnN0IGlzVWludDhBcnJheSA9IGFyZ3MuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkICYmIGFyZ3MuYnl0ZUxlbmd0aCA9PT0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChpc1VpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSB8fCB0eXBlb2YgYXJncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlBvc2l0aW9uYWxBcmdzRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2UgYSBjb250cmFjdCB2aWV3IGZ1bmN0aW9uIHVzaW5nIHRoZSBSUEMgQVBJLlxuICAgICAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyNjYWxsLWEtY29udHJhY3QtZnVuY3Rpb25dKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyNjYWxsLWEtY29udHJhY3QtZnVuY3Rpb24pXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBGdW5jdGlvbiBjYWxsIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RJZCBORUFSIGFjY291bnQgd2hlcmUgdGhlIGNvbnRyYWN0IGlzIGRlcGxveWVkXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWV0aG9kTmFtZSBUaGUgdmlldy1vbmx5IG1ldGhvZCAobm8gc3RhdGUgbXV0YXRpb25zKSBuYW1lIG9uIHRoZSBjb250cmFjdCBhcyBpdCBpcyB3cml0dGVuIGluIHRoZSBjb250cmFjdCBjb2RlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXJncyBBbnkgYXJndW1lbnRzIHRvIHRoZSB2aWV3IGNvbnRyYWN0IG1ldGhvZCwgd3JhcHBlZCBpbiBKU09OXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFyc2UgUGFyc2UgdGhlIHJlc3VsdCBvZiB0aGUgY2FsbC4gUmVjZWl2ZXMgYSBCdWZmZXIgKGJ5dGVzIGFycmF5KSBhbmQgY29udmVydHMgaXQgdG8gYW55IG9iamVjdC4gQnkgZGVmYXVsdCByZXN1bHQgd2lsbCBiZSB0cmVhdGVkIGFzIGpzb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RyaW5naWZ5IENvbnZlcnQgaW5wdXQgYXJndW1lbnRzIGludG8gYSBieXRlcyBhcnJheS4gQnkgZGVmYXVsdCB0aGUgaW5wdXQgaXMgdHJlYXRlZCBhcyBhIEpTT04uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuanNDb250cmFjdCBJcyBjb250cmFjdCBmcm9tIEpTIFNESywgYXV0b21hdGljYWxseSBlbmNvZGVzIGFyZ3MgZnJvbSBKUyBTREsgdG8gYmluYXJ5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJsb2NrUXVlcnkgc3BlY2lmaWVzIHdoaWNoIGJsb2NrIHRvIHF1ZXJ5IHN0YXRlIGF0LiBCeSBkZWZhdWx0IHJldHVybnMgbGFzdCBcIm9wdGltaXN0aWNcIiBibG9jayAoaS5lLiBub3QgbmVjZXNzYXJpbHkgZmluYWxpemVkKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fVxuICAgICAqL1xuICAgIHZpZXdGdW5jdGlvbih7IGNvbnRyYWN0SWQsIG1ldGhvZE5hbWUsIGFyZ3MgPSB7fSwgcGFyc2UgPSBwYXJzZUpzb25Gcm9tUmF3UmVzcG9uc2UsIHN0cmluZ2lmeSA9IGJ5dGVzSnNvblN0cmluZ2lmeSwganNDb250cmFjdCA9IGZhbHNlLCBibG9ja1F1ZXJ5ID0geyBmaW5hbGl0eTogJ29wdGltaXN0aWMnIH0gfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGVuY29kZWRBcmdzO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFyZ3MoYXJncyk7XG4gICAgICAgICAgICBpZiAoanNDb250cmFjdCkge1xuICAgICAgICAgICAgICAgIGVuY29kZWRBcmdzID0gdGhpcy5lbmNvZGVKU0NvbnRyYWN0QXJncyhjb250cmFjdElkLCBtZXRob2ROYW1lLCBPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoYXJncykgOiAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGVkQXJncyA9IHN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyByZXF1ZXN0X3R5cGU6ICdjYWxsX2Z1bmN0aW9uJyB9LCBibG9ja1F1ZXJ5KSwgeyBhY2NvdW50X2lkOiBqc0NvbnRyYWN0ID8gdGhpcy5jb25uZWN0aW9uLmpzdm1BY2NvdW50SWQgOiBjb250cmFjdElkLCBtZXRob2RfbmFtZToganNDb250cmFjdCA/ICd2aWV3X2pzX2NvbnRyYWN0JyA6IG1ldGhvZE5hbWUsIGFyZ3NfYmFzZTY0OiBlbmNvZGVkQXJncy50b1N0cmluZygnYmFzZTY0JykgfSkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sb2dzKSB7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxzXzEucHJpbnRUeE91dGNvbWVMb2dzKSh7IGNvbnRyYWN0SWQsIGxvZ3M6IHJlc3VsdC5sb2dzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQgJiYgcmVzdWx0LnJlc3VsdC5sZW5ndGggPiAwICYmIHBhcnNlKEJ1ZmZlci5mcm9tKHJlc3VsdC5yZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXRlIChrZXkgdmFsdWUgcGFpcnMpIG9mIHRoaXMgYWNjb3VudCdzIGNvbnRyYWN0IGJhc2VkIG9uIHRoZSBrZXkgcHJlZml4LlxuICAgICAqIFBhc3MgYW4gZW1wdHkgc3RyaW5nIGZvciBwcmVmaXggaWYgeW91IHdvdWxkIGxpa2UgdG8gcmV0dXJuIHRoZSBlbnRpcmUgc3RhdGUuXG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvY29udHJhY3RzI3ZpZXctY29udHJhY3Qtc3RhdGVdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2NvbnRyYWN0cyN2aWV3LWNvbnRyYWN0LXN0YXRlKVxuICAgICAqXG4gICAgICogQHBhcmFtIHByZWZpeCBhbGxvd3MgdG8gZmlsdGVyIHdoaWNoIGtleXMgc2hvdWxkIGJlIHJldHVybmVkLiBFbXB0eSBwcmVmaXggbWVhbnMgYWxsIGtleXMuIFN0cmluZyBwcmVmaXggaXMgdXRmLTggZW5jb2RlZC5cbiAgICAgKiBAcGFyYW0gYmxvY2tRdWVyeSBzcGVjaWZpZXMgd2hpY2ggYmxvY2sgdG8gcXVlcnkgc3RhdGUgYXQuIEJ5IGRlZmF1bHQgcmV0dXJucyBsYXN0IFwib3B0aW1pc3RpY1wiIGJsb2NrIChpLmUuIG5vdCBuZWNlc3NhcmlseSBmaW5hbGl6ZWQpLlxuICAgICAqL1xuICAgIHZpZXdTdGF0ZShwcmVmaXgsIGJsb2NrUXVlcnkgPSB7IGZpbmFsaXR5OiAnb3B0aW1pc3RpYycgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB2YWx1ZXMgfSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5xdWVyeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyByZXF1ZXN0X3R5cGU6ICd2aWV3X3N0YXRlJyB9LCBibG9ja1F1ZXJ5KSwgeyBhY2NvdW50X2lkOiB0aGlzLmFjY291bnRJZCwgcHJlZml4X2Jhc2U2NDogQnVmZmVyLmZyb20ocHJlZml4KS50b1N0cmluZygnYmFzZTY0JykgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5tYXAoKHsga2V5LCB2YWx1ZSB9KSA9PiAoe1xuICAgICAgICAgICAgICAgIGtleTogQnVmZmVyLmZyb20oa2V5LCAnYmFzZTY0JyksXG4gICAgICAgICAgICAgICAgdmFsdWU6IEJ1ZmZlci5mcm9tKHZhbHVlLCAnYmFzZTY0JylcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgYWNjZXNzIGtleXMgZm9yIHRoZSBhY2NvdW50XG4gICAgICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL2FwaS9ycGMvYWNjZXNzLWtleXMjdmlldy1hY2Nlc3Mta2V5LWxpc3RdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy9hcGkvcnBjL2FjY2Vzcy1rZXlzI3ZpZXctYWNjZXNzLWtleS1saXN0KVxuICAgICAqL1xuICAgIGdldEFjY2Vzc0tleXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLnF1ZXJ5KHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X3R5cGU6ICd2aWV3X2FjY2Vzc19rZXlfbGlzdCcsXG4gICAgICAgICAgICAgICAgYWNjb3VudF9pZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgZmluYWxpdHk6ICdvcHRpbWlzdGljJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHJhdyBub25jZSBpbnRvIGEgbmV3IEJOXG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmtleXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGtleSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwga2V5KSwgeyBhY2Nlc3Nfa2V5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGtleS5hY2Nlc3Nfa2V5KSwgeyBub25jZTogbmV3IGJuX2pzXzEuZGVmYXVsdChrZXkuYWNjZXNzX2tleS5ub25jZSkgfSkgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGF1dGhvcml6ZWQgYXBwc1xuICAgICAqIEB0b2RvIHVwZGF0ZSB0aGUgcmVzcG9uc2UgdmFsdWUgdG8gcmV0dXJuIGFsbCB0aGUgZGlmZmVyZW50IGtleXMsIG5vdCBqdXN0IGFwcCBrZXlzLlxuICAgICAqL1xuICAgIGdldEFjY291bnREZXRhaWxzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogdXBkYXRlIHRoZSByZXNwb25zZSB2YWx1ZSB0byByZXR1cm4gYWxsIHRoZSBkaWZmZXJlbnQga2V5cywgbm90IGp1c3QgYXBwIGtleXMuXG4gICAgICAgICAgICAvLyBBbHNvIGlmIHdlIG5lZWQgdGhpcyBmdW5jdGlvbiwgb3IgZ2V0QWNjZXNzS2V5cyBpcyBnb29kIGVub3VnaC5cbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc0tleXMgPSB5aWVsZCB0aGlzLmdldEFjY2Vzc0tleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6ZWRBcHBzID0gYWNjZXNzS2V5c1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmFjY2Vzc19rZXkucGVybWlzc2lvbiAhPT0gJ0Z1bGxBY2Nlc3MnKVxuICAgICAgICAgICAgICAgIC5tYXAoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVybSA9IGl0ZW0uYWNjZXNzX2tleS5wZXJtaXNzaW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0SWQ6IHBlcm0uRnVuY3Rpb25DYWxsLnJlY2VpdmVyX2lkLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IHBlcm0uRnVuY3Rpb25DYWxsLmFsbG93YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljS2V5OiBpdGVtLnB1YmxpY19rZXksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgYXV0aG9yaXplZEFwcHMgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY2FsY3VsYXRlZCBhY2NvdW50IGJhbGFuY2VcbiAgICAgKi9cbiAgICBnZXRBY2NvdW50QmFsYW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uZmlnID0geWllbGQgdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyLmV4cGVyaW1lbnRhbF9wcm90b2NvbENvbmZpZyh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB5aWVsZCB0aGlzLnN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjb3N0UGVyQnl0ZSA9IG5ldyBibl9qc18xLmRlZmF1bHQocHJvdG9jb2xDb25maWcucnVudGltZV9jb25maWcuc3RvcmFnZV9hbW91bnRfcGVyX2J5dGUpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGVTdGFrZWQgPSBuZXcgYm5fanNfMS5kZWZhdWx0KHN0YXRlLnN0b3JhZ2VfdXNhZ2UpLm11bChjb3N0UGVyQnl0ZSk7XG4gICAgICAgICAgICBjb25zdCBzdGFrZWQgPSBuZXcgYm5fanNfMS5kZWZhdWx0KHN0YXRlLmxvY2tlZCk7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEJhbGFuY2UgPSBuZXcgYm5fanNfMS5kZWZhdWx0KHN0YXRlLmFtb3VudCkuYWRkKHN0YWtlZCk7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVCYWxhbmNlID0gdG90YWxCYWxhbmNlLnN1Yihibl9qc18xLmRlZmF1bHQubWF4KHN0YWtlZCwgc3RhdGVTdGFrZWQpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsQmFsYW5jZS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHN0YXRlU3Rha2VkOiBzdGF0ZVN0YWtlZC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHN0YWtlZDogc3Rha2VkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlOiBhdmFpbGFibGVCYWxhbmNlLnRvU3RyaW5nKClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBORUFSIHRva2VucyBiYWxhbmNlIGFuZCB2YWxpZGF0b3JzIG9mIGEgZ2l2ZW4gYWNjb3VudCB0aGF0IGlzIGRlbGVnYXRlZCB0byB0aGUgc3Rha2luZyBwb29scyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSB2YWxpZGF0b3JzIHNldCBpbiB0aGUgY3VycmVudCBlcG9jaC5cbiAgICAgKlxuICAgICAqIE5PVEU6IElmIHRoZSB0b2tlbnMgYXJlIGRlbGVnYXRlZCB0byBhIHN0YWtpbmcgcG9vbCB0aGF0IGlzIGN1cnJlbnRseSBvbiBwYXVzZSBvciBkb2VzIG5vdCBoYXZlIGVub3VnaCB0b2tlbnMgdG8gcGFydGljaXBhdGUgaW4gdmFsaWRhdGlvbiwgdGhleSB3b24ndCBiZSBhY2NvdW50ZWQgZm9yLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGl2ZURlbGVnYXRlZFN0YWtlQmFsYW5jZT59XG4gICAgICovXG4gICAgZ2V0QWN0aXZlRGVsZWdhdGVkU3Rha2VCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIuYmxvY2soeyBmaW5hbGl0eTogJ2ZpbmFsJyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrSGFzaCA9IGJsb2NrLmhlYWRlci5oYXNoO1xuICAgICAgICAgICAgY29uc3QgZXBvY2hJZCA9IGJsb2NrLmhlYWRlci5lcG9jaF9pZDtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudF92YWxpZGF0b3JzLCBuZXh0X3ZhbGlkYXRvcnMsIGN1cnJlbnRfcHJvcG9zYWxzIH0gPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24ucHJvdmlkZXIudmFsaWRhdG9ycyhlcG9jaElkKTtcbiAgICAgICAgICAgIGNvbnN0IHBvb2xzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgWy4uLmN1cnJlbnRfdmFsaWRhdG9ycywgLi4ubmV4dF92YWxpZGF0b3JzLCAuLi5jdXJyZW50X3Byb3Bvc2Fsc11cbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgodmFsaWRhdG9yKSA9PiBwb29scy5hZGQodmFsaWRhdG9yLmFjY291bnRfaWQpKTtcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVBvb2xzID0gWy4uLnBvb2xzXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gdW5pcXVlUG9vbHNcbiAgICAgICAgICAgICAgICAubWFwKCh2YWxpZGF0b3IpID0+ICh0aGlzLnZpZXdGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgY29udHJhY3RJZDogdmFsaWRhdG9yLFxuICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6ICdnZXRfYWNjb3VudF90b3RhbF9iYWxhbmNlJyxcbiAgICAgICAgICAgICAgICBhcmdzOiB7IGFjY291bnRfaWQ6IHRoaXMuYWNjb3VudElkIH0sXG4gICAgICAgICAgICAgICAgYmxvY2tRdWVyeTogeyBibG9ja0lkOiBibG9ja0hhc2ggfVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSB5aWVsZCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICAgICAgICAgICAgY29uc3QgaGFzVGltZW91dEVycm9yID0gcmVzdWx0cy5zb21lKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ3JlamVjdGVkJyAmJiByZXN1bHQucmVhc29uLnR5cGUgPT09ICdUaW1lb3V0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdoZW4gUlBDIGlzIGRvd24gYW5kIHJldHVybiB0aW1lb3V0IGVycm9yLCB0aHJvdyBlcnJvclxuICAgICAgICAgICAgaWYgKGhhc1RpbWVvdXRFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBkZWxlZ2F0ZWQgc3Rha2UgYmFsYW5jZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IHJlc3VsdHMucmVkdWNlKChyZXN1bHQsIHN0YXRlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvcklkID0gdW5pcXVlUG9vbHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09ICdmdWxmaWxsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCTiA9IG5ldyBibl9qc18xLmRlZmF1bHQoc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRCTi5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0KSwgeyBzdGFrZWRWYWxpZGF0b3JzOiBbLi4ucmVzdWx0LnN0YWtlZFZhbGlkYXRvcnMsIHsgdmFsaWRhdG9ySWQsIGFtb3VudDogY3VycmVudEJOLnRvU3RyaW5nKCkgfV0sIHRvdGFsOiByZXN1bHQudG90YWwuYWRkKGN1cnJlbnRCTikgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN1bHQpLCB7IGZhaWxlZFZhbGlkYXRvcnM6IFsuLi5yZXN1bHQuZmFpbGVkVmFsaWRhdG9ycywgeyB2YWxpZGF0b3JJZCwgZXJyb3I6IHN0YXRlLnJlYXNvbiB9XSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIHsgc3Rha2VkVmFsaWRhdG9yczogW10sIGZhaWxlZFZhbGlkYXRvcnM6IFtdLCB0b3RhbDogbmV3IGJuX2pzXzEuZGVmYXVsdCgwKSB9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN1bW1hcnkpLCB7IHRvdGFsOiBzdW1tYXJ5LnRvdGFsLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudCA9IEFjY291bnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_2fa.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_2fa.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Account2FA = void 0;\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@1.2.1/node_modules/@near-js/crypto/lib/index.js\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.0.4/node_modules/@near-js/types/lib/index.js\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.1.1/node_modules/@near-js/providers/lib/index.js\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.1.2/node_modules/@near-js/transactions/lib/index.js\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.1.0/node_modules/@near-js/utils/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst account_multisig_1 = __webpack_require__(/*! ./account_multisig */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_multisig.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/constants.js\");\nconst types_2 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/types.js\");\nconst { addKey, deleteKey, deployContract, fullAccessKey, functionCall, functionCallAccessKey } = transactions_1.actionCreators;\nclass Account2FA extends account_multisig_1.AccountMultisig {\n    constructor(connection, accountId, options) {\n        super(connection, accountId, options);\n        this.helperUrl = 'https://helper.testnet.near.org';\n        this.helperUrl = options.helperUrl || this.helperUrl;\n        this.storage = options.storage;\n        this.sendCode = options.sendCode || this.sendCodeDefault;\n        this.getCode = options.getCode || this.getCodeDefault;\n        this.verifyCode = options.verifyCode || this.verifyCodeDefault;\n        this.onConfirmResult = options.onConfirmResult;\n    }\n    /**\n     * Sign a transaction to preform a list of actions and broadcast it using the RPC API.\n     * @see {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider.sendTransaction | JsonRpcProvider.sendTransaction}\n     *\n     * @param options Options for the transaction.\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions The list of actions to be included in the transaction.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.signAndSendTransaction.call(this, { receiverId, actions });\n            // TODO: Should following override onRequestResult in superclass instead of doing custom signAndSendTransaction?\n            yield this.sendCode();\n            const result = yield this.promptAndVerify();\n            if (this.onConfirmResult) {\n                yield this.onConfirmResult(result);\n            }\n            return result;\n        });\n    }\n    // default helpers for CH deployments of multisig\n    /**\n     * Deploy a multisig contract with 2FA and handle the deployment process.\n     * @param contractBytes - The bytecode of the multisig contract.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deployment.\n     */\n    deployMultisig(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransactionWithAccount: { get: () => super.signAndSendTransactionWithAccount }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const seedOrLedgerKey = (yield this.getRecoveryMethods()).data\n                .filter(({ kind, publicKey }) => (kind === 'phrase' || kind === 'ledger') && publicKey !== null)\n                .map((rm) => rm.publicKey);\n            const fak2lak = (yield this.getAccessKeys())\n                .filter(({ public_key, access_key: { permission } }) => permission === 'FullAccess' && !seedOrLedgerKey.includes(public_key))\n                .map((ak) => ak.public_key)\n                .map(toPK);\n            const confirmOnlyKey = toPK((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            const newArgs = Buffer.from(JSON.stringify({ 'num_confirmations': 2 }));\n            const actions = [\n                ...fak2lak.map((pk) => deleteKey(pk)),\n                ...fak2lak.map((pk) => addKey(pk, functionCallAccessKey(accountId, constants_1.MULTISIG_CHANGE_METHODS, null))),\n                addKey(confirmOnlyKey, functionCallAccessKey(accountId, constants_1.MULTISIG_CONFIRM_METHODS, null)),\n                deployContract(contractBytes),\n            ];\n            const newFunctionCallActionBatch = actions.concat(functionCall('new', newArgs, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT));\n            utils_1.Logger.log('deploying multisig contract for', accountId);\n            const { stateStatus: multisigStateStatus } = yield this.checkMultisigCodeAndStateStatus(contractBytes);\n            switch (multisigStateStatus) {\n                case types_2.MultisigStateStatus.STATE_NOT_INITIALIZED:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, newFunctionCallActionBatch);\n                case types_2.MultisigStateStatus.VALID_STATE:\n                    return yield _super.signAndSendTransactionWithAccount.call(this, accountId, actions);\n                case types_2.MultisigStateStatus.INVALID_STATE:\n                    throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState');\n                default:\n                    throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n        });\n    }\n    /**\n     * Disable 2FA with the option to clean up contract state.\n     * @param options Options for disabling 2FA.\n     * @param options.contractBytes The bytecode of the contract to deploy.\n     * @param options.cleanupContractBytes The bytecode of the cleanup contract (optional).\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.\n     */\n    disableWithFAK({ contractBytes, cleanupContractBytes }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let cleanupActions = [];\n            if (cleanupContractBytes) {\n                yield this.deleteAllRequests().catch(e => e);\n                cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes);\n            }\n            const keyConversionActions = yield this.get2faDisableKeyConversionActions();\n            const actions = [\n                ...cleanupActions,\n                ...keyConversionActions,\n                deployContract(contractBytes)\n            ];\n            const accessKeyInfo = yield this.findAccessKey(this.accountId, actions);\n            if (accessKeyInfo && accessKeyInfo.accessKey && accessKeyInfo.accessKey.permission !== 'FullAccess') {\n                throw new types_1.TypedError('No full access key found in keystore. Unable to bypass multisig', 'NoFAKFound');\n            }\n            return this.signAndSendTransactionWithAccount(this.accountId, actions);\n        });\n    }\n    /**\n     * Retrieves cleanup actions for disabling 2FA.\n     * @param cleanupContractBytes - The bytecode of the cleanup contract.\n     * @returns {Promise<Action[]>} - A promise that resolves to an array of cleanup actions.\n     */\n    get2faDisableCleanupActions(cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentAccountState = yield this.viewState('').catch(error => {\n                const cause = error.cause && error.cause.name;\n                if (cause == 'NO_CONTRACT_CODE') {\n                    return [];\n                }\n                throw cause == 'TOO_LARGE_CONTRACT_STATE'\n                    ? new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account has existing state.`, 'ContractHasExistingState')\n                    : error;\n            });\n            const currentAccountStateKeys = currentAccountState.map(({ key }) => key.toString('base64'));\n            return currentAccountState.length ? [\n                deployContract(cleanupContractBytes),\n                functionCall('clean', { keys: currentAccountStateKeys }, constants_1.MULTISIG_GAS, new bn_js_1.default('0'))\n            ] : [];\n        });\n    }\n    /**\n     * Retrieves key conversion actions for disabling 2FA.\n     * @returns {Promise<Action[]>} - A promise that resolves to an array of key conversion actions.\n     */\n    get2faDisableKeyConversionActions() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const accessKeys = yield this.getAccessKeys();\n            const lak2fak = accessKeys\n                .filter(({ access_key }) => access_key.permission !== 'FullAccess')\n                .filter(({ access_key }) => {\n                const perm = access_key.permission.FunctionCall;\n                return perm.receiver_id === accountId &&\n                    perm.method_names.length === 4 &&\n                    perm.method_names.includes('add_request_and_confirm');\n            });\n            const confirmOnlyKey = crypto_1.PublicKey.from((yield this.postSignedJson('/2fa/getAccessKey', { accountId })).publicKey);\n            return [\n                deleteKey(confirmOnlyKey),\n                ...lak2fak.map(({ public_key }) => deleteKey(crypto_1.PublicKey.from(public_key))),\n                ...lak2fak.map(({ public_key }) => addKey(crypto_1.PublicKey.from(public_key), fullAccessKey()))\n            ];\n        });\n    }\n    /**\n     * This method converts LAKs back to FAKs, clears state and deploys an 'empty' contract (contractBytes param)\n     * @param [contractBytes]{@link https://github.com/near/near-wallet/blob/master/packages/frontend/src/wasm/main.wasm?raw=true}\n     * @param [cleanupContractBytes]{@link https://github.com/near/core-contracts/blob/master/state-manipulation/res/state_cleanup.wasm?raw=true}\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the operation.\n     */\n    disable(contractBytes, cleanupContractBytes) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { stateStatus } = yield this.checkMultisigCodeAndStateStatus();\n            if (stateStatus !== types_2.MultisigStateStatus.VALID_STATE && stateStatus !== types_2.MultisigStateStatus.STATE_NOT_INITIALIZED) {\n                throw new types_1.TypedError(`Can not deploy a contract to account ${this.accountId} on network ${this.connection.networkId}, the account state could not be verified.`, 'ContractStateUnknown');\n            }\n            let deleteAllRequestsError;\n            yield this.deleteAllRequests().catch(e => deleteAllRequestsError = e);\n            const cleanupActions = yield this.get2faDisableCleanupActions(cleanupContractBytes).catch(e => {\n                if (e.type === 'ContractHasExistingState') {\n                    throw deleteAllRequestsError || e;\n                }\n                throw e;\n            });\n            const actions = [\n                ...cleanupActions,\n                ...(yield this.get2faDisableKeyConversionActions()),\n                deployContract(contractBytes),\n            ];\n            utils_1.Logger.log('disabling 2fa for', this.accountId);\n            return yield this.signAndSendTransaction({\n                receiverId: this.accountId,\n                actions\n            });\n        });\n    }\n    /**\n     * Default implementation for sending the 2FA code.\n     * @returns {Promise<string>} - A promise that resolves to the request ID.\n     */\n    sendCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const { requestId } = this.getRequest();\n            const method = yield this.get2faMethod();\n            yield this.postSignedJson('/2fa/send', {\n                accountId,\n                method,\n                requestId,\n            });\n            return requestId;\n        });\n    }\n    getCodeDefault() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('There is no getCode callback provided. Please provide your own in AccountMultisig constructor options. It has a parameter method where method.kind is \"email\" or \"phone\".');\n        });\n    }\n    /**\n     * Prompts the user to enter and verify the 2FA code.\n     * @returns {Promise<any>} - A promise that resolves to the verification result.\n     */\n    promptAndVerify() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const method = yield this.get2faMethod();\n            const securityCode = yield this.getCode(method);\n            try {\n                const result = yield this.verifyCode(securityCode);\n                // TODO: Parse error from result for real (like in normal account.signAndSendTransaction)\n                return result;\n            }\n            catch (e) {\n                utils_1.Logger.warn('Error validating security code:', e);\n                if (e.toString().includes('invalid 2fa code provided') || e.toString().includes('2fa code not valid')) {\n                    return yield this.promptAndVerify();\n                }\n                throw e;\n            }\n        });\n    }\n    /**\n     * Verify the 2FA code using the default method.\n     * @param securityCode - The security code to verify.\n     * @returns {Promise<any>} A promise that resolves to the verification result.\n     */\n    verifyCodeDefault(securityCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const request = this.getRequest();\n            if (!request) {\n                throw new Error('no request pending');\n            }\n            const { requestId } = request;\n            return yield this.postSignedJson('/2fa/verify', {\n                accountId,\n                securityCode,\n                requestId\n            });\n        });\n    }\n    /**\n     * Retrieves recovery methods for the account.\n     * @returns {Promise<{ accountId: string, data: any }>} - A promise that resolves to recovery methods data.\n     */\n    getRecoveryMethods() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            return {\n                accountId,\n                data: yield this.postSignedJson('/account/recoveryMethods', { accountId })\n            };\n        });\n    }\n    /**\n     * Gets the 2FA method (kind and detail).\n     * @returns {Promise<{ kind: string, detail: string }>} A promise that resolves to the 2FA method.\n     */\n    get2faMethod() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let { data } = yield this.getRecoveryMethods();\n            if (data && data.length) {\n                data = data.find((m) => m.kind.indexOf('2fa-') === 0);\n            }\n            if (!data)\n                return null;\n            const { kind, detail } = data;\n            return { kind, detail };\n        });\n    }\n    /**\n    * Generates a signature for the latest finalized block.\n    * @returns {Promise<{ blockNumber: string, blockNumberSignature: string }>} - A promise that resolves to the signature information.\n    */\n    signatureFor() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockNumber = block.header.height.toString();\n            const signed = yield this.connection.signer.signMessage(Buffer.from(blockNumber), accountId, this.connection.networkId);\n            const blockNumberSignature = Buffer.from(signed.signature).toString('base64');\n            return { blockNumber, blockNumberSignature };\n        });\n    }\n    /**\n    * Sends a signed JSON request to a specified path.\n    * @param path - The path for the request.\n    * @param body - The request body.\n    * @returns {Promise<any>} - A promise that resolves to the response from the helper.\n    */\n    postSignedJson(path, body) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield (0, providers_1.fetchJson)(this.helperUrl + path, JSON.stringify(Object.assign(Object.assign({}, body), (yield this.signatureFor()))));\n        });\n    }\n}\nexports.Account2FA = Account2FA;\n// helpers\nconst toPK = (pk) => crypto_1.PublicKey.from(pk);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50XzJmYS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsaUJBQWlCLG1CQUFPLENBQUMsbUhBQWlCO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLGdIQUFnQjtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0SEFBb0I7QUFDaEQsdUJBQXVCLG1CQUFPLENBQUMscUlBQXVCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLGdIQUFnQjtBQUN4QyxnQ0FBZ0MsbUJBQU8sQ0FBQyxrRkFBTztBQUMvQywyQkFBMkIsbUJBQU8sQ0FBQyxxSUFBb0I7QUFDdkQsb0JBQW9CLG1CQUFPLENBQUMsdUhBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsK0dBQVM7QUFDakMsUUFBUSx3RkFBd0Y7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSw2REFBNkQscUJBQXFCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEIsY0FBYztBQUNuRTtBQUNBO0FBQ0EsMEZBQTBGLFdBQVc7QUFDckcseURBQXlELHdCQUF3QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQ2hKO0FBQ0EseUZBQXlGLGdCQUFnQixhQUFhLDBCQUEwQjtBQUNoSjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EscUJBQXFCLHFDQUFxQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQzVJO0FBQ0EsYUFBYTtBQUNiLHVFQUF1RSxLQUFLO0FBQzVFO0FBQ0E7QUFDQSx3Q0FBd0MsK0JBQStCO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBLDJCQUEyQixZQUFZO0FBQ3ZDLDJCQUEyQixZQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZHQUE2RyxXQUFXO0FBQ3hIO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QyxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIscUNBQXFDO0FBQ3JDLGlCQUFpQixnQ0FBZ0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxxRkFBcUYsZ0JBQWdCLGFBQWEsMEJBQTBCO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVLDhCQUE4QixHQUFHO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSw4RUFBOEUsV0FBVztBQUN6RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVSw4QkFBOEIsR0FBRztBQUM1RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVSxtREFBbUQsR0FBRztBQUNoRjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQyxpRUFBaUUsbUJBQW1CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDtBQUN4SCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjAuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2FjY291bnRfMmZhLmpzPzIxMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWNjb3VudDJGQSA9IHZvaWQgMDtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBuZWFyLWpzL2NyeXB0b1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdHlwZXNcIik7XG5jb25zdCBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9wcm92aWRlcnNcIik7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90cmFuc2FjdGlvbnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3V0aWxzXCIpO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuY29uc3QgYWNjb3VudF9tdWx0aXNpZ18xID0gcmVxdWlyZShcIi4vYWNjb3VudF9tdWx0aXNpZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdHlwZXNfMiA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgeyBhZGRLZXksIGRlbGV0ZUtleSwgZGVwbG95Q29udHJhY3QsIGZ1bGxBY2Nlc3NLZXksIGZ1bmN0aW9uQ2FsbCwgZnVuY3Rpb25DYWxsQWNjZXNzS2V5IH0gPSB0cmFuc2FjdGlvbnNfMS5hY3Rpb25DcmVhdG9ycztcbmNsYXNzIEFjY291bnQyRkEgZXh0ZW5kcyBhY2NvdW50X211bHRpc2lnXzEuQWNjb3VudE11bHRpc2lnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uLCBhY2NvdW50SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgYWNjb3VudElkLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5oZWxwZXJVcmwgPSAnaHR0cHM6Ly9oZWxwZXIudGVzdG5ldC5uZWFyLm9yZyc7XG4gICAgICAgIHRoaXMuaGVscGVyVXJsID0gb3B0aW9ucy5oZWxwZXJVcmwgfHwgdGhpcy5oZWxwZXJVcmw7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZTtcbiAgICAgICAgdGhpcy5zZW5kQ29kZSA9IG9wdGlvbnMuc2VuZENvZGUgfHwgdGhpcy5zZW5kQ29kZURlZmF1bHQ7XG4gICAgICAgIHRoaXMuZ2V0Q29kZSA9IG9wdGlvbnMuZ2V0Q29kZSB8fCB0aGlzLmdldENvZGVEZWZhdWx0O1xuICAgICAgICB0aGlzLnZlcmlmeUNvZGUgPSBvcHRpb25zLnZlcmlmeUNvZGUgfHwgdGhpcy52ZXJpZnlDb2RlRGVmYXVsdDtcbiAgICAgICAgdGhpcy5vbkNvbmZpcm1SZXN1bHQgPSBvcHRpb25zLm9uQ29uZmlybVJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiBhIHRyYW5zYWN0aW9uIHRvIHByZWZvcm0gYSBsaXN0IG9mIGFjdGlvbnMgYW5kIGJyb2FkY2FzdCBpdCB1c2luZyB0aGUgUlBDIEFQSS5cbiAgICAgKiBAc2VlIHtAbGluayBcIkBuZWFyLWpzL3Byb3ZpZGVyc1wiLmpzb24tcnBjLXByb3ZpZGVyLkpzb25ScGNQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24gfCBKc29uUnBjUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9ufVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY2VpdmVySWQgVGhlIE5FQVIgYWNjb3VudCBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gcmVjZWl2ZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWN0aW9ucyBUaGUgbGlzdCBvZiBhY3Rpb25zIHRvIGJlIGluY2x1ZGVkIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmluYWwgZXhlY3V0aW9uIG91dGNvbWUgb2YgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uOiB7IGdldDogKCkgPT4gc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbiB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgZm9sbG93aW5nIG92ZXJyaWRlIG9uUmVxdWVzdFJlc3VsdCBpbiBzdXBlcmNsYXNzIGluc3RlYWQgb2YgZG9pbmcgY3VzdG9tIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb24/XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRDb2RlKCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnByb21wdEFuZFZlcmlmeSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMub25Db25maXJtUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5vbkNvbmZpcm1SZXN1bHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBkZWZhdWx0IGhlbHBlcnMgZm9yIENIIGRlcGxveW1lbnRzIG9mIG11bHRpc2lnXG4gICAgLyoqXG4gICAgICogRGVwbG95IGEgbXVsdGlzaWcgY29udHJhY3Qgd2l0aCAyRkEgYW5kIGhhbmRsZSB0aGUgZGVwbG95bWVudCBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSBjb250cmFjdEJ5dGVzIC0gVGhlIGJ5dGVjb2RlIG9mIHRoZSBtdWx0aXNpZyBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmluYWwgZXhlY3V0aW9uIG91dGNvbWUgb2YgdGhlIGRlcGxveW1lbnQuXG4gICAgICovXG4gICAgZGVwbG95TXVsdGlzaWcoY29udHJhY3RCeXRlcykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudDogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudCB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBzZWVkT3JMZWRnZXJLZXkgPSAoeWllbGQgdGhpcy5nZXRSZWNvdmVyeU1ldGhvZHMoKSkuZGF0YVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsga2luZCwgcHVibGljS2V5IH0pID0+IChraW5kID09PSAncGhyYXNlJyB8fCBraW5kID09PSAnbGVkZ2VyJykgJiYgcHVibGljS2V5ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIC5tYXAoKHJtKSA9PiBybS5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgZmFrMmxhayA9ICh5aWVsZCB0aGlzLmdldEFjY2Vzc0tleXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh7IHB1YmxpY19rZXksIGFjY2Vzc19rZXk6IHsgcGVybWlzc2lvbiB9IH0pID0+IHBlcm1pc3Npb24gPT09ICdGdWxsQWNjZXNzJyAmJiAhc2VlZE9yTGVkZ2VyS2V5LmluY2x1ZGVzKHB1YmxpY19rZXkpKVxuICAgICAgICAgICAgICAgIC5tYXAoKGFrKSA9PiBhay5wdWJsaWNfa2V5KVxuICAgICAgICAgICAgICAgIC5tYXAodG9QSyk7XG4gICAgICAgICAgICBjb25zdCBjb25maXJtT25seUtleSA9IHRvUEsoKHlpZWxkIHRoaXMucG9zdFNpZ25lZEpzb24oJy8yZmEvZ2V0QWNjZXNzS2V5JywgeyBhY2NvdW50SWQgfSkpLnB1YmxpY0tleSk7XG4gICAgICAgICAgICBjb25zdCBuZXdBcmdzID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoeyAnbnVtX2NvbmZpcm1hdGlvbnMnOiAyIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgLi4uZmFrMmxhay5tYXAoKHBrKSA9PiBkZWxldGVLZXkocGspKSxcbiAgICAgICAgICAgICAgICAuLi5mYWsybGFrLm1hcCgocGspID0+IGFkZEtleShwaywgZnVuY3Rpb25DYWxsQWNjZXNzS2V5KGFjY291bnRJZCwgY29uc3RhbnRzXzEuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFMsIG51bGwpKSksXG4gICAgICAgICAgICAgICAgYWRkS2V5KGNvbmZpcm1Pbmx5S2V5LCBmdW5jdGlvbkNhbGxBY2Nlc3NLZXkoYWNjb3VudElkLCBjb25zdGFudHNfMS5NVUxUSVNJR19DT05GSVJNX01FVEhPRFMsIG51bGwpKSxcbiAgICAgICAgICAgICAgICBkZXBsb3lDb250cmFjdChjb250cmFjdEJ5dGVzKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBuZXdGdW5jdGlvbkNhbGxBY3Rpb25CYXRjaCA9IGFjdGlvbnMuY29uY2F0KGZ1bmN0aW9uQ2FsbCgnbmV3JywgbmV3QXJncywgY29uc3RhbnRzXzEuTVVMVElTSUdfR0FTLCBjb25zdGFudHNfMS5NVUxUSVNJR19ERVBPU0lUKSk7XG4gICAgICAgICAgICB1dGlsc18xLkxvZ2dlci5sb2coJ2RlcGxveWluZyBtdWx0aXNpZyBjb250cmFjdCBmb3InLCBhY2NvdW50SWQpO1xuICAgICAgICAgICAgY29uc3QgeyBzdGF0ZVN0YXR1czogbXVsdGlzaWdTdGF0ZVN0YXR1cyB9ID0geWllbGQgdGhpcy5jaGVja011bHRpc2lnQ29kZUFuZFN0YXRlU3RhdHVzKGNvbnRyYWN0Qnl0ZXMpO1xuICAgICAgICAgICAgc3dpdGNoIChtdWx0aXNpZ1N0YXRlU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuU1RBVEVfTk9UX0lOSVRJQUxJWkVEOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudC5jYWxsKHRoaXMsIGFjY291bnRJZCwgbmV3RnVuY3Rpb25DYWxsQWN0aW9uQmF0Y2gpO1xuICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfMi5NdWx0aXNpZ1N0YXRlU3RhdHVzLlZBTElEX1NUQVRFOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb25XaXRoQWNjb3VudC5jYWxsKHRoaXMsIGFjY291bnRJZCwgYWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgY2FzZSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuSU5WQUxJRF9TVEFURTpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgaGFzIGV4aXN0aW5nIHN0YXRlLmAsICdDb250cmFjdEhhc0V4aXN0aW5nU3RhdGUnKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBDYW4gbm90IGRlcGxveSBhIGNvbnRyYWN0IHRvIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCB0aGUgYWNjb3VudCBzdGF0ZSBjb3VsZCBub3QgYmUgdmVyaWZpZWQuYCwgJ0NvbnRyYWN0U3RhdGVVbmtub3duJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIDJGQSB3aXRoIHRoZSBvcHRpb24gdG8gY2xlYW4gdXAgY29udHJhY3Qgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgZGlzYWJsaW5nIDJGQS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdEJ5dGVzIFRoZSBieXRlY29kZSBvZiB0aGUgY29udHJhY3QgdG8gZGVwbG95LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNsZWFudXBDb250cmFjdEJ5dGVzIFRoZSBieXRlY29kZSBvZiB0aGUgY2xlYW51cCBjb250cmFjdCAob3B0aW9uYWwpLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGRpc2FibGVXaXRoRkFLKHsgY29udHJhY3RCeXRlcywgY2xlYW51cENvbnRyYWN0Qnl0ZXMgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGNsZWFudXBBY3Rpb25zID0gW107XG4gICAgICAgICAgICBpZiAoY2xlYW51cENvbnRyYWN0Qnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZUFsbFJlcXVlc3RzKCkuY2F0Y2goZSA9PiBlKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQWN0aW9ucyA9IHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUNsZWFudXBBY3Rpb25zKGNsZWFudXBDb250cmFjdEJ5dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleUNvbnZlcnNpb25BY3Rpb25zID0geWllbGQgdGhpcy5nZXQyZmFEaXNhYmxlS2V5Q29udmVyc2lvbkFjdGlvbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY2xlYW51cEFjdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4ua2V5Q29udmVyc2lvbkFjdGlvbnMsXG4gICAgICAgICAgICAgICAgZGVwbG95Q29udHJhY3QoY29udHJhY3RCeXRlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXlJbmZvID0geWllbGQgdGhpcy5maW5kQWNjZXNzS2V5KHRoaXMuYWNjb3VudElkLCBhY3Rpb25zKTtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NLZXlJbmZvICYmIGFjY2Vzc0tleUluZm8uYWNjZXNzS2V5ICYmIGFjY2Vzc0tleUluZm8uYWNjZXNzS2V5LnBlcm1pc3Npb24gIT09ICdGdWxsQWNjZXNzJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLlR5cGVkRXJyb3IoJ05vIGZ1bGwgYWNjZXNzIGtleSBmb3VuZCBpbiBrZXlzdG9yZS4gVW5hYmxlIHRvIGJ5cGFzcyBtdWx0aXNpZycsICdOb0ZBS0ZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uV2l0aEFjY291bnQodGhpcy5hY2NvdW50SWQsIGFjdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGNsZWFudXAgYWN0aW9ucyBmb3IgZGlzYWJsaW5nIDJGQS5cbiAgICAgKiBAcGFyYW0gY2xlYW51cENvbnRyYWN0Qnl0ZXMgLSBUaGUgYnl0ZWNvZGUgb2YgdGhlIGNsZWFudXAgY29udHJhY3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QWN0aW9uW10+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGNsZWFudXAgYWN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQyZmFEaXNhYmxlQ2xlYW51cEFjdGlvbnMoY2xlYW51cENvbnRyYWN0Qnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBY2NvdW50U3RhdGUgPSB5aWVsZCB0aGlzLnZpZXdTdGF0ZSgnJykuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2UgJiYgZXJyb3IuY2F1c2UubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoY2F1c2UgPT0gJ05PX0NPTlRSQUNUX0NPREUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgY2F1c2UgPT0gJ1RPT19MQVJHRV9DT05UUkFDVF9TVEFURSdcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgdHlwZXNfMS5UeXBlZEVycm9yKGBDYW4gbm90IGRlcGxveSBhIGNvbnRyYWN0IHRvIGFjY291bnQgJHt0aGlzLmFjY291bnRJZH0gb24gbmV0d29yayAke3RoaXMuY29ubmVjdGlvbi5uZXR3b3JrSWR9LCB0aGUgYWNjb3VudCBoYXMgZXhpc3Rpbmcgc3RhdGUuYCwgJ0NvbnRyYWN0SGFzRXhpc3RpbmdTdGF0ZScpXG4gICAgICAgICAgICAgICAgICAgIDogZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBY2NvdW50U3RhdGVLZXlzID0gY3VycmVudEFjY291bnRTdGF0ZS5tYXAoKHsga2V5IH0pID0+IGtleS50b1N0cmluZygnYmFzZTY0JykpO1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRBY2NvdW50U3RhdGUubGVuZ3RoID8gW1xuICAgICAgICAgICAgICAgIGRlcGxveUNvbnRyYWN0KGNsZWFudXBDb250cmFjdEJ5dGVzKSxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGwoJ2NsZWFuJywgeyBrZXlzOiBjdXJyZW50QWNjb3VudFN0YXRlS2V5cyB9LCBjb25zdGFudHNfMS5NVUxUSVNJR19HQVMsIG5ldyBibl9qc18xLmRlZmF1bHQoJzAnKSlcbiAgICAgICAgICAgIF0gOiBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBrZXkgY29udmVyc2lvbiBhY3Rpb25zIGZvciBkaXNhYmxpbmcgMkZBLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGlvbltdPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBrZXkgY29udmVyc2lvbiBhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldDJmYURpc2FibGVLZXlDb252ZXJzaW9uQWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudElkIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgYWNjZXNzS2V5cyA9IHlpZWxkIHRoaXMuZ2V0QWNjZXNzS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgbGFrMmZhayA9IGFjY2Vzc0tleXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKCh7IGFjY2Vzc19rZXkgfSkgPT4gYWNjZXNzX2tleS5wZXJtaXNzaW9uICE9PSAnRnVsbEFjY2VzcycpXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoeyBhY2Nlc3Nfa2V5IH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJtID0gYWNjZXNzX2tleS5wZXJtaXNzaW9uLkZ1bmN0aW9uQ2FsbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVybS5yZWNlaXZlcl9pZCA9PT0gYWNjb3VudElkICYmXG4gICAgICAgICAgICAgICAgICAgIHBlcm0ubWV0aG9kX25hbWVzLmxlbmd0aCA9PT0gNCAmJlxuICAgICAgICAgICAgICAgICAgICBwZXJtLm1ldGhvZF9uYW1lcy5pbmNsdWRlcygnYWRkX3JlcXVlc3RfYW5kX2NvbmZpcm0nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29uZmlybU9ubHlLZXkgPSBjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbSgoeWllbGQgdGhpcy5wb3N0U2lnbmVkSnNvbignLzJmYS9nZXRBY2Nlc3NLZXknLCB7IGFjY291bnRJZCB9KSkucHVibGljS2V5KTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZGVsZXRlS2V5KGNvbmZpcm1Pbmx5S2V5KSxcbiAgICAgICAgICAgICAgICAuLi5sYWsyZmFrLm1hcCgoeyBwdWJsaWNfa2V5IH0pID0+IGRlbGV0ZUtleShjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwdWJsaWNfa2V5KSkpLFxuICAgICAgICAgICAgICAgIC4uLmxhazJmYWsubWFwKCh7IHB1YmxpY19rZXkgfSkgPT4gYWRkS2V5KGNyeXB0b18xLlB1YmxpY0tleS5mcm9tKHB1YmxpY19rZXkpLCBmdWxsQWNjZXNzS2V5KCkpKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNvbnZlcnRzIExBS3MgYmFjayB0byBGQUtzLCBjbGVhcnMgc3RhdGUgYW5kIGRlcGxveXMgYW4gJ2VtcHR5JyBjb250cmFjdCAoY29udHJhY3RCeXRlcyBwYXJhbSlcbiAgICAgKiBAcGFyYW0gW2NvbnRyYWN0Qnl0ZXNde0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9uZWFyL25lYXItd2FsbGV0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2Zyb250ZW5kL3NyYy93YXNtL21haW4ud2FzbT9yYXc9dHJ1ZX1cbiAgICAgKiBAcGFyYW0gW2NsZWFudXBDb250cmFjdEJ5dGVzXXtAbGluayBodHRwczovL2dpdGh1Yi5jb20vbmVhci9jb3JlLWNvbnRyYWN0cy9ibG9iL21hc3Rlci9zdGF0ZS1tYW5pcHVsYXRpb24vcmVzL3N0YXRlX2NsZWFudXAud2FzbT9yYXc9dHJ1ZX1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxGaW5hbEV4ZWN1dGlvbk91dGNvbWU+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmluYWwgZXhlY3V0aW9uIG91dGNvbWUgb2YgdGhlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBkaXNhYmxlKGNvbnRyYWN0Qnl0ZXMsIGNsZWFudXBDb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlU3RhdHVzIH0gPSB5aWVsZCB0aGlzLmNoZWNrTXVsdGlzaWdDb2RlQW5kU3RhdGVTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZVN0YXR1cyAhPT0gdHlwZXNfMi5NdWx0aXNpZ1N0YXRlU3RhdHVzLlZBTElEX1NUQVRFICYmIHN0YXRlU3RhdHVzICE9PSB0eXBlc18yLk11bHRpc2lnU3RhdGVTdGF0dXMuU1RBVEVfTk9UX0lOSVRJQUxJWkVEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuVHlwZWRFcnJvcihgQ2FuIG5vdCBkZXBsb3kgYSBjb250cmFjdCB0byBhY2NvdW50ICR7dGhpcy5hY2NvdW50SWR9IG9uIG5ldHdvcmsgJHt0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkfSwgdGhlIGFjY291bnQgc3RhdGUgY291bGQgbm90IGJlIHZlcmlmaWVkLmAsICdDb250cmFjdFN0YXRlVW5rbm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRlbGV0ZUFsbFJlcXVlc3RzRXJyb3I7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZUFsbFJlcXVlc3RzKCkuY2F0Y2goZSA9PiBkZWxldGVBbGxSZXF1ZXN0c0Vycm9yID0gZSk7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwQWN0aW9ucyA9IHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUNsZWFudXBBY3Rpb25zKGNsZWFudXBDb250cmFjdEJ5dGVzKS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnQ29udHJhY3RIYXNFeGlzdGluZ1N0YXRlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZWxldGVBbGxSZXF1ZXN0c0Vycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgLi4uY2xlYW51cEFjdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4uKHlpZWxkIHRoaXMuZ2V0MmZhRGlzYWJsZUtleUNvbnZlcnNpb25BY3Rpb25zKCkpLFxuICAgICAgICAgICAgICAgIGRlcGxveUNvbnRyYWN0KGNvbnRyYWN0Qnl0ZXMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLmxvZygnZGlzYWJsaW5nIDJmYSBmb3InLCB0aGlzLmFjY291bnRJZCk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICByZWNlaXZlcklkOiB0aGlzLmFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHNlbmRpbmcgdGhlIDJGQSBjb2RlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVlc3QgSUQuXG4gICAgICovXG4gICAgc2VuZENvZGVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RJZCB9ID0gdGhpcy5nZXRSZXF1ZXN0KCk7XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSB5aWVsZCB0aGlzLmdldDJmYU1ldGhvZCgpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wb3N0U2lnbmVkSnNvbignLzJmYS9zZW5kJywge1xuICAgICAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdElkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29kZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXJlIGlzIG5vIGdldENvZGUgY2FsbGJhY2sgcHJvdmlkZWQuIFBsZWFzZSBwcm92aWRlIHlvdXIgb3duIGluIEFjY291bnRNdWx0aXNpZyBjb25zdHJ1Y3RvciBvcHRpb25zLiBJdCBoYXMgYSBwYXJhbWV0ZXIgbWV0aG9kIHdoZXJlIG1ldGhvZC5raW5kIGlzIFwiZW1haWxcIiBvciBcInBob25lXCIuJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9tcHRzIHRoZSB1c2VyIHRvIGVudGVyIGFuZCB2ZXJpZnkgdGhlIDJGQSBjb2RlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHZlcmlmaWNhdGlvbiByZXN1bHQuXG4gICAgICovXG4gICAgcHJvbXB0QW5kVmVyaWZ5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0geWllbGQgdGhpcy5nZXQyZmFNZXRob2QoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlY3VyaXR5Q29kZSA9IHlpZWxkIHRoaXMuZ2V0Q29kZShtZXRob2QpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnZlcmlmeUNvZGUoc2VjdXJpdHlDb2RlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBQYXJzZSBlcnJvciBmcm9tIHJlc3VsdCBmb3IgcmVhbCAobGlrZSBpbiBub3JtYWwgYWNjb3VudC5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLndhcm4oJ0Vycm9yIHZhbGlkYXRpbmcgc2VjdXJpdHkgY29kZTonLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZS50b1N0cmluZygpLmluY2x1ZGVzKCdpbnZhbGlkIDJmYSBjb2RlIHByb3ZpZGVkJykgfHwgZS50b1N0cmluZygpLmluY2x1ZGVzKCcyZmEgY29kZSBub3QgdmFsaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm9tcHRBbmRWZXJpZnkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmeSB0aGUgMkZBIGNvZGUgdXNpbmcgdGhlIGRlZmF1bHQgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBzZWN1cml0eUNvZGUgLSBUaGUgc2VjdXJpdHkgY29kZSB0byB2ZXJpZnkuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHZlcmlmaWNhdGlvbiByZXN1bHQuXG4gICAgICovXG4gICAgdmVyaWZ5Q29kZURlZmF1bHQoc2VjdXJpdHlDb2RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLmdldFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gcmVxdWVzdCBwZW5kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHJlcXVlc3RJZCB9ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnBvc3RTaWduZWRKc29uKCcvMmZhL3ZlcmlmeScsIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgc2VjdXJpdHlDb2RlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgcmVjb3ZlcnkgbWV0aG9kcyBmb3IgdGhlIGFjY291bnQuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8eyBhY2NvdW50SWQ6IHN0cmluZywgZGF0YTogYW55IH0+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHJlY292ZXJ5IG1ldGhvZHMgZGF0YS5cbiAgICAgKi9cbiAgICBnZXRSZWNvdmVyeU1ldGhvZHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWNjb3VudElkLFxuICAgICAgICAgICAgICAgIGRhdGE6IHlpZWxkIHRoaXMucG9zdFNpZ25lZEpzb24oJy9hY2NvdW50L3JlY292ZXJ5TWV0aG9kcycsIHsgYWNjb3VudElkIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgMkZBIG1ldGhvZCAoa2luZCBhbmQgZGV0YWlsKS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGtpbmQ6IHN0cmluZywgZGV0YWlsOiBzdHJpbmcgfT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSAyRkEgbWV0aG9kLlxuICAgICAqL1xuICAgIGdldDJmYU1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB7IGRhdGEgfSA9IHlpZWxkIHRoaXMuZ2V0UmVjb3ZlcnlNZXRob2RzKCk7XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmZpbmQoKG0pID0+IG0ua2luZC5pbmRleE9mKCcyZmEtJykgPT09IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY29uc3QgeyBraW5kLCBkZXRhaWwgfSA9IGRhdGE7XG4gICAgICAgICAgICByZXR1cm4geyBraW5kLCBkZXRhaWwgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICogR2VuZXJhdGVzIGEgc2lnbmF0dXJlIGZvciB0aGUgbGF0ZXN0IGZpbmFsaXplZCBibG9jay5cbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgYmxvY2tOdW1iZXI6IHN0cmluZywgYmxvY2tOdW1iZXJTaWduYXR1cmU6IHN0cmluZyB9Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc2lnbmF0dXJlIGluZm9ybWF0aW9uLlxuICAgICovXG4gICAgc2lnbmF0dXJlRm9yKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhY2NvdW50SWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSBibG9jay5oZWFkZXIuaGVpZ2h0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb24uc2lnbmVyLnNpZ25NZXNzYWdlKEJ1ZmZlci5mcm9tKGJsb2NrTnVtYmVyKSwgYWNjb3VudElkLCB0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyU2lnbmF0dXJlID0gQnVmZmVyLmZyb20oc2lnbmVkLnNpZ25hdHVyZSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgYmxvY2tOdW1iZXIsIGJsb2NrTnVtYmVyU2lnbmF0dXJlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAqIFNlbmRzIGEgc2lnbmVkIEpTT04gcmVxdWVzdCB0byBhIHNwZWNpZmllZCBwYXRoLlxuICAgICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCBmb3IgdGhlIHJlcXVlc3QuXG4gICAgKiBAcGFyYW0gYm9keSAtIFRoZSByZXF1ZXN0IGJvZHkuXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBmcm9tIHRoZSBoZWxwZXIuXG4gICAgKi9cbiAgICBwb3N0U2lnbmVkSnNvbihwYXRoLCBib2R5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgKDAsIHByb3ZpZGVyc18xLmZldGNoSnNvbikodGhpcy5oZWxwZXJVcmwgKyBwYXRoLCBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJvZHkpLCAoeWllbGQgdGhpcy5zaWduYXR1cmVGb3IoKSkpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQWNjb3VudDJGQSA9IEFjY291bnQyRkE7XG4vLyBoZWxwZXJzXG5jb25zdCB0b1BLID0gKHBrKSA9PiBjcnlwdG9fMS5QdWJsaWNLZXkuZnJvbShwayk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_2fa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_creator.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_creator.js ***!
  \**********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = void 0;\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.1.1/node_modules/@near-js/providers/lib/index.js\");\n/**\n * Account creator provides an interface for implementations to actually create accounts\n */\nclass AccountCreator {\n}\nexports.AccountCreator = AccountCreator;\nclass LocalAccountCreator extends AccountCreator {\n    constructor(masterAccount, initialBalance) {\n        super();\n        this.masterAccount = masterAccount;\n        this.initialBalance = initialBalance;\n    }\n    /**\n     * Creates an account using a masterAccount, meaning the new account is created from an existing account\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    createAccount(newAccountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.masterAccount.createAccount(newAccountId, publicKey, this.initialBalance);\n        });\n    }\n}\nexports.LocalAccountCreator = LocalAccountCreator;\nclass UrlAccountCreator extends AccountCreator {\n    constructor(connection, helperUrl) {\n        super();\n        this.connection = connection;\n        this.helperUrl = helperUrl;\n    }\n    /**\n     * Creates an account using a helperUrl\n     * This is [hosted here](https://helper.nearprotocol.com) or set up locally with the [near-contract-helper](https://github.com/nearprotocol/near-contract-helper) repository\n     * @param newAccountId The name of the NEAR account to be created\n     * @param publicKey The public key from the masterAccount used to create this account\n     * @returns {Promise<void>}\n     */\n    createAccount(newAccountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield (0, providers_1.fetchJson)(`${this.helperUrl}/account`, JSON.stringify({ newAccountId, newAccountPublicKey: publicKey.toString() }));\n        });\n    }\n}\nexports.UrlAccountCreator = UrlAccountCreator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50X2NyZWF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQjtBQUNoRixvQkFBb0IsbUJBQU8sQ0FBQyw0SEFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsNEJBQTRCLHlEQUF5RDtBQUNwSixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50X2NyZWF0b3IuanM/YmJiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VcmxBY2NvdW50Q3JlYXRvciA9IGV4cG9ydHMuTG9jYWxBY2NvdW50Q3JlYXRvciA9IGV4cG9ydHMuQWNjb3VudENyZWF0b3IgPSB2b2lkIDA7XG5jb25zdCBwcm92aWRlcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9wcm92aWRlcnNcIik7XG4vKipcbiAqIEFjY291bnQgY3JlYXRvciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGltcGxlbWVudGF0aW9ucyB0byBhY3R1YWxseSBjcmVhdGUgYWNjb3VudHNcbiAqL1xuY2xhc3MgQWNjb3VudENyZWF0b3Ige1xufVxuZXhwb3J0cy5BY2NvdW50Q3JlYXRvciA9IEFjY291bnRDcmVhdG9yO1xuY2xhc3MgTG9jYWxBY2NvdW50Q3JlYXRvciBleHRlbmRzIEFjY291bnRDcmVhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYXN0ZXJBY2NvdW50LCBpbml0aWFsQmFsYW5jZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1hc3RlckFjY291bnQgPSBtYXN0ZXJBY2NvdW50O1xuICAgICAgICB0aGlzLmluaXRpYWxCYWxhbmNlID0gaW5pdGlhbEJhbGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYWNjb3VudCB1c2luZyBhIG1hc3RlckFjY291bnQsIG1lYW5pbmcgdGhlIG5ldyBhY2NvdW50IGlzIGNyZWF0ZWQgZnJvbSBhbiBleGlzdGluZyBhY2NvdW50XG4gICAgICogQHBhcmFtIG5ld0FjY291bnRJZCBUaGUgbmFtZSBvZiB0aGUgTkVBUiBhY2NvdW50IHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IGZyb20gdGhlIG1hc3RlckFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhpcyBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgY3JlYXRlQWNjb3VudChuZXdBY2NvdW50SWQsIHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5tYXN0ZXJBY2NvdW50LmNyZWF0ZUFjY291bnQobmV3QWNjb3VudElkLCBwdWJsaWNLZXksIHRoaXMuaW5pdGlhbEJhbGFuY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxvY2FsQWNjb3VudENyZWF0b3IgPSBMb2NhbEFjY291bnRDcmVhdG9yO1xuY2xhc3MgVXJsQWNjb3VudENyZWF0b3IgZXh0ZW5kcyBBY2NvdW50Q3JlYXRvciB7XG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgaGVscGVyVXJsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuaGVscGVyVXJsID0gaGVscGVyVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFjY291bnQgdXNpbmcgYSBoZWxwZXJVcmxcbiAgICAgKiBUaGlzIGlzIFtob3N0ZWQgaGVyZV0oaHR0cHM6Ly9oZWxwZXIubmVhcnByb3RvY29sLmNvbSkgb3Igc2V0IHVwIGxvY2FsbHkgd2l0aCB0aGUgW25lYXItY29udHJhY3QtaGVscGVyXShodHRwczovL2dpdGh1Yi5jb20vbmVhcnByb3RvY29sL25lYXItY29udHJhY3QtaGVscGVyKSByZXBvc2l0b3J5XG4gICAgICogQHBhcmFtIG5ld0FjY291bnRJZCBUaGUgbmFtZSBvZiB0aGUgTkVBUiBhY2NvdW50IHRvIGJlIGNyZWF0ZWRcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFRoZSBwdWJsaWMga2V5IGZyb20gdGhlIG1hc3RlckFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhpcyBhY2NvdW50XG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgY3JlYXRlQWNjb3VudChuZXdBY2NvdW50SWQsIHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgKDAsIHByb3ZpZGVyc18xLmZldGNoSnNvbikoYCR7dGhpcy5oZWxwZXJVcmx9L2FjY291bnRgLCBKU09OLnN0cmluZ2lmeSh7IG5ld0FjY291bnRJZCwgbmV3QWNjb3VudFB1YmxpY0tleTogcHVibGljS2V5LnRvU3RyaW5nKCkgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlVybEFjY291bnRDcmVhdG9yID0gVXJsQWNjb3VudENyZWF0b3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_creator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_multisig.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_multisig.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AccountMultisig = void 0;\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.1.2/node_modules/@near-js/transactions/lib/index.js\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.1.0/node_modules/@near-js/utils/lib/index.js\");\nconst account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/constants.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/types.js\");\nconst { deployContract, functionCall } = transactions_1.actionCreators;\nvar MultisigCodeStatus;\n(function (MultisigCodeStatus) {\n    MultisigCodeStatus[MultisigCodeStatus[\"INVALID_CODE\"] = 0] = \"INVALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"VALID_CODE\"] = 1] = \"VALID_CODE\";\n    MultisigCodeStatus[MultisigCodeStatus[\"UNKNOWN_CODE\"] = 2] = \"UNKNOWN_CODE\";\n})(MultisigCodeStatus || (MultisigCodeStatus = {}));\n// in memory request cache for node w/o localStorage\nconst storageFallback = {\n    [constants_1.MULTISIG_STORAGE_KEY]: null\n};\nclass AccountMultisig extends account_1.Account {\n    /**\n     * Constructs an instance of the `AccountMultisig` class.\n     * @param connection The NEAR connection object.\n     * @param accountId The NEAR account ID.\n     * @param options Additional options for the multisig account.\n     * @param options.storage Storage to store data related to multisig operations.\n     * @param options.onAddRequestResult Callback function to handle the result of adding a request.\n     */\n    constructor(connection, accountId, options) {\n        super(connection, accountId);\n        this.storage = options.storage;\n        this.onAddRequestResult = options.onAddRequestResult;\n    }\n    /**\n     * Sign and send a transaction with the multisig account as the sender.\n     * @param receiverId - The NEAR account ID of the transaction receiver.\n     * @param actions - The list of actions to be included in the transaction.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    signAndSendTransactionWithAccount(receiverId, actions) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super.signAndSendTransaction.call(this, { receiverId, actions });\n        });\n    }\n    /**\n     * Sign and send a multisig transaction to add a request and confirm it.\n     * @param options Options for the multisig transaction.\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions The list of actions to be included in the transaction.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the transaction.\n     */\n    signAndSendTransaction({ receiverId, actions }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const { accountId } = this;\n            const args = Buffer.from(JSON.stringify({\n                request: {\n                    receiver_id: receiverId,\n                    actions: convertActions(actions, accountId, receiverId)\n                }\n            }));\n            let result;\n            try {\n                result = yield _super.signAndSendTransaction.call(this, {\n                    receiverId: accountId,\n                    actions: [\n                        functionCall('add_request_and_confirm', args, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)\n                    ]\n                });\n            }\n            catch (e) {\n                if (e.toString().includes('Account has too many active requests. Confirm or delete some')) {\n                    yield this.deleteUnconfirmedRequests();\n                    return yield this.signAndSendTransaction({ receiverId, actions });\n                }\n                throw e;\n            }\n            // TODO: Are following even needed? Seems like it throws on error already\n            if (!result.status) {\n                throw new Error('Request failed');\n            }\n            const status = Object.assign({}, result.status);\n            if (!status.SuccessValue || typeof status.SuccessValue !== 'string') {\n                throw new Error('Request failed');\n            }\n            this.setRequest({\n                accountId,\n                actions,\n                requestId: parseInt(Buffer.from(status.SuccessValue, 'base64').toString('ascii'), 10)\n            });\n            if (this.onAddRequestResult) {\n                yield this.onAddRequestResult(result);\n            }\n            // NOTE there is no await on purpose to avoid blocking for 2fa\n            this.deleteUnconfirmedRequests();\n            return result;\n        });\n    }\n    /**\n     * This method submits a canary transaction that is expected to always fail in order to determine whether the contract currently has valid multisig state\n     * and whether it is initialized. The canary transaction attempts to delete a request at index u32_max and will go through if a request exists at that index.\n     * a u32_max + 1 and -1 value cannot be used for the canary due to expected u32 error thrown before deserialization attempt.\n     * @param contractBytes The bytecode of the multisig contract.\n     * @returns {Promise<{ codeStatus: MultisigCodeStatus; stateStatus: MultisigStateStatus }>} A promise that resolves to the status of the code and state.\n     */\n    checkMultisigCodeAndStateStatus(contractBytes) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const u32_max = 4294967295;\n            const validCodeStatusIfNoDeploy = contractBytes ? MultisigCodeStatus.UNKNOWN_CODE : MultisigCodeStatus.VALID_CODE;\n            try {\n                if (contractBytes) {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId, actions: [\n                            deployContract(contractBytes),\n                            functionCall('delete_request', { request_id: u32_max }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)\n                        ]\n                    });\n                }\n                else {\n                    yield this.deleteRequest(u32_max);\n                }\n                return { codeStatus: MultisigCodeStatus.VALID_CODE, stateStatus: types_1.MultisigStateStatus.VALID_STATE };\n            }\n            catch (e) {\n                if (new RegExp(types_1.MultisigDeleteRequestRejectionError.CANNOT_DESERIALIZE_STATE).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.INVALID_STATE };\n                }\n                else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.MULTISIG_NOT_INITIALIZED).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.STATE_NOT_INITIALIZED };\n                }\n                else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.NO_SUCH_REQUEST).test(e && e.kind && e.kind.ExecutionError)) {\n                    return { codeStatus: validCodeStatusIfNoDeploy, stateStatus: types_1.MultisigStateStatus.VALID_STATE };\n                }\n                else if (new RegExp(types_1.MultisigDeleteRequestRejectionError.METHOD_NOT_FOUND).test(e && e.message)) {\n                    // not reachable if transaction included a deploy\n                    return { codeStatus: MultisigCodeStatus.INVALID_CODE, stateStatus: types_1.MultisigStateStatus.UNKNOWN_STATE };\n                }\n                throw e;\n            }\n        });\n    }\n    /**\n     * Delete a multisig request by its ID.\n     * @param request_id The ID of the multisig request to be deleted.\n     * @returns {Promise<FinalExecutionOutcome>} A promise that resolves to the final execution outcome of the deletion.\n     */\n    deleteRequest(request_id) {\n        return super.signAndSendTransaction({\n            receiverId: this.accountId,\n            actions: [functionCall('delete_request', { request_id }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]\n        });\n    }\n    /**\n     * Delete all multisig requests associated with the account.\n     * @returns {Promise<void>} A promise that resolves when all requests are deleted.\n     */\n    deleteAllRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request_ids = yield this.getRequestIds();\n            if (request_ids.length) {\n                yield Promise.all(request_ids.map((id) => this.deleteRequest(id)));\n            }\n        });\n    }\n    /**\n     * Delete unconfirmed multisig requests associated with the account.\n     * @returns {Promise<void>} A promise that resolves when unconfirmed requests are deleted.\n     */\n    deleteUnconfirmedRequests() {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Delete in batch, don't delete unexpired\n            // TODO: Delete in batch, don't delete unexpired (can reduce gas usage dramatically)\n            const request_ids = yield this.getRequestIds();\n            const { requestId } = this.getRequest();\n            for (const requestIdToDelete of request_ids) {\n                if (requestIdToDelete == requestId) {\n                    continue;\n                }\n                try {\n                    yield _super.signAndSendTransaction.call(this, {\n                        receiverId: this.accountId,\n                        actions: [functionCall('delete_request', { request_id: requestIdToDelete }, constants_1.MULTISIG_GAS, constants_1.MULTISIG_DEPOSIT)]\n                    });\n                }\n                catch (e) {\n                    utils_1.Logger.warn('Attempt to delete an earlier request before 15 minutes failed. Will try again.');\n                }\n            }\n        });\n    }\n    // helpers\n    getRequestIds() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Read requests from state to allow filtering by expiration time\n            // TODO: https://github.com/near/core-contracts/blob/305d1db4f4f2cf5ce4c1ef3479f7544957381f11/multisig/src/lib.rs#L84\n            return this.viewFunction({\n                contractId: this.accountId,\n                methodName: 'list_request_ids',\n            });\n        });\n    }\n    getRequest() {\n        if (this.storage) {\n            return JSON.parse(this.storage.getItem(constants_1.MULTISIG_STORAGE_KEY) || '{}');\n        }\n        return storageFallback[constants_1.MULTISIG_STORAGE_KEY];\n    }\n    setRequest(data) {\n        if (this.storage) {\n            return this.storage.setItem(constants_1.MULTISIG_STORAGE_KEY, JSON.stringify(data));\n        }\n        storageFallback[constants_1.MULTISIG_STORAGE_KEY] = data;\n    }\n}\nexports.AccountMultisig = AccountMultisig;\nconst convertPKForContract = (pk) => pk.toString().replace('ed25519:', '');\nconst convertActions = (actions, accountId, receiverId) => actions.map((a) => {\n    const type = a.enum;\n    const { gas, publicKey, methodName, args, deposit, accessKey, code } = a[type];\n    const action = {\n        type: type[0].toUpperCase() + type.substr(1),\n        gas: (gas && gas.toString()) || undefined,\n        public_key: (publicKey && convertPKForContract(publicKey)) || undefined,\n        method_name: methodName,\n        args: (args && Buffer.from(args).toString('base64')) || undefined,\n        code: (code && Buffer.from(code).toString('base64')) || undefined,\n        amount: (deposit && deposit.toString()) || undefined,\n        deposit: (deposit && deposit.toString()) || '0',\n        permission: undefined,\n    };\n    if (accessKey) {\n        if (receiverId === accountId && accessKey.permission.enum !== 'fullAccess') {\n            action.permission = {\n                receiver_id: accountId,\n                allowance: constants_1.MULTISIG_ALLOWANCE.toString(),\n                method_names: constants_1.MULTISIG_CHANGE_METHODS,\n            };\n        }\n        if (accessKey.permission.enum === 'functionCall') {\n            const { receiverId: receiver_id, methodNames: method_names, allowance } = accessKey.permission.functionCall;\n            action.permission = {\n                receiver_id,\n                allowance: (allowance && allowance.toString()) || undefined,\n                method_names\n            };\n        }\n    }\n    return action;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9hY2NvdW50X211bHRpc2lnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsdUJBQXVCLG1CQUFPLENBQUMscUlBQXVCO0FBQ3RELGdCQUFnQixtQkFBTyxDQUFDLGdIQUFnQjtBQUN4QyxrQkFBa0IsbUJBQU8sQ0FBQyxtSEFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx1SEFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQywrR0FBUztBQUNqQyxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSw4REFBOEQscUJBQXFCO0FBQ25GLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHFCQUFxQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFVBQVUsZ0NBQWdDLGtDQUFrQyxHQUFHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxxQkFBcUI7QUFDbEY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdDQUFnQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsK0JBQStCO0FBQ2xHLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQTZEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0VBQWdFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjAuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2FjY291bnRfbXVsdGlzaWcuanM/MDk0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY2NvdW50TXVsdGlzaWcgPSB2b2lkIDA7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90cmFuc2FjdGlvbnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3V0aWxzXCIpO1xuY29uc3QgYWNjb3VudF8xID0gcmVxdWlyZShcIi4vYWNjb3VudFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgeyBkZXBsb3lDb250cmFjdCwgZnVuY3Rpb25DYWxsIH0gPSB0cmFuc2FjdGlvbnNfMS5hY3Rpb25DcmVhdG9ycztcbnZhciBNdWx0aXNpZ0NvZGVTdGF0dXM7XG4oZnVuY3Rpb24gKE11bHRpc2lnQ29kZVN0YXR1cykge1xuICAgIE11bHRpc2lnQ29kZVN0YXR1c1tNdWx0aXNpZ0NvZGVTdGF0dXNbXCJJTlZBTElEX0NPREVcIl0gPSAwXSA9IFwiSU5WQUxJRF9DT0RFXCI7XG4gICAgTXVsdGlzaWdDb2RlU3RhdHVzW011bHRpc2lnQ29kZVN0YXR1c1tcIlZBTElEX0NPREVcIl0gPSAxXSA9IFwiVkFMSURfQ09ERVwiO1xuICAgIE11bHRpc2lnQ29kZVN0YXR1c1tNdWx0aXNpZ0NvZGVTdGF0dXNbXCJVTktOT1dOX0NPREVcIl0gPSAyXSA9IFwiVU5LTk9XTl9DT0RFXCI7XG59KShNdWx0aXNpZ0NvZGVTdGF0dXMgfHwgKE11bHRpc2lnQ29kZVN0YXR1cyA9IHt9KSk7XG4vLyBpbiBtZW1vcnkgcmVxdWVzdCBjYWNoZSBmb3Igbm9kZSB3L28gbG9jYWxTdG9yYWdlXG5jb25zdCBzdG9yYWdlRmFsbGJhY2sgPSB7XG4gICAgW2NvbnN0YW50c18xLk1VTFRJU0lHX1NUT1JBR0VfS0VZXTogbnVsbFxufTtcbmNsYXNzIEFjY291bnRNdWx0aXNpZyBleHRlbmRzIGFjY291bnRfMS5BY2NvdW50IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGFuIGluc3RhbmNlIG9mIHRoZSBgQWNjb3VudE11bHRpc2lnYCBjbGFzcy5cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgTkVBUiBjb25uZWN0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gYWNjb3VudElkIFRoZSBORUFSIGFjY291bnQgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgbXVsdGlzaWcgYWNjb3VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdG9yYWdlIFN0b3JhZ2UgdG8gc3RvcmUgZGF0YSByZWxhdGVkIHRvIG11bHRpc2lnIG9wZXJhdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25BZGRSZXF1ZXN0UmVzdWx0IENhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgcmVzdWx0IG9mIGFkZGluZyBhIHJlcXVlc3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29ubmVjdGlvbiwgYWNjb3VudElkLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKGNvbm5lY3Rpb24sIGFjY291bnRJZCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZTtcbiAgICAgICAgdGhpcy5vbkFkZFJlcXVlc3RSZXN1bHQgPSBvcHRpb25zLm9uQWRkUmVxdWVzdFJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIG11bHRpc2lnIGFjY291bnQgYXMgdGhlIHNlbmRlci5cbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCAtIFRoZSBORUFSIGFjY291bnQgSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHJlY2VpdmVyLlxuICAgICAqIEBwYXJhbSBhY3Rpb25zIC0gVGhlIGxpc3Qgb2YgYWN0aW9ucyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8RmluYWxFeGVjdXRpb25PdXRjb21lPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGZpbmFsIGV4ZWN1dGlvbiBvdXRjb21lIG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBzaWduQW5kU2VuZFRyYW5zYWN0aW9uV2l0aEFjY291bnQocmVjZWl2ZXJJZCwgYWN0aW9ucykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24uY2FsbCh0aGlzLCB7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduIGFuZCBzZW5kIGEgbXVsdGlzaWcgdHJhbnNhY3Rpb24gdG8gYWRkIGEgcmVxdWVzdCBhbmQgY29uZmlybSBpdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgbXVsdGlzaWcgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVjZWl2ZXJJZCBUaGUgTkVBUiBhY2NvdW50IElEIG9mIHRoZSB0cmFuc2FjdGlvbiByZWNlaXZlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hY3Rpb25zIFRoZSBsaXN0IG9mIGFjdGlvbnMgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMgfSkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY291bnRJZCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcl9pZDogcmVjZWl2ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogY29udmVydEFjdGlvbnMoYWN0aW9ucywgYWNjb3VudElkLCByZWNlaXZlcklkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICByZWNlaXZlcklkOiBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbCgnYWRkX3JlcXVlc3RfYW5kX2NvbmZpcm0nLCBhcmdzLCBjb25zdGFudHNfMS5NVUxUSVNJR19HQVMsIGNvbnN0YW50c18xLk1VTFRJU0lHX0RFUE9TSVQpXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5pbmNsdWRlcygnQWNjb3VudCBoYXMgdG9vIG1hbnkgYWN0aXZlIHJlcXVlc3RzLiBDb25maXJtIG9yIGRlbGV0ZSBzb21lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kZWxldGVVbmNvbmZpcm1lZFJlcXVlc3RzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24oeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogQXJlIGZvbGxvd2luZyBldmVuIG5lZWRlZD8gU2VlbXMgbGlrZSBpdCB0aHJvd3Mgb24gZXJyb3IgYWxyZWFkeVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzdWx0LnN0YXR1cyk7XG4gICAgICAgICAgICBpZiAoIXN0YXR1cy5TdWNjZXNzVmFsdWUgfHwgdHlwZW9mIHN0YXR1cy5TdWNjZXNzVmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHBhcnNlSW50KEJ1ZmZlci5mcm9tKHN0YXR1cy5TdWNjZXNzVmFsdWUsICdiYXNlNjQnKS50b1N0cmluZygnYXNjaWknKSwgMTApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQWRkUmVxdWVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMub25BZGRSZXF1ZXN0UmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFIHRoZXJlIGlzIG5vIGF3YWl0IG9uIHB1cnBvc2UgdG8gYXZvaWQgYmxvY2tpbmcgZm9yIDJmYVxuICAgICAgICAgICAgdGhpcy5kZWxldGVVbmNvbmZpcm1lZFJlcXVlc3RzKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2Qgc3VibWl0cyBhIGNhbmFyeSB0cmFuc2FjdGlvbiB0aGF0IGlzIGV4cGVjdGVkIHRvIGFsd2F5cyBmYWlsIGluIG9yZGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBjb250cmFjdCBjdXJyZW50bHkgaGFzIHZhbGlkIG11bHRpc2lnIHN0YXRlXG4gICAgICogYW5kIHdoZXRoZXIgaXQgaXMgaW5pdGlhbGl6ZWQuIFRoZSBjYW5hcnkgdHJhbnNhY3Rpb24gYXR0ZW1wdHMgdG8gZGVsZXRlIGEgcmVxdWVzdCBhdCBpbmRleCB1MzJfbWF4IGFuZCB3aWxsIGdvIHRocm91Z2ggaWYgYSByZXF1ZXN0IGV4aXN0cyBhdCB0aGF0IGluZGV4LlxuICAgICAqIGEgdTMyX21heCArIDEgYW5kIC0xIHZhbHVlIGNhbm5vdCBiZSB1c2VkIGZvciB0aGUgY2FuYXJ5IGR1ZSB0byBleHBlY3RlZCB1MzIgZXJyb3IgdGhyb3duIGJlZm9yZSBkZXNlcmlhbGl6YXRpb24gYXR0ZW1wdC5cbiAgICAgKiBAcGFyYW0gY29udHJhY3RCeXRlcyBUaGUgYnl0ZWNvZGUgb2YgdGhlIG11bHRpc2lnIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHsgY29kZVN0YXR1czogTXVsdGlzaWdDb2RlU3RhdHVzOyBzdGF0ZVN0YXR1czogTXVsdGlzaWdTdGF0ZVN0YXR1cyB9Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXR1cyBvZiB0aGUgY29kZSBhbmQgc3RhdGUuXG4gICAgICovXG4gICAgY2hlY2tNdWx0aXNpZ0NvZGVBbmRTdGF0ZVN0YXR1cyhjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbjogeyBnZXQ6ICgpID0+IHN1cGVyLnNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHUzMl9tYXggPSA0Mjk0OTY3Mjk1O1xuICAgICAgICAgICAgY29uc3QgdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSA9IGNvbnRyYWN0Qnl0ZXMgPyBNdWx0aXNpZ0NvZGVTdGF0dXMuVU5LTk9XTl9DT0RFIDogTXVsdGlzaWdDb2RlU3RhdHVzLlZBTElEX0NPREU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb250cmFjdEJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZXJJZDogdGhpcy5hY2NvdW50SWQsIGFjdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBsb3lDb250cmFjdChjb250cmFjdEJ5dGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGwoJ2RlbGV0ZV9yZXF1ZXN0JywgeyByZXF1ZXN0X2lkOiB1MzJfbWF4IH0sIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVClcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRlbGV0ZVJlcXVlc3QodTMyX21heCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGNvZGVTdGF0dXM6IE11bHRpc2lnQ29kZVN0YXR1cy5WQUxJRF9DT0RFLCBzdGF0ZVN0YXR1czogdHlwZXNfMS5NdWx0aXNpZ1N0YXRlU3RhdHVzLlZBTElEX1NUQVRFIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXcgUmVnRXhwKHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuQ0FOTk9UX0RFU0VSSUFMSVpFX1NUQVRFKS50ZXN0KGUgJiYgZS5raW5kICYmIGUua2luZC5FeGVjdXRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1cy5JTlZBTElEX1NUQVRFIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ldyBSZWdFeHAodHlwZXNfMS5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvci5NVUxUSVNJR19OT1RfSU5JVElBTElaRUQpLnRlc3QoZSAmJiBlLmtpbmQgJiYgZS5raW5kLkV4ZWN1dGlvbkVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjb2RlU3RhdHVzOiB2YWxpZENvZGVTdGF0dXNJZk5vRGVwbG95LCBzdGF0ZVN0YXR1czogdHlwZXNfMS5NdWx0aXNpZ1N0YXRlU3RhdHVzLlNUQVRFX05PVF9JTklUSUFMSVpFRCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXcgUmVnRXhwKHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuTk9fU1VDSF9SRVFVRVNUKS50ZXN0KGUgJiYgZS5raW5kICYmIGUua2luZC5FeGVjdXRpb25FcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgY29kZVN0YXR1czogdmFsaWRDb2RlU3RhdHVzSWZOb0RlcGxveSwgc3RhdGVTdGF0dXM6IHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1cy5WQUxJRF9TVEFURSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuZXcgUmVnRXhwKHR5cGVzXzEuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IuTUVUSE9EX05PVF9GT1VORCkudGVzdChlICYmIGUubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IHJlYWNoYWJsZSBpZiB0cmFuc2FjdGlvbiBpbmNsdWRlZCBhIGRlcGxveVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjb2RlU3RhdHVzOiBNdWx0aXNpZ0NvZGVTdGF0dXMuSU5WQUxJRF9DT0RFLCBzdGF0ZVN0YXR1czogdHlwZXNfMS5NdWx0aXNpZ1N0YXRlU3RhdHVzLlVOS05PV05fU1RBVEUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIG11bHRpc2lnIHJlcXVlc3QgYnkgaXRzIElELlxuICAgICAqIEBwYXJhbSByZXF1ZXN0X2lkIFRoZSBJRCBvZiB0aGUgbXVsdGlzaWcgcmVxdWVzdCB0byBiZSBkZWxldGVkLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEZpbmFsRXhlY3V0aW9uT3V0Y29tZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaW5hbCBleGVjdXRpb24gb3V0Y29tZSBvZiB0aGUgZGVsZXRpb24uXG4gICAgICovXG4gICAgZGVsZXRlUmVxdWVzdChyZXF1ZXN0X2lkKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgYWN0aW9uczogW2Z1bmN0aW9uQ2FsbCgnZGVsZXRlX3JlcXVlc3QnLCB7IHJlcXVlc3RfaWQgfSwgY29uc3RhbnRzXzEuTVVMVElTSUdfR0FTLCBjb25zdGFudHNfMS5NVUxUSVNJR19ERVBPU0lUKV1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhbGwgbXVsdGlzaWcgcmVxdWVzdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCByZXF1ZXN0cyBhcmUgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBkZWxldGVBbGxSZXF1ZXN0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RfaWRzID0geWllbGQgdGhpcy5nZXRSZXF1ZXN0SWRzKCk7XG4gICAgICAgICAgICBpZiAocmVxdWVzdF9pZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwocmVxdWVzdF9pZHMubWFwKChpZCkgPT4gdGhpcy5kZWxldGVSZXF1ZXN0KGlkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHVuY29uZmlybWVkIG11bHRpc2lnIHJlcXVlc3RzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB1bmNvbmZpcm1lZCByZXF1ZXN0cyBhcmUgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBkZWxldGVVbmNvbmZpcm1lZFJlcXVlc3RzKCkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgaW4gYmF0Y2gsIGRvbid0IGRlbGV0ZSB1bmV4cGlyZWRcbiAgICAgICAgICAgIC8vIFRPRE86IERlbGV0ZSBpbiBiYXRjaCwgZG9uJ3QgZGVsZXRlIHVuZXhwaXJlZCAoY2FuIHJlZHVjZSBnYXMgdXNhZ2UgZHJhbWF0aWNhbGx5KVxuICAgICAgICAgICAgY29uc3QgcmVxdWVzdF9pZHMgPSB5aWVsZCB0aGlzLmdldFJlcXVlc3RJZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdElkIH0gPSB0aGlzLmdldFJlcXVlc3QoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdElkVG9EZWxldGUgb2YgcmVxdWVzdF9pZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdElkVG9EZWxldGUgPT0gcmVxdWVzdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfc3VwZXIuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVySWQ6IHRoaXMuYWNjb3VudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uczogW2Z1bmN0aW9uQ2FsbCgnZGVsZXRlX3JlcXVlc3QnLCB7IHJlcXVlc3RfaWQ6IHJlcXVlc3RJZFRvRGVsZXRlIH0sIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUywgY29uc3RhbnRzXzEuTVVMVElTSUdfREVQT1NJVCldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB1dGlsc18xLkxvZ2dlci53YXJuKCdBdHRlbXB0IHRvIGRlbGV0ZSBhbiBlYXJsaWVyIHJlcXVlc3QgYmVmb3JlIDE1IG1pbnV0ZXMgZmFpbGVkLiBXaWxsIHRyeSBhZ2Fpbi4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBoZWxwZXJzXG4gICAgZ2V0UmVxdWVzdElkcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlYWQgcmVxdWVzdHMgZnJvbSBzdGF0ZSB0byBhbGxvdyBmaWx0ZXJpbmcgYnkgZXhwaXJhdGlvbiB0aW1lXG4gICAgICAgICAgICAvLyBUT0RPOiBodHRwczovL2dpdGh1Yi5jb20vbmVhci9jb3JlLWNvbnRyYWN0cy9ibG9iLzMwNWQxZGI0ZjRmMmNmNWNlNGMxZWYzNDc5Zjc1NDQ5NTczODFmMTEvbXVsdGlzaWcvc3JjL2xpYi5ycyNMODRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdGdW5jdGlvbih7XG4gICAgICAgICAgICAgICAgY29udHJhY3RJZDogdGhpcy5hY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogJ2xpc3RfcmVxdWVzdF9pZHMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLnN0b3JhZ2UuZ2V0SXRlbShjb25zdGFudHNfMS5NVUxUSVNJR19TVE9SQUdFX0tFWSkgfHwgJ3t9Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JhZ2VGYWxsYmFja1tjb25zdGFudHNfMS5NVUxUSVNJR19TVE9SQUdFX0tFWV07XG4gICAgfVxuICAgIHNldFJlcXVlc3QoZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5zdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0oY29uc3RhbnRzXzEuTVVMVElTSUdfU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlRmFsbGJhY2tbY29uc3RhbnRzXzEuTVVMVElTSUdfU1RPUkFHRV9LRVldID0gZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnRNdWx0aXNpZyA9IEFjY291bnRNdWx0aXNpZztcbmNvbnN0IGNvbnZlcnRQS0ZvckNvbnRyYWN0ID0gKHBrKSA9PiBway50b1N0cmluZygpLnJlcGxhY2UoJ2VkMjU1MTk6JywgJycpO1xuY29uc3QgY29udmVydEFjdGlvbnMgPSAoYWN0aW9ucywgYWNjb3VudElkLCByZWNlaXZlcklkKSA9PiBhY3Rpb25zLm1hcCgoYSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBhLmVudW07XG4gICAgY29uc3QgeyBnYXMsIHB1YmxpY0tleSwgbWV0aG9kTmFtZSwgYXJncywgZGVwb3NpdCwgYWNjZXNzS2V5LCBjb2RlIH0gPSBhW3R5cGVdO1xuICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgICAgdHlwZTogdHlwZVswXS50b1VwcGVyQ2FzZSgpICsgdHlwZS5zdWJzdHIoMSksXG4gICAgICAgIGdhczogKGdhcyAmJiBnYXMudG9TdHJpbmcoKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBwdWJsaWNfa2V5OiAocHVibGljS2V5ICYmIGNvbnZlcnRQS0ZvckNvbnRyYWN0KHB1YmxpY0tleSkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgbWV0aG9kX25hbWU6IG1ldGhvZE5hbWUsXG4gICAgICAgIGFyZ3M6IChhcmdzICYmIEJ1ZmZlci5mcm9tKGFyZ3MpLnRvU3RyaW5nKCdiYXNlNjQnKSkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBjb2RlOiAoY29kZSAmJiBCdWZmZXIuZnJvbShjb2RlKS50b1N0cmluZygnYmFzZTY0JykpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgYW1vdW50OiAoZGVwb3NpdCAmJiBkZXBvc2l0LnRvU3RyaW5nKCkpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgZGVwb3NpdDogKGRlcG9zaXQgJiYgZGVwb3NpdC50b1N0cmluZygpKSB8fCAnMCcsXG4gICAgICAgIHBlcm1pc3Npb246IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChhY2Nlc3NLZXkpIHtcbiAgICAgICAgaWYgKHJlY2VpdmVySWQgPT09IGFjY291bnRJZCAmJiBhY2Nlc3NLZXkucGVybWlzc2lvbi5lbnVtICE9PSAnZnVsbEFjY2VzcycpIHtcbiAgICAgICAgICAgIGFjdGlvbi5wZXJtaXNzaW9uID0ge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVyX2lkOiBhY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgYWxsb3dhbmNlOiBjb25zdGFudHNfMS5NVUxUSVNJR19BTExPV0FOQ0UudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtZXRob2RfbmFtZXM6IGNvbnN0YW50c18xLk1VTFRJU0lHX0NIQU5HRV9NRVRIT0RTLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWNjZXNzS2V5LnBlcm1pc3Npb24uZW51bSA9PT0gJ2Z1bmN0aW9uQ2FsbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVjZWl2ZXJJZDogcmVjZWl2ZXJfaWQsIG1ldGhvZE5hbWVzOiBtZXRob2RfbmFtZXMsIGFsbG93YW5jZSB9ID0gYWNjZXNzS2V5LnBlcm1pc3Npb24uZnVuY3Rpb25DYWxsO1xuICAgICAgICAgICAgYWN0aW9uLnBlcm1pc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZXJfaWQsXG4gICAgICAgICAgICAgICAgYWxsb3dhbmNlOiAoYWxsb3dhbmNlICYmIGFsbG93YW5jZS50b1N0cmluZygpKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kX25hbWVzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY3Rpb247XG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_multisig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/connection.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/connection.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connection = void 0;\nconst signers_1 = __webpack_require__(/*! @near-js/signers */ \"(ssr)/./node_modules/.pnpm/@near-js+signers@0.1.1/node_modules/@near-js/signers/lib/index.js\");\nconst providers_1 = __webpack_require__(/*! @near-js/providers */ \"(ssr)/./node_modules/.pnpm/@near-js+providers@0.1.1/node_modules/@near-js/providers/lib/index.js\");\n/**\n * @param config Contains connection info details\n * @returns {Provider}\n */\nfunction getProvider(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'JsonRpcProvider': return new providers_1.JsonRpcProvider(Object.assign({}, config.args));\n        default: throw new Error(`Unknown provider type ${config.type}`);\n    }\n}\n/**\n * @param config Contains connection info details\n * @returns {Signer}\n */\nfunction getSigner(config) {\n    switch (config.type) {\n        case undefined:\n            return config;\n        case 'InMemorySigner': {\n            return new signers_1.InMemorySigner(config.keyStore);\n        }\n        default: throw new Error(`Unknown signer type ${config.type}`);\n    }\n}\n/**\n * Connects an account to a given network via a given provider\n */\nclass Connection {\n    constructor(networkId, provider, signer, jsvmAccountId) {\n        this.networkId = networkId;\n        this.provider = provider;\n        this.signer = signer;\n        this.jsvmAccountId = jsvmAccountId;\n    }\n    /**\n     * @param config Contains connection info details\n     */\n    static fromConfig(config) {\n        const provider = getProvider(config.provider);\n        const signer = getSigner(config.signer);\n        return new Connection(config.networkId, provider, signer, config.jsvmAccountId);\n    }\n}\nexports.Connection = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQyxzSEFBa0I7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNEhBQW9CO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RiwwREFBMEQsWUFBWTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjAuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2Nvbm5lY3Rpb24uanM/ODRhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGlvbiA9IHZvaWQgMDtcbmNvbnN0IHNpZ25lcnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9zaWduZXJzXCIpO1xuY29uc3QgcHJvdmlkZXJzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvcHJvdmlkZXJzXCIpO1xuLyoqXG4gKiBAcGFyYW0gY29uZmlnIENvbnRhaW5zIGNvbm5lY3Rpb24gaW5mbyBkZXRhaWxzXG4gKiBAcmV0dXJucyB7UHJvdmlkZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFByb3ZpZGVyKGNvbmZpZykge1xuICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICBjYXNlICdKc29uUnBjUHJvdmlkZXInOiByZXR1cm4gbmV3IHByb3ZpZGVyc18xLkpzb25ScGNQcm92aWRlcihPYmplY3QuYXNzaWduKHt9LCBjb25maWcuYXJncykpO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcHJvdmlkZXIgdHlwZSAke2NvbmZpZy50eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogQHBhcmFtIGNvbmZpZyBDb250YWlucyBjb25uZWN0aW9uIGluZm8gZGV0YWlsc1xuICogQHJldHVybnMge1NpZ25lcn1cbiAqL1xuZnVuY3Rpb24gZ2V0U2lnbmVyKGNvbmZpZykge1xuICAgIHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICBjYXNlICdJbk1lbW9yeVNpZ25lcic6IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgc2lnbmVyc18xLkluTWVtb3J5U2lnbmVyKGNvbmZpZy5rZXlTdG9yZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNpZ25lciB0eXBlICR7Y29uZmlnLnR5cGV9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb25uZWN0cyBhbiBhY2NvdW50IHRvIGEgZ2l2ZW4gbmV0d29yayB2aWEgYSBnaXZlbiBwcm92aWRlclxuICovXG5jbGFzcyBDb25uZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrSWQsIHByb3ZpZGVyLCBzaWduZXIsIGpzdm1BY2NvdW50SWQpIHtcbiAgICAgICAgdGhpcy5uZXR3b3JrSWQgPSBuZXR3b3JrSWQ7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgdGhpcy5zaWduZXIgPSBzaWduZXI7XG4gICAgICAgIHRoaXMuanN2bUFjY291bnRJZCA9IGpzdm1BY2NvdW50SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb25maWcgQ29udGFpbnMgY29ubmVjdGlvbiBpbmZvIGRldGFpbHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcihjb25maWcucHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBzaWduZXIgPSBnZXRTaWduZXIoY29uZmlnLnNpZ25lcik7XG4gICAgICAgIHJldHVybiBuZXcgQ29ubmVjdGlvbihjb25maWcubmV0d29ya0lkLCBwcm92aWRlciwgc2lnbmVyLCBjb25maWcuanN2bUFjY291bnRJZCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uID0gQ29ubmVjdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/connection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/constants.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/constants.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.1.0/node_modules/@near-js/utils/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nexports.MULTISIG_STORAGE_KEY = '__multisigRequest';\nexports.MULTISIG_ALLOWANCE = new bn_js_1.default((0, utils_1.parseNearAmount)('1'));\n// TODO: Different gas value for different requests (can reduce gas usage dramatically)\nexports.MULTISIG_GAS = new bn_js_1.default('100000000000000');\nexports.MULTISIG_DEPOSIT = new bn_js_1.default('0');\nexports.MULTISIG_CHANGE_METHODS = ['add_request', 'add_request_and_confirm', 'delete_request', 'confirm'];\nexports.MULTISIG_CONFIRM_METHODS = ['confirm'];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEI7QUFDaEwsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3hDLGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DLDRCQUE0QjtBQUM1QiwwQkFBMEI7QUFDMUI7QUFDQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLCtCQUErQjtBQUMvQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMC40L25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvY29uc3RhbnRzLmpzP2IyZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1VTFRJU0lHX0NPTkZJUk1fTUVUSE9EUyA9IGV4cG9ydHMuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFMgPSBleHBvcnRzLk1VTFRJU0lHX0RFUE9TSVQgPSBleHBvcnRzLk1VTFRJU0lHX0dBUyA9IGV4cG9ydHMuTVVMVElTSUdfQUxMT1dBTkNFID0gZXhwb3J0cy5NVUxUSVNJR19TVE9SQUdFX0tFWSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5leHBvcnRzLk1VTFRJU0lHX1NUT1JBR0VfS0VZID0gJ19fbXVsdGlzaWdSZXF1ZXN0JztcbmV4cG9ydHMuTVVMVElTSUdfQUxMT1dBTkNFID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgoMCwgdXRpbHNfMS5wYXJzZU5lYXJBbW91bnQpKCcxJykpO1xuLy8gVE9ETzogRGlmZmVyZW50IGdhcyB2YWx1ZSBmb3IgZGlmZmVyZW50IHJlcXVlc3RzIChjYW4gcmVkdWNlIGdhcyB1c2FnZSBkcmFtYXRpY2FsbHkpXG5leHBvcnRzLk1VTFRJU0lHX0dBUyA9IG5ldyBibl9qc18xLmRlZmF1bHQoJzEwMDAwMDAwMDAwMDAwMCcpO1xuZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUID0gbmV3IGJuX2pzXzEuZGVmYXVsdCgnMCcpO1xuZXhwb3J0cy5NVUxUSVNJR19DSEFOR0VfTUVUSE9EUyA9IFsnYWRkX3JlcXVlc3QnLCAnYWRkX3JlcXVlc3RfYW5kX2NvbmZpcm0nLCAnZGVsZXRlX3JlcXVlc3QnLCAnY29uZmlybSddO1xuZXhwb3J0cy5NVUxUSVNJR19DT05GSVJNX01FVEhPRFMgPSBbJ2NvbmZpcm0nXTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/contract.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/contract.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Contract = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.1.0/node_modules/@near-js/utils/lib/index.js\");\nconst types_1 = __webpack_require__(/*! @near-js/types */ \"(ssr)/./node_modules/.pnpm/@near-js+types@0.0.4/node_modules/@near-js/types/lib/index.js\");\nconst local_view_execution_1 = __webpack_require__(/*! ./local-view-execution */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/index.js\");\nconst ajv_1 = __importDefault(__webpack_require__(/*! ajv */ \"(ssr)/./node_modules/.pnpm/ajv@8.11.2/node_modules/ajv/dist/ajv.js\"));\nconst ajv_formats_1 = __importDefault(__webpack_require__(/*! ajv-formats */ \"(ssr)/./node_modules/.pnpm/ajv-formats@2.1.1_ajv@8.11.2/node_modules/ajv-formats/dist/index.js\"));\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst depd_1 = __importDefault(__webpack_require__(/*! depd */ \"(ssr)/./node_modules/.pnpm/depd@2.0.0/node_modules/depd/index.js\"));\nconst near_abi_1 = __webpack_require__(/*! near-abi */ \"(ssr)/./node_modules/.pnpm/near-abi@0.1.1/node_modules/near-abi/lib/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/errors.js\");\n// Makes `function.name` return given name\nfunction nameFunction(name, body) {\n    return {\n        [name](...args) {\n            return body(...args);\n        }\n    }[name];\n}\nfunction validateArguments(args, abiFunction, ajv, abiRoot) {\n    var _a;\n    if (!isObject(args))\n        return;\n    if (abiFunction.params && abiFunction.params.serialization_type !== near_abi_1.AbiSerializationType.Json) {\n        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.params.serialization_type);\n    }\n    if (abiFunction.result && abiFunction.result.serialization_type !== near_abi_1.AbiSerializationType.Json) {\n        throw new errors_1.UnsupportedSerializationError(abiFunction.name, abiFunction.result.serialization_type);\n    }\n    const params = ((_a = abiFunction.params) === null || _a === void 0 ? void 0 : _a.args) || [];\n    for (const p of params) {\n        const arg = args[p.name];\n        const typeSchema = p.type_schema;\n        typeSchema.definitions = abiRoot.body.root_schema.definitions;\n        const validate = ajv.compile(typeSchema);\n        if (!validate(arg)) {\n            throw new errors_1.ArgumentSchemaError(p.name, validate.errors);\n        }\n    }\n    // Check there are no extra unknown arguments passed\n    for (const argName of Object.keys(args)) {\n        const param = params.find((p) => p.name === argName);\n        if (!param) {\n            throw new errors_1.UnknownArgumentError(argName, params.map((p) => p.name));\n        }\n    }\n}\nfunction createAjv() {\n    // Strict mode is disabled for now as it complains about unknown formats. We need to\n    // figure out if we want to support a fixed set of formats. `uint32` and `uint64`\n    // are added explicitly just to reduce the amount of warnings as these are very popular\n    // types.\n    const ajv = new ajv_1.default({\n        strictSchema: false,\n        formats: {\n            uint32: true,\n            uint64: true\n        }\n    });\n    (0, ajv_formats_1.default)(ajv);\n    return ajv;\n}\nconst isUint8Array = (x) => x && x.byteLength !== undefined && x.byteLength === x.length;\nconst isObject = (x) => Object.prototype.toString.call(x) === '[object Object]';\n/**\n * Defines a smart contract on NEAR including the change (mutable) and view (non-mutable) methods\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#contract](https://docs.near.org/tools/near-api-js/quick-reference#contract)\n * @example\n * ```js\n * import { Contract } from 'near-api-js';\n *\n * async function contractExample() {\n *   const methodOptions = {\n *     viewMethods: ['getMessageByAccountId'],\n *     changeMethods: ['addMessage']\n *   };\n *   const contract = new Contract(\n *     wallet.account(),\n *     'contract-id.testnet',\n *     methodOptions\n *   );\n *\n *   // use a contract view method\n *   const messages = await contract.getMessages({\n *     accountId: 'example-account.testnet'\n *   });\n *\n *   // use a contract change method\n *   await contract.addMessage({\n *      meta: 'some info',\n *      callbackUrl: 'https://example.com/callback',\n *      args: { text: 'my message' },\n *      amount: 1\n *   })\n * }\n * ```\n */\nclass Contract {\n    /**\n     * @param account NEAR account to sign change method transactions\n     * @param contractId NEAR account id where the contract is deployed\n     * @param options NEAR smart contract methods that your application will use. These will be available as `contract.methodName`\n     */\n    constructor(account, contractId, options) {\n        this.account = account;\n        this.contractId = contractId;\n        this.lve = new local_view_execution_1.LocalViewExecution(account);\n        const { viewMethods = [], changeMethods = [], abi: abiRoot, useLocalViewExecution } = options;\n        let viewMethodsWithAbi = viewMethods.map((name) => ({ name, abi: null }));\n        let changeMethodsWithAbi = changeMethods.map((name) => ({ name, abi: null }));\n        if (abiRoot) {\n            if (viewMethodsWithAbi.length > 0 || changeMethodsWithAbi.length > 0) {\n                throw new errors_1.ConflictingOptions();\n            }\n            viewMethodsWithAbi = abiRoot.body.functions\n                .filter((m) => m.kind === near_abi_1.AbiFunctionKind.View)\n                .map((m) => ({ name: m.name, abi: m }));\n            changeMethodsWithAbi = abiRoot.body.functions\n                .filter((methodAbi) => methodAbi.kind === near_abi_1.AbiFunctionKind.Call)\n                .map((methodAbi) => ({ name: methodAbi.name, abi: methodAbi }));\n        }\n        const ajv = createAjv();\n        viewMethodsWithAbi.forEach(({ name, abi }) => {\n            Object.defineProperty(this, name, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(name, (args = {}, options = {}, ...ignored) => __awaiter(this, void 0, void 0, function* () {\n                    if (ignored.length || !(isObject(args) || isUint8Array(args)) || !isObject(options)) {\n                        throw new types_1.PositionalArgsError();\n                    }\n                    if (abi) {\n                        validateArguments(args, abi, ajv, abiRoot);\n                    }\n                    if (useLocalViewExecution) {\n                        try {\n                            return yield this.lve.viewFunction(Object.assign({ contractId: this.contractId, methodName: name, args }, options));\n                        }\n                        catch (error) {\n                            utils_1.Logger.warn(`Local view execution failed with: \"${error.message}\"`);\n                            utils_1.Logger.warn(`Fallback to normal RPC call`);\n                        }\n                    }\n                    return this.account.viewFunction(Object.assign({ contractId: this.contractId, methodName: name, args }, options));\n                }))\n            });\n        });\n        changeMethodsWithAbi.forEach(({ name, abi }) => {\n            Object.defineProperty(this, name, {\n                writable: false,\n                enumerable: true,\n                value: nameFunction(name, (...args) => __awaiter(this, void 0, void 0, function* () {\n                    if (args.length && (args.length > 3 || !(isObject(args[0]) || isUint8Array(args[0])))) {\n                        throw new types_1.PositionalArgsError();\n                    }\n                    if (args.length > 1 || !(args[0] && args[0].args)) {\n                        const deprecate = (0, depd_1.default)('contract.methodName(args, gas, amount)');\n                        deprecate('use `contract.methodName({ args, gas?, amount?, callbackUrl?, meta? })` instead');\n                        args[0] = {\n                            args: args[0],\n                            gas: args[1],\n                            amount: args[2]\n                        };\n                    }\n                    if (abi) {\n                        validateArguments(args[0].args, abi, ajv, abiRoot);\n                    }\n                    return this._changeMethod(Object.assign({ methodName: name }, args[0]));\n                }))\n            });\n        });\n    }\n    _changeMethod({ args, methodName, gas, amount, meta, callbackUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            validateBNLike({ gas, amount });\n            const rawResult = yield this.account.functionCall({\n                contractId: this.contractId,\n                methodName,\n                args,\n                gas,\n                attachedDeposit: amount,\n                walletMeta: meta,\n                walletCallbackUrl: callbackUrl\n            });\n            return (0, utils_1.getTransactionLastResult)(rawResult);\n        });\n    }\n}\nexports.Contract = Contract;\n/**\n * Validation on arguments being a big number from bn.js\n * Throws if an argument is not in BN format or otherwise invalid\n * @param argMap\n */\nfunction validateBNLike(argMap) {\n    const bnLike = 'number, decimal string or BN';\n    for (const argName of Object.keys(argMap)) {\n        const argValue = argMap[argName];\n        if (argValue && !bn_js_1.default.isBN(argValue) && isNaN(argValue)) {\n            throw new types_1.ArgumentTypeError(argName, bnLike, argValue);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9jb250cmFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLGdIQUFnQjtBQUN4QywrQkFBK0IsbUJBQU8sQ0FBQyxtSkFBd0I7QUFDL0QsOEJBQThCLG1CQUFPLENBQUMsK0VBQUs7QUFDM0Msc0NBQXNDLG1CQUFPLENBQUMsbUhBQWE7QUFDM0QsZ0NBQWdDLG1CQUFPLENBQUMsa0ZBQU87QUFDL0MsK0JBQStCLG1CQUFPLENBQUMsOEVBQU07QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsOEZBQVU7QUFDckMsaUJBQWlCLG1CQUFPLENBQUMsaUhBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRFQUE0RTtBQUM1Riw4REFBOEQsaUJBQWlCO0FBQy9FLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0EsdUNBQXVDLHNDQUFzQztBQUM3RTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxxREFBcUQ7QUFDcEk7QUFDQTtBQUNBLHNGQUFzRixjQUFjO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxxREFBcUQ7QUFDMUgsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Qsd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELDBDQUEwQztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsa0JBQWtCO0FBQ2hGLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLGtEQUFrRDtBQUN0RTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjAuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2NvbnRyYWN0LmpzPzExYjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3QgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBuZWFyLWpzL3V0aWxzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90eXBlc1wiKTtcbmNvbnN0IGxvY2FsX3ZpZXdfZXhlY3V0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2NhbC12aWV3LWV4ZWN1dGlvblwiKTtcbmNvbnN0IGFqdl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhanZcIikpO1xuY29uc3QgYWp2X2Zvcm1hdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYWp2LWZvcm1hdHNcIikpO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuY29uc3QgZGVwZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZXBkXCIpKTtcbmNvbnN0IG5lYXJfYWJpXzEgPSByZXF1aXJlKFwibmVhci1hYmlcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8vIE1ha2VzIGBmdW5jdGlvbi5uYW1lYCByZXR1cm4gZ2l2ZW4gbmFtZVxuZnVuY3Rpb24gbmFtZUZ1bmN0aW9uKG5hbWUsIGJvZHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBbbmFtZV0oLi4uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHkoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9W25hbWVdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBcmd1bWVudHMoYXJncywgYWJpRnVuY3Rpb24sIGFqdiwgYWJpUm9vdCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWlzT2JqZWN0KGFyZ3MpKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGFiaUZ1bmN0aW9uLnBhcmFtcyAmJiBhYmlGdW5jdGlvbi5wYXJhbXMuc2VyaWFsaXphdGlvbl90eXBlICE9PSBuZWFyX2FiaV8xLkFiaVNlcmlhbGl6YXRpb25UeXBlLkpzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yKGFiaUZ1bmN0aW9uLm5hbWUsIGFiaUZ1bmN0aW9uLnBhcmFtcy5zZXJpYWxpemF0aW9uX3R5cGUpO1xuICAgIH1cbiAgICBpZiAoYWJpRnVuY3Rpb24ucmVzdWx0ICYmIGFiaUZ1bmN0aW9uLnJlc3VsdC5zZXJpYWxpemF0aW9uX3R5cGUgIT09IG5lYXJfYWJpXzEuQWJpU2VyaWFsaXphdGlvblR5cGUuSnNvbikge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRTZXJpYWxpemF0aW9uRXJyb3IoYWJpRnVuY3Rpb24ubmFtZSwgYWJpRnVuY3Rpb24ucmVzdWx0LnNlcmlhbGl6YXRpb25fdHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9ICgoX2EgPSBhYmlGdW5jdGlvbi5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcmdzKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHAgb2YgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbcC5uYW1lXTtcbiAgICAgICAgY29uc3QgdHlwZVNjaGVtYSA9IHAudHlwZV9zY2hlbWE7XG4gICAgICAgIHR5cGVTY2hlbWEuZGVmaW5pdGlvbnMgPSBhYmlSb290LmJvZHkucm9vdF9zY2hlbWEuZGVmaW5pdGlvbnM7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlID0gYWp2LmNvbXBpbGUodHlwZVNjaGVtYSk7XG4gICAgICAgIGlmICghdmFsaWRhdGUoYXJnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50U2NoZW1hRXJyb3IocC5uYW1lLCB2YWxpZGF0ZS5lcnJvcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIHRoZXJlIGFyZSBubyBleHRyYSB1bmtub3duIGFyZ3VtZW50cyBwYXNzZWRcbiAgICBmb3IgKGNvbnN0IGFyZ05hbWUgb2YgT2JqZWN0LmtleXMoYXJncykpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbXMuZmluZCgocCkgPT4gcC5uYW1lID09PSBhcmdOYW1lKTtcbiAgICAgICAgaWYgKCFwYXJhbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVua25vd25Bcmd1bWVudEVycm9yKGFyZ05hbWUsIHBhcmFtcy5tYXAoKHApID0+IHAubmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQWp2KCkge1xuICAgIC8vIFN0cmljdCBtb2RlIGlzIGRpc2FibGVkIGZvciBub3cgYXMgaXQgY29tcGxhaW5zIGFib3V0IHVua25vd24gZm9ybWF0cy4gV2UgbmVlZCB0b1xuICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugd2FudCB0byBzdXBwb3J0IGEgZml4ZWQgc2V0IG9mIGZvcm1hdHMuIGB1aW50MzJgIGFuZCBgdWludDY0YFxuICAgIC8vIGFyZSBhZGRlZCBleHBsaWNpdGx5IGp1c3QgdG8gcmVkdWNlIHRoZSBhbW91bnQgb2Ygd2FybmluZ3MgYXMgdGhlc2UgYXJlIHZlcnkgcG9wdWxhclxuICAgIC8vIHR5cGVzLlxuICAgIGNvbnN0IGFqdiA9IG5ldyBhanZfMS5kZWZhdWx0KHtcbiAgICAgICAgc3RyaWN0U2NoZW1hOiBmYWxzZSxcbiAgICAgICAgZm9ybWF0czoge1xuICAgICAgICAgICAgdWludDMyOiB0cnVlLFxuICAgICAgICAgICAgdWludDY0OiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAoMCwgYWp2X2Zvcm1hdHNfMS5kZWZhdWx0KShhanYpO1xuICAgIHJldHVybiBhanY7XG59XG5jb25zdCBpc1VpbnQ4QXJyYXkgPSAoeCkgPT4geCAmJiB4LmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCAmJiB4LmJ5dGVMZW5ndGggPT09IHgubGVuZ3RoO1xuY29uc3QgaXNPYmplY3QgPSAoeCkgPT4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBPYmplY3RdJztcbi8qKlxuICogRGVmaW5lcyBhIHNtYXJ0IGNvbnRyYWN0IG9uIE5FQVIgaW5jbHVkaW5nIHRoZSBjaGFuZ2UgKG11dGFibGUpIGFuZCB2aWV3IChub24tbXV0YWJsZSkgbWV0aG9kc1xuICpcbiAqIEBzZWUgW2h0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2UjY29udHJhY3RdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2UjY29udHJhY3QpXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqIGltcG9ydCB7IENvbnRyYWN0IH0gZnJvbSAnbmVhci1hcGktanMnO1xuICpcbiAqIGFzeW5jIGZ1bmN0aW9uIGNvbnRyYWN0RXhhbXBsZSgpIHtcbiAqICAgY29uc3QgbWV0aG9kT3B0aW9ucyA9IHtcbiAqICAgICB2aWV3TWV0aG9kczogWydnZXRNZXNzYWdlQnlBY2NvdW50SWQnXSxcbiAqICAgICBjaGFuZ2VNZXRob2RzOiBbJ2FkZE1lc3NhZ2UnXVxuICogICB9O1xuICogICBjb25zdCBjb250cmFjdCA9IG5ldyBDb250cmFjdChcbiAqICAgICB3YWxsZXQuYWNjb3VudCgpLFxuICogICAgICdjb250cmFjdC1pZC50ZXN0bmV0JyxcbiAqICAgICBtZXRob2RPcHRpb25zXG4gKiAgICk7XG4gKlxuICogICAvLyB1c2UgYSBjb250cmFjdCB2aWV3IG1ldGhvZFxuICogICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IGNvbnRyYWN0LmdldE1lc3NhZ2VzKHtcbiAqICAgICBhY2NvdW50SWQ6ICdleGFtcGxlLWFjY291bnQudGVzdG5ldCdcbiAqICAgfSk7XG4gKlxuICogICAvLyB1c2UgYSBjb250cmFjdCBjaGFuZ2UgbWV0aG9kXG4gKiAgIGF3YWl0IGNvbnRyYWN0LmFkZE1lc3NhZ2Uoe1xuICogICAgICBtZXRhOiAnc29tZSBpbmZvJyxcbiAqICAgICAgY2FsbGJhY2tVcmw6ICdodHRwczovL2V4YW1wbGUuY29tL2NhbGxiYWNrJyxcbiAqICAgICAgYXJnczogeyB0ZXh0OiAnbXkgbWVzc2FnZScgfSxcbiAqICAgICAgYW1vdW50OiAxXG4gKiAgIH0pXG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29udHJhY3Qge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhY2NvdW50IE5FQVIgYWNjb3VudCB0byBzaWduIGNoYW5nZSBtZXRob2QgdHJhbnNhY3Rpb25zXG4gICAgICogQHBhcmFtIGNvbnRyYWN0SWQgTkVBUiBhY2NvdW50IGlkIHdoZXJlIHRoZSBjb250cmFjdCBpcyBkZXBsb3llZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIE5FQVIgc21hcnQgY29udHJhY3QgbWV0aG9kcyB0aGF0IHlvdXIgYXBwbGljYXRpb24gd2lsbCB1c2UuIFRoZXNlIHdpbGwgYmUgYXZhaWxhYmxlIGFzIGBjb250cmFjdC5tZXRob2ROYW1lYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFjY291bnQsIGNvbnRyYWN0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50ID0gYWNjb3VudDtcbiAgICAgICAgdGhpcy5jb250cmFjdElkID0gY29udHJhY3RJZDtcbiAgICAgICAgdGhpcy5sdmUgPSBuZXcgbG9jYWxfdmlld19leGVjdXRpb25fMS5Mb2NhbFZpZXdFeGVjdXRpb24oYWNjb3VudCk7XG4gICAgICAgIGNvbnN0IHsgdmlld01ldGhvZHMgPSBbXSwgY2hhbmdlTWV0aG9kcyA9IFtdLCBhYmk6IGFiaVJvb3QsIHVzZUxvY2FsVmlld0V4ZWN1dGlvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgbGV0IHZpZXdNZXRob2RzV2l0aEFiaSA9IHZpZXdNZXRob2RzLm1hcCgobmFtZSkgPT4gKHsgbmFtZSwgYWJpOiBudWxsIH0pKTtcbiAgICAgICAgbGV0IGNoYW5nZU1ldGhvZHNXaXRoQWJpID0gY2hhbmdlTWV0aG9kcy5tYXAoKG5hbWUpID0+ICh7IG5hbWUsIGFiaTogbnVsbCB9KSk7XG4gICAgICAgIGlmIChhYmlSb290KSB7XG4gICAgICAgICAgICBpZiAodmlld01ldGhvZHNXaXRoQWJpLmxlbmd0aCA+IDAgfHwgY2hhbmdlTWV0aG9kc1dpdGhBYmkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Db25mbGljdGluZ09wdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZpZXdNZXRob2RzV2l0aEFiaSA9IGFiaVJvb3QuYm9keS5mdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChtKSA9PiBtLmtpbmQgPT09IG5lYXJfYWJpXzEuQWJpRnVuY3Rpb25LaW5kLlZpZXcpXG4gICAgICAgICAgICAgICAgLm1hcCgobSkgPT4gKHsgbmFtZTogbS5uYW1lLCBhYmk6IG0gfSkpO1xuICAgICAgICAgICAgY2hhbmdlTWV0aG9kc1dpdGhBYmkgPSBhYmlSb290LmJvZHkuZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigobWV0aG9kQWJpKSA9PiBtZXRob2RBYmkua2luZCA9PT0gbmVhcl9hYmlfMS5BYmlGdW5jdGlvbktpbmQuQ2FsbClcbiAgICAgICAgICAgICAgICAubWFwKChtZXRob2RBYmkpID0+ICh7IG5hbWU6IG1ldGhvZEFiaS5uYW1lLCBhYmk6IG1ldGhvZEFiaSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWp2ID0gY3JlYXRlQWp2KCk7XG4gICAgICAgIHZpZXdNZXRob2RzV2l0aEFiaS5mb3JFYWNoKCh7IG5hbWUsIGFiaSB9KSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lRnVuY3Rpb24obmFtZSwgKGFyZ3MgPSB7fSwgb3B0aW9ucyA9IHt9LCAuLi5pZ25vcmVkKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkLmxlbmd0aCB8fCAhKGlzT2JqZWN0KGFyZ3MpIHx8IGlzVWludDhBcnJheShhcmdzKSkgfHwgIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgdHlwZXNfMS5Qb3NpdGlvbmFsQXJnc0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFiaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVBcmd1bWVudHMoYXJncywgYWJpLCBhanYsIGFiaVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VMb2NhbFZpZXdFeGVjdXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMubHZlLnZpZXdGdW5jdGlvbihPYmplY3QuYXNzaWduKHsgY29udHJhY3RJZDogdGhpcy5jb250cmFjdElkLCBtZXRob2ROYW1lOiBuYW1lLCBhcmdzIH0sIG9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLndhcm4oYExvY2FsIHZpZXcgZXhlY3V0aW9uIGZhaWxlZCB3aXRoOiBcIiR7ZXJyb3IubWVzc2FnZX1cImApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxzXzEuTG9nZ2VyLndhcm4oYEZhbGxiYWNrIHRvIG5vcm1hbCBSUEMgY2FsbGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY291bnQudmlld0Z1bmN0aW9uKE9iamVjdC5hc3NpZ24oeyBjb250cmFjdElkOiB0aGlzLmNvbnRyYWN0SWQsIG1ldGhvZE5hbWU6IG5hbWUsIGFyZ3MgfSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGFuZ2VNZXRob2RzV2l0aEFiaS5mb3JFYWNoKCh7IG5hbWUsIGFiaSB9KSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgbmFtZSwge1xuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lRnVuY3Rpb24obmFtZSwgKC4uLmFyZ3MpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoICYmIChhcmdzLmxlbmd0aCA+IDMgfHwgIShpc09iamVjdChhcmdzWzBdKSB8fCBpc1VpbnQ4QXJyYXkoYXJnc1swXSkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuUG9zaXRpb25hbEFyZ3NFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDEgfHwgIShhcmdzWzBdICYmIGFyZ3NbMF0uYXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcHJlY2F0ZSA9ICgwLCBkZXBkXzEuZGVmYXVsdCkoJ2NvbnRyYWN0Lm1ldGhvZE5hbWUoYXJncywgZ2FzLCBhbW91bnQpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGUoJ3VzZSBgY29udHJhY3QubWV0aG9kTmFtZSh7IGFyZ3MsIGdhcz8sIGFtb3VudD8sIGNhbGxiYWNrVXJsPywgbWV0YT8gfSlgIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXM6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBhcmdzWzJdXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQXJndW1lbnRzKGFyZ3NbMF0uYXJncywgYWJpLCBhanYsIGFiaVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VNZXRob2QoT2JqZWN0LmFzc2lnbih7IG1ldGhvZE5hbWU6IG5hbWUgfSwgYXJnc1swXSkpO1xuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY2hhbmdlTWV0aG9kKHsgYXJncywgbWV0aG9kTmFtZSwgZ2FzLCBhbW91bnQsIG1ldGEsIGNhbGxiYWNrVXJsIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQk5MaWtlKHsgZ2FzLCBhbW91bnQgfSk7XG4gICAgICAgICAgICBjb25zdCByYXdSZXN1bHQgPSB5aWVsZCB0aGlzLmFjY291bnQuZnVuY3Rpb25DYWxsKHtcbiAgICAgICAgICAgICAgICBjb250cmFjdElkOiB0aGlzLmNvbnRyYWN0SWQsXG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICBhdHRhY2hlZERlcG9zaXQ6IGFtb3VudCxcbiAgICAgICAgICAgICAgICB3YWxsZXRNZXRhOiBtZXRhLFxuICAgICAgICAgICAgICAgIHdhbGxldENhbGxiYWNrVXJsOiBjYWxsYmFja1VybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuZ2V0VHJhbnNhY3Rpb25MYXN0UmVzdWx0KShyYXdSZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0ID0gQ29udHJhY3Q7XG4vKipcbiAqIFZhbGlkYXRpb24gb24gYXJndW1lbnRzIGJlaW5nIGEgYmlnIG51bWJlciBmcm9tIGJuLmpzXG4gKiBUaHJvd3MgaWYgYW4gYXJndW1lbnQgaXMgbm90IGluIEJOIGZvcm1hdCBvciBvdGhlcndpc2UgaW52YWxpZFxuICogQHBhcmFtIGFyZ01hcFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJOTGlrZShhcmdNYXApIHtcbiAgICBjb25zdCBibkxpa2UgPSAnbnVtYmVyLCBkZWNpbWFsIHN0cmluZyBvciBCTic7XG4gICAgZm9yIChjb25zdCBhcmdOYW1lIG9mIE9iamVjdC5rZXlzKGFyZ01hcCkpIHtcbiAgICAgICAgY29uc3QgYXJnVmFsdWUgPSBhcmdNYXBbYXJnTmFtZV07XG4gICAgICAgIGlmIChhcmdWYWx1ZSAmJiAhYm5fanNfMS5kZWZhdWx0LmlzQk4oYXJnVmFsdWUpICYmIGlzTmFOKGFyZ1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuQXJndW1lbnRUeXBlRXJyb3IoYXJnTmFtZSwgYm5MaWtlLCBhcmdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/errors.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/errors.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConflictingOptions = exports.ArgumentSchemaError = exports.UnknownArgumentError = exports.UnsupportedSerializationError = void 0;\nclass UnsupportedSerializationError extends Error {\n    constructor(methodName, serializationType) {\n        super(`Contract method '${methodName}' is using an unsupported serialization type ${serializationType}`);\n    }\n}\nexports.UnsupportedSerializationError = UnsupportedSerializationError;\nclass UnknownArgumentError extends Error {\n    constructor(actualArgName, expectedArgNames) {\n        super(`Unrecognized argument '${actualArgName}', expected '${JSON.stringify(expectedArgNames)}'`);\n    }\n}\nexports.UnknownArgumentError = UnknownArgumentError;\nclass ArgumentSchemaError extends Error {\n    constructor(argName, errors) {\n        super(`Argument '${argName}' does not conform to the specified ABI schema: '${JSON.stringify(errors)}'`);\n    }\n}\nexports.ArgumentSchemaError = ArgumentSchemaError;\nclass ConflictingOptions extends Error {\n    constructor() {\n        super('Conflicting contract method options have been passed. You can either specify ABI or a list of view/call methods.');\n    }\n}\nexports.ConflictingOptions = ConflictingOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsNEJBQTRCLEdBQUcscUNBQXFDO0FBQy9IO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVywrQ0FBK0Msa0JBQWtCO0FBQzlHO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHdDQUF3QyxjQUFjLGVBQWUsaUNBQWlDO0FBQ3RHO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDJCQUEyQixRQUFRLG1EQUFtRCx1QkFBdUI7QUFDN0c7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcythY2NvdW50c0AxLjAuNC9ub2RlX21vZHVsZXMvQG5lYXItanMvYWNjb3VudHMvbGliL2Vycm9ycy5qcz9kNzNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25mbGljdGluZ09wdGlvbnMgPSBleHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBleHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gZXhwb3J0cy5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvciA9IHZvaWQgMDtcbmNsYXNzIFVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1ldGhvZE5hbWUsIHNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgICAgIHN1cGVyKGBDb250cmFjdCBtZXRob2QgJyR7bWV0aG9kTmFtZX0nIGlzIHVzaW5nIGFuIHVuc3VwcG9ydGVkIHNlcmlhbGl6YXRpb24gdHlwZSAke3NlcmlhbGl6YXRpb25UeXBlfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5zdXBwb3J0ZWRTZXJpYWxpemF0aW9uRXJyb3IgPSBVbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcjtcbmNsYXNzIFVua25vd25Bcmd1bWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFjdHVhbEFyZ05hbWUsIGV4cGVjdGVkQXJnTmFtZXMpIHtcbiAgICAgICAgc3VwZXIoYFVucmVjb2duaXplZCBhcmd1bWVudCAnJHthY3R1YWxBcmdOYW1lfScsIGV4cGVjdGVkICcke0pTT04uc3RyaW5naWZ5KGV4cGVjdGVkQXJnTmFtZXMpfSdgKTtcbiAgICB9XG59XG5leHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gVW5rbm93bkFyZ3VtZW50RXJyb3I7XG5jbGFzcyBBcmd1bWVudFNjaGVtYUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFyZ05hbWUsIGVycm9ycykge1xuICAgICAgICBzdXBlcihgQXJndW1lbnQgJyR7YXJnTmFtZX0nIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIHNwZWNpZmllZCBBQkkgc2NoZW1hOiAnJHtKU09OLnN0cmluZ2lmeShlcnJvcnMpfSdgKTtcbiAgICB9XG59XG5leHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBBcmd1bWVudFNjaGVtYUVycm9yO1xuY2xhc3MgQ29uZmxpY3RpbmdPcHRpb25zIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ29uZmxpY3RpbmcgY29udHJhY3QgbWV0aG9kIG9wdGlvbnMgaGF2ZSBiZWVuIHBhc3NlZC4gWW91IGNhbiBlaXRoZXIgc3BlY2lmeSBBQkkgb3IgYSBsaXN0IG9mIHZpZXcvY2FsbCBtZXRob2RzLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uZmxpY3RpbmdPcHRpb25zID0gQ29uZmxpY3RpbmdPcHRpb25zO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/index.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/index.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = exports.UnsupportedSerializationError = exports.UnknownArgumentError = exports.ConflictingOptions = exports.ArgumentSchemaError = exports.Contract = exports.MULTISIG_CONFIRM_METHODS = exports.MULTISIG_CHANGE_METHODS = exports.MULTISIG_DEPOSIT = exports.MULTISIG_GAS = exports.MULTISIG_ALLOWANCE = exports.MULTISIG_STORAGE_KEY = exports.Connection = exports.AccountMultisig = exports.UrlAccountCreator = exports.LocalAccountCreator = exports.AccountCreator = exports.Account2FA = exports.Account = void 0;\nvar account_1 = __webpack_require__(/*! ./account */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account.js\");\nObject.defineProperty(exports, \"Account\", ({ enumerable: true, get: function () { return account_1.Account; } }));\nvar account_2fa_1 = __webpack_require__(/*! ./account_2fa */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_2fa.js\");\nObject.defineProperty(exports, \"Account2FA\", ({ enumerable: true, get: function () { return account_2fa_1.Account2FA; } }));\nvar account_creator_1 = __webpack_require__(/*! ./account_creator */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_creator.js\");\nObject.defineProperty(exports, \"AccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.AccountCreator; } }));\nObject.defineProperty(exports, \"LocalAccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.LocalAccountCreator; } }));\nObject.defineProperty(exports, \"UrlAccountCreator\", ({ enumerable: true, get: function () { return account_creator_1.UrlAccountCreator; } }));\nvar account_multisig_1 = __webpack_require__(/*! ./account_multisig */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/account_multisig.js\");\nObject.defineProperty(exports, \"AccountMultisig\", ({ enumerable: true, get: function () { return account_multisig_1.AccountMultisig; } }));\nvar connection_1 = __webpack_require__(/*! ./connection */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/connection.js\");\nObject.defineProperty(exports, \"Connection\", ({ enumerable: true, get: function () { return connection_1.Connection; } }));\nvar constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/constants.js\");\nObject.defineProperty(exports, \"MULTISIG_STORAGE_KEY\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_STORAGE_KEY; } }));\nObject.defineProperty(exports, \"MULTISIG_ALLOWANCE\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_ALLOWANCE; } }));\nObject.defineProperty(exports, \"MULTISIG_GAS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_GAS; } }));\nObject.defineProperty(exports, \"MULTISIG_DEPOSIT\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_DEPOSIT; } }));\nObject.defineProperty(exports, \"MULTISIG_CHANGE_METHODS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_CHANGE_METHODS; } }));\nObject.defineProperty(exports, \"MULTISIG_CONFIRM_METHODS\", ({ enumerable: true, get: function () { return constants_1.MULTISIG_CONFIRM_METHODS; } }));\nvar contract_1 = __webpack_require__(/*! ./contract */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/contract.js\");\nObject.defineProperty(exports, \"Contract\", ({ enumerable: true, get: function () { return contract_1.Contract; } }));\nvar errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/errors.js\");\nObject.defineProperty(exports, \"ArgumentSchemaError\", ({ enumerable: true, get: function () { return errors_1.ArgumentSchemaError; } }));\nObject.defineProperty(exports, \"ConflictingOptions\", ({ enumerable: true, get: function () { return errors_1.ConflictingOptions; } }));\nObject.defineProperty(exports, \"UnknownArgumentError\", ({ enumerable: true, get: function () { return errors_1.UnknownArgumentError; } }));\nObject.defineProperty(exports, \"UnsupportedSerializationError\", ({ enumerable: true, get: function () { return errors_1.UnsupportedSerializationError; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/types.js\");\nObject.defineProperty(exports, \"MultisigDeleteRequestRejectionError\", ({ enumerable: true, get: function () { return types_1.MultisigDeleteRequestRejectionError; } }));\nObject.defineProperty(exports, \"MultisigStateStatus\", ({ enumerable: true, get: function () { return types_1.MultisigStateStatus; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQ0FBMkMsR0FBRyxxQ0FBcUMsR0FBRyw0QkFBNEIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRyxnQkFBZ0IsR0FBRyxnQ0FBZ0MsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxrQkFBa0IsR0FBRyxlQUFlO0FBQzFqQixnQkFBZ0IsbUJBQU8sQ0FBQyxtSEFBVztBQUNuQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csb0JBQW9CLG1CQUFPLENBQUMsMkhBQWU7QUFDM0MsOENBQTZDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3pILHdCQUF3QixtQkFBTyxDQUFDLG1JQUFtQjtBQUNuRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckksdURBQXNELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQy9JLHFEQUFvRCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMzSSx5QkFBeUIsbUJBQU8sQ0FBQyxxSUFBb0I7QUFDckQsbURBQWtELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ3hJLG1CQUFtQixtQkFBTyxDQUFDLHlIQUFjO0FBQ3pDLDhDQUE2QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN4SCxrQkFBa0IsbUJBQU8sQ0FBQyx1SEFBYTtBQUN2Qyx3REFBdUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDM0ksc0RBQXFELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3ZJLGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCxvREFBbUQsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDbkksMkRBQTBELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ2pKLDREQUEyRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUNuSixpQkFBaUIsbUJBQU8sQ0FBQyxxSEFBWTtBQUNyQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDbEgsZUFBZSxtQkFBTyxDQUFDLGlIQUFVO0FBQ2pDLHVEQUFzRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUN0SSxzREFBcUQsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDcEksd0RBQXVELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ3hJLGlFQUFnRSxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUMxSixjQUFjLG1CQUFPLENBQUMsK0dBQVM7QUFDL0IsdUVBQXNFLEVBQUUscUNBQXFDLHVEQUF1RCxFQUFDO0FBQ3JLLHVEQUFzRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9pbmRleC5qcz9iMzg0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdWx0aXNpZ1N0YXRlU3RhdHVzID0gZXhwb3J0cy5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRTZXJpYWxpemF0aW9uRXJyb3IgPSBleHBvcnRzLlVua25vd25Bcmd1bWVudEVycm9yID0gZXhwb3J0cy5Db25mbGljdGluZ09wdGlvbnMgPSBleHBvcnRzLkFyZ3VtZW50U2NoZW1hRXJyb3IgPSBleHBvcnRzLkNvbnRyYWN0ID0gZXhwb3J0cy5NVUxUSVNJR19DT05GSVJNX01FVEhPRFMgPSBleHBvcnRzLk1VTFRJU0lHX0NIQU5HRV9NRVRIT0RTID0gZXhwb3J0cy5NVUxUSVNJR19ERVBPU0lUID0gZXhwb3J0cy5NVUxUSVNJR19HQVMgPSBleHBvcnRzLk1VTFRJU0lHX0FMTE9XQU5DRSA9IGV4cG9ydHMuTVVMVElTSUdfU1RPUkFHRV9LRVkgPSBleHBvcnRzLkNvbm5lY3Rpb24gPSBleHBvcnRzLkFjY291bnRNdWx0aXNpZyA9IGV4cG9ydHMuVXJsQWNjb3VudENyZWF0b3IgPSBleHBvcnRzLkxvY2FsQWNjb3VudENyZWF0b3IgPSBleHBvcnRzLkFjY291bnRDcmVhdG9yID0gZXhwb3J0cy5BY2NvdW50MkZBID0gZXhwb3J0cy5BY2NvdW50ID0gdm9pZCAwO1xudmFyIGFjY291bnRfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50XzEuQWNjb3VudDsgfSB9KTtcbnZhciBhY2NvdW50XzJmYV8xID0gcmVxdWlyZShcIi4vYWNjb3VudF8yZmFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50MkZBXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50XzJmYV8xLkFjY291bnQyRkE7IH0gfSk7XG52YXIgYWNjb3VudF9jcmVhdG9yXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50X2NyZWF0b3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50Q3JlYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWNjb3VudF9jcmVhdG9yXzEuQWNjb3VudENyZWF0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMb2NhbEFjY291bnRDcmVhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhY2NvdW50X2NyZWF0b3JfMS5Mb2NhbEFjY291bnRDcmVhdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXJsQWNjb3VudENyZWF0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjY291bnRfY3JlYXRvcl8xLlVybEFjY291bnRDcmVhdG9yOyB9IH0pO1xudmFyIGFjY291bnRfbXVsdGlzaWdfMSA9IHJlcXVpcmUoXCIuL2FjY291bnRfbXVsdGlzaWdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2NvdW50TXVsdGlzaWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFjY291bnRfbXVsdGlzaWdfMS5BY2NvdW50TXVsdGlzaWc7IH0gfSk7XG52YXIgY29ubmVjdGlvbl8xID0gcmVxdWlyZShcIi4vY29ubmVjdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbm5lY3Rpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpb25fMS5Db25uZWN0aW9uOyB9IH0pO1xudmFyIGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTVVMVElTSUdfU1RPUkFHRV9LRVlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX1NUT1JBR0VfS0VZOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTVVMVElTSUdfQUxMT1dBTkNFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5NVUxUSVNJR19BTExPV0FOQ0U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNVUxUSVNJR19HQVNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX0dBUzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1VTFRJU0lHX0RFUE9TSVRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX0RFUE9TSVQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNVUxUSVNJR19DSEFOR0VfTUVUSE9EU1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuTVVMVElTSUdfQ0hBTkdFX01FVEhPRFM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNVUxUSVNJR19DT05GSVJNX01FVEhPRFNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLk1VTFRJU0lHX0NPTkZJUk1fTUVUSE9EUzsgfSB9KTtcbnZhciBjb250cmFjdF8xID0gcmVxdWlyZShcIi4vY29udHJhY3RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb250cmFjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29udHJhY3RfMS5Db250cmFjdDsgfSB9KTtcbnZhciBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFyZ3VtZW50U2NoZW1hRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLkFyZ3VtZW50U2NoZW1hRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25mbGljdGluZ09wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc18xLkNvbmZsaWN0aW5nT3B0aW9uczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVua25vd25Bcmd1bWVudEVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5Vbmtub3duQXJndW1lbnRFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuc3VwcG9ydGVkU2VyaWFsaXphdGlvbkVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5VbnN1cHBvcnRlZFNlcmlhbGl6YXRpb25FcnJvcjsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk11bHRpc2lnU3RhdGVTdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuTXVsdGlzaWdTdGF0ZVN0YXR1czsgfSB9KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/index.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/index.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocalViewExecution = void 0;\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.1.0/node_modules/@near-js/utils/lib/index.js\");\nconst storage_1 = __webpack_require__(/*! ./storage */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/storage.js\");\nconst runtime_1 = __webpack_require__(/*! ./runtime */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/runtime.js\");\nclass LocalViewExecution {\n    constructor(account) {\n        this.account = account;\n        this.storage = new storage_1.Storage();\n    }\n    fetchContractCode(contractId, blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this.account.connection.provider.query(Object.assign({ request_type: 'view_code', account_id: contractId }, blockQuery));\n            return result.code_base64;\n        });\n    }\n    fetchContractState(blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.account.viewState('', blockQuery);\n        });\n    }\n    fetch(contractId, blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const block = yield this.account.connection.provider.block(blockQuery);\n            const blockHash = block.header.hash;\n            const blockHeight = block.header.height;\n            const blockTimestamp = block.header.timestamp;\n            const contractCode = yield this.fetchContractCode(contractId, blockQuery);\n            const contractState = yield this.fetchContractState(blockQuery);\n            return {\n                blockHash,\n                blockHeight,\n                blockTimestamp,\n                contractCode,\n                contractState,\n            };\n        });\n    }\n    loadOrFetch(contractId, blockQuery) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = this.storage.load(blockQuery);\n            if (stored) {\n                return stored;\n            }\n            const _a = yield this.fetch(contractId, blockQuery), { blockHash } = _a, fetched = __rest(_a, [\"blockHash\"]);\n            this.storage.save(blockHash, fetched);\n            return fetched;\n        });\n    }\n    /**\n     * Calls a view function on a contract, fetching the contract code and state if needed.\n     * @param options Options for calling the view function.\n     * @param options.contractId The contract account ID.\n     * @param options.methodName The name of the view function to call.\n     * @param options.args The arguments to pass to the view function.\n     * @param options.blockQuery The block query options.\n     * @returns {Promise<any>} - A promise that resolves to the result of the view function.\n     */\n    viewFunction(_a) {\n        var { contractId, methodName, args = {}, blockQuery = { finality: 'optimistic' } } = _a, ignored = __rest(_a, [\"contractId\", \"methodName\", \"args\", \"blockQuery\"]);\n        return __awaiter(this, void 0, void 0, function* () {\n            const methodArgs = JSON.stringify(args);\n            const { contractCode, contractState, blockHeight, blockTimestamp } = yield this.loadOrFetch(contractId, blockQuery);\n            const runtime = new runtime_1.Runtime({ contractId, contractCode, contractState, blockHeight, blockTimestamp, methodArgs });\n            const { result, logs } = yield runtime.execute(methodName);\n            if (logs) {\n                (0, utils_1.printTxOutcomeLogs)({ contractId, logs });\n            }\n            return JSON.parse(Buffer.from(result).toString());\n        });\n    }\n}\nexports.LocalViewExecution = LocalViewExecution;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9sb2NhbC12aWV3LWV4ZWN1dGlvbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMsZ0hBQWdCO0FBQ3hDLGtCQUFrQixtQkFBTyxDQUFDLHdJQUFXO0FBQ3JDLGtCQUFrQixtQkFBTyxDQUFDLHdJQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLG1EQUFtRDtBQUMzSTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxZQUFZO0FBQy9FO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQyxpQkFBaUIsMkJBQTJCO0FBQzNGO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQTJEO0FBQy9FLG9EQUFvRCxrRkFBa0Y7QUFDdEksb0JBQW9CLGVBQWU7QUFDbkM7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9sb2NhbC12aWV3LWV4ZWN1dGlvbi9pbmRleC5qcz84ZWRhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvY2FsVmlld0V4ZWN1dGlvbiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCBzdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zdG9yYWdlXCIpO1xuY29uc3QgcnVudGltZV8xID0gcmVxdWlyZShcIi4vcnVudGltZVwiKTtcbmNsYXNzIExvY2FsVmlld0V4ZWN1dGlvbiB7XG4gICAgY29uc3RydWN0b3IoYWNjb3VudCkge1xuICAgICAgICB0aGlzLmFjY291bnQgPSBhY2NvdW50O1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBuZXcgc3RvcmFnZV8xLlN0b3JhZ2UoKTtcbiAgICB9XG4gICAgZmV0Y2hDb250cmFjdENvZGUoY29udHJhY3RJZCwgYmxvY2tRdWVyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5hY2NvdW50LmNvbm5lY3Rpb24ucHJvdmlkZXIucXVlcnkoT2JqZWN0LmFzc2lnbih7IHJlcXVlc3RfdHlwZTogJ3ZpZXdfY29kZScsIGFjY291bnRfaWQ6IGNvbnRyYWN0SWQgfSwgYmxvY2tRdWVyeSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb2RlX2Jhc2U2NDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoQ29udHJhY3RTdGF0ZShibG9ja1F1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY2NvdW50LnZpZXdTdGF0ZSgnJywgYmxvY2tRdWVyeSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaChjb250cmFjdElkLCBibG9ja1F1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuYWNjb3VudC5jb25uZWN0aW9uLnByb3ZpZGVyLmJsb2NrKGJsb2NrUXVlcnkpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gYmxvY2suaGVhZGVyLmhhc2g7XG4gICAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IGJsb2NrLmhlYWRlci5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBibG9ja1RpbWVzdGFtcCA9IGJsb2NrLmhlYWRlci50aW1lc3RhbXA7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdENvZGUgPSB5aWVsZCB0aGlzLmZldGNoQ29udHJhY3RDb2RlKGNvbnRyYWN0SWQsIGJsb2NrUXVlcnkpO1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RTdGF0ZSA9IHlpZWxkIHRoaXMuZmV0Y2hDb250cmFjdFN0YXRlKGJsb2NrUXVlcnkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBibG9ja0hhc2gsXG4gICAgICAgICAgICAgICAgYmxvY2tIZWlnaHQsXG4gICAgICAgICAgICAgICAgYmxvY2tUaW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgY29udHJhY3RDb2RlLFxuICAgICAgICAgICAgICAgIGNvbnRyYWN0U3RhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9hZE9yRmV0Y2goY29udHJhY3RJZCwgYmxvY2tRdWVyeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0gdGhpcy5zdG9yYWdlLmxvYWQoYmxvY2tRdWVyeSk7XG4gICAgICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IF9hID0geWllbGQgdGhpcy5mZXRjaChjb250cmFjdElkLCBibG9ja1F1ZXJ5KSwgeyBibG9ja0hhc2ggfSA9IF9hLCBmZXRjaGVkID0gX19yZXN0KF9hLCBbXCJibG9ja0hhc2hcIl0pO1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNhdmUoYmxvY2tIYXNoLCBmZXRjaGVkKTtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaGVkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSB2aWV3IGZ1bmN0aW9uIG9uIGEgY29udHJhY3QsIGZldGNoaW5nIHRoZSBjb250cmFjdCBjb2RlIGFuZCBzdGF0ZSBpZiBuZWVkZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgY2FsbGluZyB0aGUgdmlldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cmFjdElkIFRoZSBjb250cmFjdCBhY2NvdW50IElELlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIHZpZXcgZnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcmdzIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgdmlldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ibG9ja1F1ZXJ5IFRoZSBibG9jayBxdWVyeSBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3VsdCBvZiB0aGUgdmlldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICB2aWV3RnVuY3Rpb24oX2EpIHtcbiAgICAgICAgdmFyIHsgY29udHJhY3RJZCwgbWV0aG9kTmFtZSwgYXJncyA9IHt9LCBibG9ja1F1ZXJ5ID0geyBmaW5hbGl0eTogJ29wdGltaXN0aWMnIH0gfSA9IF9hLCBpZ25vcmVkID0gX19yZXN0KF9hLCBbXCJjb250cmFjdElkXCIsIFwibWV0aG9kTmFtZVwiLCBcImFyZ3NcIiwgXCJibG9ja1F1ZXJ5XCJdKTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEFyZ3MgPSBKU09OLnN0cmluZ2lmeShhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY29udHJhY3RDb2RlLCBjb250cmFjdFN0YXRlLCBibG9ja0hlaWdodCwgYmxvY2tUaW1lc3RhbXAgfSA9IHlpZWxkIHRoaXMubG9hZE9yRmV0Y2goY29udHJhY3RJZCwgYmxvY2tRdWVyeSk7XG4gICAgICAgICAgICBjb25zdCBydW50aW1lID0gbmV3IHJ1bnRpbWVfMS5SdW50aW1lKHsgY29udHJhY3RJZCwgY29udHJhY3RDb2RlLCBjb250cmFjdFN0YXRlLCBibG9ja0hlaWdodCwgYmxvY2tUaW1lc3RhbXAsIG1ldGhvZEFyZ3MgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHJlc3VsdCwgbG9ncyB9ID0geWllbGQgcnVudGltZS5leGVjdXRlKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgaWYgKGxvZ3MpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfMS5wcmludFR4T3V0Y29tZUxvZ3MpKHsgY29udHJhY3RJZCwgbG9ncyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEJ1ZmZlci5mcm9tKHJlc3VsdCkudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9jYWxWaWV3RXhlY3V0aW9uID0gTG9jYWxWaWV3RXhlY3V0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/runtime.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/runtime.js ***!
  \***********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Runtime = void 0;\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst notImplemented = (name) => () => {\n    throw new Error('method not implemented: ' + name);\n};\nconst prohibitedInView = (name) => () => {\n    throw new Error('method not available for view calls: ' + name);\n};\nclass Runtime {\n    constructor(_a) {\n        var { contractCode } = _a, context = __rest(_a, [\"contractCode\"]);\n        this.context = context;\n        this.wasm = this.prepareWASM(Buffer.from(contractCode, 'base64'));\n        this.memory = new WebAssembly.Memory({ initial: 1024, maximum: 2048 });\n        this.registers = {};\n        this.logs = [];\n        this.result = Buffer.from([]);\n    }\n    readUTF16CStr(ptr) {\n        const arr = [];\n        const mem = new Uint16Array(this.memory.buffer);\n        let key = Number(ptr) / 2;\n        while (mem[key] != 0) {\n            arr.push(mem[key]);\n            key++;\n        }\n        return Buffer.from(Uint16Array.from(arr).buffer).toString('ucs2');\n    }\n    readUTF8CStr(len, ptr) {\n        const arr = [];\n        const mem = new Uint8Array(this.memory.buffer);\n        let key = Number(ptr);\n        for (let i = 0; i < len && mem[key] != 0; i++) {\n            arr.push(mem[key]);\n            key++;\n        }\n        return Buffer.from(arr).toString('utf8');\n    }\n    storageRead(keyLen, keyPtr) {\n        const storageKey = Buffer.from(new Uint8Array(this.memory.buffer, Number(keyPtr), Number(keyLen)));\n        const stateVal = this.context.contractState.filter((obj) => Buffer.compare(obj.key, storageKey) === 0).map((obj) => obj.value);\n        if (stateVal.length === 0)\n            return null;\n        return stateVal.length > 1 ? stateVal : stateVal[0];\n    }\n    prepareWASM(input) {\n        const parts = [];\n        const magic = input.subarray(0, 4);\n        if (magic.toString('utf8') !== '\\0asm') {\n            throw new Error('Invalid magic number');\n        }\n        const version = input.readUInt32LE(4);\n        if (version != 1) {\n            throw new Error('Invalid version: ' + version);\n        }\n        let offset = 8;\n        parts.push(input.subarray(0, offset));\n        function decodeLEB128() {\n            let result = 0;\n            let shift = 0;\n            let byte;\n            do {\n                byte = input[offset++];\n                result |= (byte & 0x7f) << shift;\n                shift += 7;\n            } while (byte & 0x80);\n            return result;\n        }\n        function decodeLimits() {\n            const flags = input[offset++];\n            const hasMax = flags & 0x1;\n            const initial = decodeLEB128();\n            const max = hasMax ? decodeLEB128() : null;\n            return { initial, max };\n        }\n        function decodeString() {\n            const length = decodeLEB128();\n            const result = input.subarray(offset, offset + length);\n            offset += length;\n            return result.toString('utf8');\n        }\n        function encodeLEB128(value) {\n            const result = [];\n            do {\n                let byte = value & 0x7f;\n                value >>= 7;\n                if (value !== 0) {\n                    byte |= 0x80;\n                }\n                result.push(byte);\n            } while (value !== 0);\n            return Buffer.from(result);\n        }\n        function encodeString(value) {\n            const result = Buffer.from(value, 'utf8');\n            return Buffer.concat([encodeLEB128(result.length), result]);\n        }\n        do {\n            const sectionStart = offset;\n            const sectionId = input.readUInt8(offset);\n            offset++;\n            const sectionSize = decodeLEB128();\n            const sectionEnd = offset + sectionSize;\n            if (sectionId == 5) {\n                // Memory section\n                // Make sure it's empty and only imported memory is used\n                parts.push(Buffer.from([5, 1, 0]));\n            }\n            else if (sectionId == 2) {\n                // Import section\n                const sectionParts = [];\n                const numImports = decodeLEB128();\n                for (let i = 0; i < numImports; i++) {\n                    const importStart = offset;\n                    decodeString();\n                    decodeString();\n                    const kind = input.readUInt8(offset);\n                    offset++;\n                    let skipImport = false;\n                    switch (kind) {\n                        case 0:\n                            // Function import\n                            decodeLEB128(); // index\n                            break;\n                        case 1:\n                            // Table import\n                            offset++; // type\n                            decodeLimits();\n                            break;\n                        case 2:\n                            // Memory import\n                            decodeLimits();\n                            // NOTE: existing memory import is removed (so no need to add it to sectionParts)\n                            skipImport = true;\n                            break;\n                        case 3:\n                            // Global import\n                            offset++; // type\n                            offset++; // mutability\n                            break;\n                        default:\n                            throw new Error('Invalid import kind: ' + kind);\n                    }\n                    if (!skipImport) {\n                        sectionParts.push(input.subarray(importStart, offset));\n                    }\n                }\n                const importMemory = Buffer.concat([\n                    encodeString('env'),\n                    encodeString('memory'),\n                    Buffer.from([2]),\n                    Buffer.from([0]),\n                    encodeLEB128(1),\n                ]);\n                sectionParts.push(importMemory);\n                const sectionData = Buffer.concat([\n                    encodeLEB128(sectionParts.length),\n                    ...sectionParts,\n                ]);\n                parts.push(Buffer.concat([\n                    Buffer.from([2]),\n                    encodeLEB128(sectionData.length),\n                    sectionData\n                ]));\n            }\n            else if (sectionId == 7) {\n                // Export section\n                const sectionParts = [];\n                const numExports = decodeLEB128();\n                for (let i = 0; i < numExports; i++) {\n                    const exportStart = offset;\n                    decodeString();\n                    const kind = input.readUInt8(offset);\n                    offset++;\n                    decodeLEB128();\n                    if (kind !== 2) {\n                        // Pass through all exports except memory\n                        sectionParts.push(input.subarray(exportStart, offset));\n                    }\n                }\n                const sectionData = Buffer.concat([\n                    encodeLEB128(sectionParts.length),\n                    ...sectionParts,\n                ]);\n                parts.push(Buffer.concat([\n                    Buffer.from([7]),\n                    encodeLEB128(sectionData.length),\n                    sectionData\n                ]));\n            }\n            else {\n                parts.push(input.subarray(sectionStart, sectionEnd));\n            }\n            offset = sectionEnd;\n        } while (offset < input.length);\n        return Buffer.concat(parts);\n    }\n    // Host functions\n    getRegisterLength(registerId) {\n        return BigInt(this.registers[registerId.toString()] ? this.registers[registerId.toString()].length : Number.MAX_SAFE_INTEGER);\n    }\n    readFromRegister(registerId, ptr) {\n        const mem = new Uint8Array(this.memory.buffer);\n        mem.set(this.registers[registerId.toString()] || Buffer.from([]), Number(ptr));\n    }\n    getCurrentAccountId(registerId) {\n        this.registers[registerId.toString()] = Buffer.from(this.context.contractId);\n    }\n    inputMethodArgs(registerId) {\n        this.registers[registerId.toString()] = Buffer.from(this.context.methodArgs);\n    }\n    getBlockHeight() {\n        return BigInt(this.context.blockHeight);\n    }\n    getBlockTimestamp() {\n        return BigInt(this.context.blockTimestamp);\n    }\n    sha256(valueLen, valuePtr, registerId) {\n        const value = new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen));\n        const hash = (0, crypto_1.createHash)('sha256');\n        hash.update(value);\n        this.registers[registerId.toString()] = hash.digest();\n    }\n    returnValue(valueLen, valuePtr) {\n        this.result = Buffer.from(new Uint8Array(this.memory.buffer, Number(valuePtr), Number(valueLen)));\n    }\n    panic(message) {\n        throw new Error('panic: ' + message);\n    }\n    abort(msg_ptr, filename_ptr, line, col) {\n        const msg = this.readUTF16CStr(msg_ptr);\n        const filename = this.readUTF16CStr(filename_ptr);\n        const message = `${msg} ${filename}:${line}:${col}`;\n        if (!msg || !filename) {\n            throw new Error('abort: ' + 'String encoding is bad UTF-16 sequence.');\n        }\n        throw new Error('abort: ' + message);\n    }\n    appendToLog(len, ptr) {\n        this.logs.push(this.readUTF8CStr(len, ptr));\n    }\n    readStorage(key_len, key_ptr, register_id) {\n        const result = this.storageRead(key_len, key_ptr);\n        if (result == null) {\n            return BigInt(0);\n        }\n        this.registers[register_id] = result;\n        return BigInt(1);\n    }\n    hasStorageKey(key_len, key_ptr) {\n        const result = this.storageRead(key_len, key_ptr);\n        if (result == null) {\n            return BigInt(0);\n        }\n        return BigInt(1);\n    }\n    getHostImports() {\n        return {\n            register_len: this.getRegisterLength.bind(this),\n            read_register: this.readFromRegister.bind(this),\n            current_account_id: this.getCurrentAccountId.bind(this),\n            input: this.inputMethodArgs.bind(this),\n            block_index: this.getBlockHeight.bind(this),\n            block_timestamp: this.getBlockTimestamp.bind(this),\n            sha256: this.sha256.bind(this),\n            value_return: this.returnValue.bind(this),\n            abort: this.abort.bind(this),\n            log_utf8: this.appendToLog.bind(this),\n            log_utf16: this.appendToLog.bind(this),\n            storage_read: this.readStorage.bind(this),\n            storage_has_key: this.hasStorageKey.bind(this),\n            panic: () => this.panic('explicit guest panic'),\n            panic_utf8: (len, ptr) => this.panic(this.readUTF8CStr(len, ptr)),\n            // Not implemented\n            epoch_height: notImplemented('epoch_height'),\n            storage_usage: notImplemented('storage_usage'),\n            account_balance: notImplemented('account_balance'),\n            account_locked_balance: notImplemented('account_locked_balance'),\n            random_seed: notImplemented('random_seed'),\n            ripemd160: notImplemented('ripemd160'),\n            keccak256: notImplemented('keccak256'),\n            keccak512: notImplemented('keccak512'),\n            ecrecover: notImplemented('ecrecover'),\n            validator_stake: notImplemented('validator_stake'),\n            validator_total_stake: notImplemented('validator_total_stake'),\n            // Prohibited\n            write_register: prohibitedInView('write_register'),\n            signer_account_id: prohibitedInView('signer_account_id'),\n            signer_account_pk: prohibitedInView('signer_account_pk'),\n            predecessor_account_id: prohibitedInView('predecessor_account_id'),\n            attached_deposit: prohibitedInView('attached_deposit'),\n            prepaid_gas: prohibitedInView('prepaid_gas'),\n            used_gas: prohibitedInView('used_gas'),\n            promise_create: prohibitedInView('promise_create'),\n            promise_then: prohibitedInView('promise_then'),\n            promise_and: prohibitedInView('promise_and'),\n            promise_batch_create: prohibitedInView('promise_batch_create'),\n            promise_batch_then: prohibitedInView('promise_batch_then'),\n            promise_batch_action_create_account: prohibitedInView('promise_batch_action_create_account'),\n            promise_batch_action_deploy_contract: prohibitedInView('promise_batch_action_deploy_contract'),\n            promise_batch_action_function_call: prohibitedInView('promise_batch_action_function_call'),\n            promise_batch_action_function_call_weight: prohibitedInView('promise_batch_action_function_call_weight'),\n            promise_batch_action_transfer: prohibitedInView('promise_batch_action_transfer'),\n            promise_batch_action_stake: prohibitedInView('promise_batch_action_stake'),\n            promise_batch_action_add_key_with_full_access: prohibitedInView('promise_batch_action_add_key_with_full_access'),\n            promise_batch_action_add_key_with_function_call: prohibitedInView('promise_batch_action_add_key_with_function_call'),\n            promise_batch_action_delete_key: prohibitedInView('promise_batch_action_delete_key'),\n            promise_batch_action_delete_account: prohibitedInView('promise_batch_action_delete_account'),\n            promise_results_count: prohibitedInView('promise_results_count'),\n            promise_result: prohibitedInView('promise_result'),\n            promise_return: prohibitedInView('promise_return'),\n            storage_write: prohibitedInView('storage_write'),\n            storage_remove: prohibitedInView('storage_remove'),\n        };\n    }\n    execute(methodName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const module = yield WebAssembly.compile(this.wasm);\n            const instance = yield WebAssembly.instantiate(module, { env: Object.assign(Object.assign({}, this.getHostImports()), { memory: this.memory }) });\n            const callMethod = instance.exports[methodName];\n            if (callMethod == undefined) {\n                throw new Error(`Contract method '${methodName}' does not exists in contract ${this.context.contractId} for block id ${this.context.blockHeight}`);\n            }\n            callMethod();\n            return {\n                result: this.result,\n                logs: this.logs\n            };\n        });\n    }\n}\nexports.Runtime = Runtime;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9sb2NhbC12aWV3LWV4ZWN1dGlvbi9ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQSwrQ0FBK0MsOEJBQThCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUssRUFBRSxTQUFTLEdBQUcsS0FBSyxHQUFHLElBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsbUNBQW1DLDRCQUE0QixxQkFBcUIsR0FBRztBQUM1SjtBQUNBO0FBQ0Esb0RBQW9ELFdBQVcsZ0NBQWdDLHlCQUF5QixlQUFlLHlCQUF5QjtBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK2FjY291bnRzQDEuMC40L25vZGVfbW9kdWxlcy9AbmVhci1qcy9hY2NvdW50cy9saWIvbG9jYWwtdmlldy1leGVjdXRpb24vcnVudGltZS5qcz9kNzVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJ1bnRpbWUgPSB2b2lkIDA7XG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG5jb25zdCBub3RJbXBsZW1lbnRlZCA9IChuYW1lKSA9PiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2Qgbm90IGltcGxlbWVudGVkOiAnICsgbmFtZSk7XG59O1xuY29uc3QgcHJvaGliaXRlZEluVmlldyA9IChuYW1lKSA9PiAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2Qgbm90IGF2YWlsYWJsZSBmb3IgdmlldyBjYWxsczogJyArIG5hbWUpO1xufTtcbmNsYXNzIFJ1bnRpbWUge1xuICAgIGNvbnN0cnVjdG9yKF9hKSB7XG4gICAgICAgIHZhciB7IGNvbnRyYWN0Q29kZSB9ID0gX2EsIGNvbnRleHQgPSBfX3Jlc3QoX2EsIFtcImNvbnRyYWN0Q29kZVwiXSk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMud2FzbSA9IHRoaXMucHJlcGFyZVdBU00oQnVmZmVyLmZyb20oY29udHJhY3RDb2RlLCAnYmFzZTY0JykpO1xuICAgICAgICB0aGlzLm1lbW9yeSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiAxMDI0LCBtYXhpbXVtOiAyMDQ4IH0pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVycyA9IHt9O1xuICAgICAgICB0aGlzLmxvZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBCdWZmZXIuZnJvbShbXSk7XG4gICAgfVxuICAgIHJlYWRVVEYxNkNTdHIocHRyKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDE2QXJyYXkodGhpcy5tZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgbGV0IGtleSA9IE51bWJlcihwdHIpIC8gMjtcbiAgICAgICAgd2hpbGUgKG1lbVtrZXldICE9IDApIHtcbiAgICAgICAgICAgIGFyci5wdXNoKG1lbVtrZXldKTtcbiAgICAgICAgICAgIGtleSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShVaW50MTZBcnJheS5mcm9tKGFycikuYnVmZmVyKS50b1N0cmluZygndWNzMicpO1xuICAgIH1cbiAgICByZWFkVVRGOENTdHIobGVuLCBwdHIpIHtcbiAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgIGNvbnN0IG1lbSA9IG5ldyBVaW50OEFycmF5KHRoaXMubWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgIGxldCBrZXkgPSBOdW1iZXIocHRyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gJiYgbWVtW2tleV0gIT0gMDsgaSsrKSB7XG4gICAgICAgICAgICBhcnIucHVzaChtZW1ba2V5XSk7XG4gICAgICAgICAgICBrZXkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyKS50b1N0cmluZygndXRmOCcpO1xuICAgIH1cbiAgICBzdG9yYWdlUmVhZChrZXlMZW4sIGtleVB0cikge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5ID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkodGhpcy5tZW1vcnkuYnVmZmVyLCBOdW1iZXIoa2V5UHRyKSwgTnVtYmVyKGtleUxlbikpKTtcbiAgICAgICAgY29uc3Qgc3RhdGVWYWwgPSB0aGlzLmNvbnRleHQuY29udHJhY3RTdGF0ZS5maWx0ZXIoKG9iaikgPT4gQnVmZmVyLmNvbXBhcmUob2JqLmtleSwgc3RvcmFnZUtleSkgPT09IDApLm1hcCgob2JqKSA9PiBvYmoudmFsdWUpO1xuICAgICAgICBpZiAoc3RhdGVWYWwubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBzdGF0ZVZhbC5sZW5ndGggPiAxID8gc3RhdGVWYWwgOiBzdGF0ZVZhbFswXTtcbiAgICB9XG4gICAgcHJlcGFyZVdBU00oaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgY29uc3QgbWFnaWMgPSBpbnB1dC5zdWJhcnJheSgwLCA0KTtcbiAgICAgICAgaWYgKG1hZ2ljLnRvU3RyaW5nKCd1dGY4JykgIT09ICdcXDBhc20nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFnaWMgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGlucHV0LnJlYWRVSW50MzJMRSg0KTtcbiAgICAgICAgaWYgKHZlcnNpb24gIT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gODtcbiAgICAgICAgcGFydHMucHVzaChpbnB1dC5zdWJhcnJheSgwLCBvZmZzZXQpKTtcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlTEVCMTI4KCkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgICAgICAgICBsZXQgc2hpZnQgPSAwO1xuICAgICAgICAgICAgbGV0IGJ5dGU7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgYnl0ZSA9IGlucHV0W29mZnNldCsrXTtcbiAgICAgICAgICAgICAgICByZXN1bHQgfD0gKGJ5dGUgJiAweDdmKSA8PCBzaGlmdDtcbiAgICAgICAgICAgICAgICBzaGlmdCArPSA3O1xuICAgICAgICAgICAgfSB3aGlsZSAoYnl0ZSAmIDB4ODApO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWNvZGVMaW1pdHMoKSB7XG4gICAgICAgICAgICBjb25zdCBmbGFncyA9IGlucHV0W29mZnNldCsrXTtcbiAgICAgICAgICAgIGNvbnN0IGhhc01heCA9IGZsYWdzICYgMHgxO1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbCA9IGRlY29kZUxFQjEyOCgpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gaGFzTWF4ID8gZGVjb2RlTEVCMTI4KCkgOiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5pdGlhbCwgbWF4IH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlU3RyaW5nKCkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZGVjb2RlTEVCMTI4KCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnB1dC5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbmd0aCk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50b1N0cmluZygndXRmOCcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVuY29kZUxFQjEyOCh2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGJ5dGUgPSB2YWx1ZSAmIDB4N2Y7XG4gICAgICAgICAgICAgICAgdmFsdWUgPj49IDc7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGUgfD0gMHg4MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYnl0ZSk7XG4gICAgICAgICAgICB9IHdoaWxlICh2YWx1ZSAhPT0gMCk7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlbmNvZGVTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpO1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2VuY29kZUxFQjEyOChyZXN1bHQubGVuZ3RoKSwgcmVzdWx0XSk7XG4gICAgICAgIH1cbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvblN0YXJ0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgY29uc3Qgc2VjdGlvbklkID0gaW5wdXQucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25TaXplID0gZGVjb2RlTEVCMTI4KCk7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uRW5kID0gb2Zmc2V0ICsgc2VjdGlvblNpemU7XG4gICAgICAgICAgICBpZiAoc2VjdGlvbklkID09IDUpIHtcbiAgICAgICAgICAgICAgICAvLyBNZW1vcnkgc2VjdGlvblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIGVtcHR5IGFuZCBvbmx5IGltcG9ydGVkIG1lbW9yeSBpcyB1c2VkXG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChCdWZmZXIuZnJvbShbNSwgMSwgMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlY3Rpb25JZCA9PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wb3J0IHNlY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1JbXBvcnRzID0gZGVjb2RlTEVCMTI4KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1JbXBvcnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1wb3J0U3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2luZCA9IGlucHV0LnJlYWRVSW50OChvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNraXBJbXBvcnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRnVuY3Rpb24gaW1wb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlTEVCMTI4KCk7IC8vIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGFibGUgaW1wb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7IC8vIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVMaW1pdHMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNZW1vcnkgaW1wb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjb2RlTGltaXRzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTk9URTogZXhpc3RpbmcgbWVtb3J5IGltcG9ydCBpcyByZW1vdmVkIChzbyBubyBuZWVkIHRvIGFkZCBpdCB0byBzZWN0aW9uUGFydHMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEltcG9ydCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2xvYmFsIGltcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCsrOyAvLyB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7IC8vIG11dGFiaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGltcG9ydCBraW5kOiAnICsga2luZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwSW1wb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uUGFydHMucHVzaChpbnB1dC5zdWJhcnJheShpbXBvcnRTdGFydCwgb2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaW1wb3J0TWVtb3J5ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVN0cmluZygnZW52JyksXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZVN0cmluZygnbWVtb3J5JyksXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFsyXSksXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFswXSksXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZUxFQjEyOCgxKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBzZWN0aW9uUGFydHMucHVzaChpbXBvcnRNZW1vcnkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3Rpb25EYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZUxFQjEyOChzZWN0aW9uUGFydHMubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc2VjdGlvblBhcnRzLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKFsyXSksXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZUxFQjEyOChzZWN0aW9uRGF0YS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRGF0YVxuICAgICAgICAgICAgICAgIF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNlY3Rpb25JZCA9PSA3KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwb3J0IHNlY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1FeHBvcnRzID0gZGVjb2RlTEVCMTI4KCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FeHBvcnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwb3J0U3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gaW5wdXQucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVMRUIxMjgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCBhbGwgZXhwb3J0cyBleGNlcHQgbWVtb3J5XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uUGFydHMucHVzaChpbnB1dC5zdWJhcnJheShleHBvcnRTdGFydCwgb2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VjdGlvbkRhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlTEVCMTI4KHNlY3Rpb25QYXJ0cy5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAuLi5zZWN0aW9uUGFydHMsXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20oWzddKSxcbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlTEVCMTI4KHNlY3Rpb25EYXRhLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25EYXRhXG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChpbnB1dC5zdWJhcnJheShzZWN0aW9uU3RhcnQsIHNlY3Rpb25FbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHNlY3Rpb25FbmQ7XG4gICAgICAgIH0gd2hpbGUgKG9mZnNldCA8IGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgLy8gSG9zdCBmdW5jdGlvbnNcbiAgICBnZXRSZWdpc3Rlckxlbmd0aChyZWdpc3RlcklkKSB7XG4gICAgICAgIHJldHVybiBCaWdJbnQodGhpcy5yZWdpc3RlcnNbcmVnaXN0ZXJJZC50b1N0cmluZygpXSA/IHRoaXMucmVnaXN0ZXJzW3JlZ2lzdGVySWQudG9TdHJpbmcoKV0ubGVuZ3RoIDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIH1cbiAgICByZWFkRnJvbVJlZ2lzdGVyKHJlZ2lzdGVySWQsIHB0cikge1xuICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheSh0aGlzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICBtZW0uc2V0KHRoaXMucmVnaXN0ZXJzW3JlZ2lzdGVySWQudG9TdHJpbmcoKV0gfHwgQnVmZmVyLmZyb20oW10pLCBOdW1iZXIocHRyKSk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRBY2NvdW50SWQocmVnaXN0ZXJJZCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyc1tyZWdpc3RlcklkLnRvU3RyaW5nKCldID0gQnVmZmVyLmZyb20odGhpcy5jb250ZXh0LmNvbnRyYWN0SWQpO1xuICAgIH1cbiAgICBpbnB1dE1ldGhvZEFyZ3MocmVnaXN0ZXJJZCkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyc1tyZWdpc3RlcklkLnRvU3RyaW5nKCldID0gQnVmZmVyLmZyb20odGhpcy5jb250ZXh0Lm1ldGhvZEFyZ3MpO1xuICAgIH1cbiAgICBnZXRCbG9ja0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLmNvbnRleHQuYmxvY2tIZWlnaHQpO1xuICAgIH1cbiAgICBnZXRCbG9ja1RpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ0ludCh0aGlzLmNvbnRleHQuYmxvY2tUaW1lc3RhbXApO1xuICAgIH1cbiAgICBzaGEyNTYodmFsdWVMZW4sIHZhbHVlUHRyLCByZWdpc3RlcklkKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5tZW1vcnkuYnVmZmVyLCBOdW1iZXIodmFsdWVQdHIpLCBOdW1iZXIodmFsdWVMZW4pKTtcbiAgICAgICAgY29uc3QgaGFzaCA9ICgwLCBjcnlwdG9fMS5jcmVhdGVIYXNoKSgnc2hhMjU2Jyk7XG4gICAgICAgIGhhc2gudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcnNbcmVnaXN0ZXJJZC50b1N0cmluZygpXSA9IGhhc2guZGlnZXN0KCk7XG4gICAgfVxuICAgIHJldHVyblZhbHVlKHZhbHVlTGVuLCB2YWx1ZVB0cikge1xuICAgICAgICB0aGlzLnJlc3VsdCA9IEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHRoaXMubWVtb3J5LmJ1ZmZlciwgTnVtYmVyKHZhbHVlUHRyKSwgTnVtYmVyKHZhbHVlTGVuKSkpO1xuICAgIH1cbiAgICBwYW5pYyhtZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFuaWM6ICcgKyBtZXNzYWdlKTtcbiAgICB9XG4gICAgYWJvcnQobXNnX3B0ciwgZmlsZW5hbWVfcHRyLCBsaW5lLCBjb2wpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdGhpcy5yZWFkVVRGMTZDU3RyKG1zZ19wdHIpO1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHRoaXMucmVhZFVURjE2Q1N0cihmaWxlbmFtZV9wdHIpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7bXNnfSAke2ZpbGVuYW1lfToke2xpbmV9OiR7Y29sfWA7XG4gICAgICAgIGlmICghbXNnIHx8ICFmaWxlbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYm9ydDogJyArICdTdHJpbmcgZW5jb2RpbmcgaXMgYmFkIFVURi0xNiBzZXF1ZW5jZS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fib3J0OiAnICsgbWVzc2FnZSk7XG4gICAgfVxuICAgIGFwcGVuZFRvTG9nKGxlbiwgcHRyKSB7XG4gICAgICAgIHRoaXMubG9ncy5wdXNoKHRoaXMucmVhZFVURjhDU3RyKGxlbiwgcHRyKSk7XG4gICAgfVxuICAgIHJlYWRTdG9yYWdlKGtleV9sZW4sIGtleV9wdHIsIHJlZ2lzdGVyX2lkKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc3RvcmFnZVJlYWQoa2V5X2xlbiwga2V5X3B0cik7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyc1tyZWdpc3Rlcl9pZF0gPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiBCaWdJbnQoMSk7XG4gICAgfVxuICAgIGhhc1N0b3JhZ2VLZXkoa2V5X2xlbiwga2V5X3B0cikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnN0b3JhZ2VSZWFkKGtleV9sZW4sIGtleV9wdHIpO1xuICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludCgxKTtcbiAgICB9XG4gICAgZ2V0SG9zdEltcG9ydHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWdpc3Rlcl9sZW46IHRoaXMuZ2V0UmVnaXN0ZXJMZW5ndGguYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlYWRfcmVnaXN0ZXI6IHRoaXMucmVhZEZyb21SZWdpc3Rlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY3VycmVudF9hY2NvdW50X2lkOiB0aGlzLmdldEN1cnJlbnRBY2NvdW50SWQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0TWV0aG9kQXJncy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgYmxvY2tfaW5kZXg6IHRoaXMuZ2V0QmxvY2tIZWlnaHQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGJsb2NrX3RpbWVzdGFtcDogdGhpcy5nZXRCbG9ja1RpbWVzdGFtcC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc2hhMjU2OiB0aGlzLnNoYTI1Ni5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgdmFsdWVfcmV0dXJuOiB0aGlzLnJldHVyblZhbHVlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBhYm9ydDogdGhpcy5hYm9ydC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgbG9nX3V0Zjg6IHRoaXMuYXBwZW5kVG9Mb2cuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGxvZ191dGYxNjogdGhpcy5hcHBlbmRUb0xvZy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc3RvcmFnZV9yZWFkOiB0aGlzLnJlYWRTdG9yYWdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzdG9yYWdlX2hhc19rZXk6IHRoaXMuaGFzU3RvcmFnZUtleS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgcGFuaWM6ICgpID0+IHRoaXMucGFuaWMoJ2V4cGxpY2l0IGd1ZXN0IHBhbmljJyksXG4gICAgICAgICAgICBwYW5pY191dGY4OiAobGVuLCBwdHIpID0+IHRoaXMucGFuaWModGhpcy5yZWFkVVRGOENTdHIobGVuLCBwdHIpKSxcbiAgICAgICAgICAgIC8vIE5vdCBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgZXBvY2hfaGVpZ2h0OiBub3RJbXBsZW1lbnRlZCgnZXBvY2hfaGVpZ2h0JyksXG4gICAgICAgICAgICBzdG9yYWdlX3VzYWdlOiBub3RJbXBsZW1lbnRlZCgnc3RvcmFnZV91c2FnZScpLFxuICAgICAgICAgICAgYWNjb3VudF9iYWxhbmNlOiBub3RJbXBsZW1lbnRlZCgnYWNjb3VudF9iYWxhbmNlJyksXG4gICAgICAgICAgICBhY2NvdW50X2xvY2tlZF9iYWxhbmNlOiBub3RJbXBsZW1lbnRlZCgnYWNjb3VudF9sb2NrZWRfYmFsYW5jZScpLFxuICAgICAgICAgICAgcmFuZG9tX3NlZWQ6IG5vdEltcGxlbWVudGVkKCdyYW5kb21fc2VlZCcpLFxuICAgICAgICAgICAgcmlwZW1kMTYwOiBub3RJbXBsZW1lbnRlZCgncmlwZW1kMTYwJyksXG4gICAgICAgICAgICBrZWNjYWsyNTY6IG5vdEltcGxlbWVudGVkKCdrZWNjYWsyNTYnKSxcbiAgICAgICAgICAgIGtlY2NhazUxMjogbm90SW1wbGVtZW50ZWQoJ2tlY2NhazUxMicpLFxuICAgICAgICAgICAgZWNyZWNvdmVyOiBub3RJbXBsZW1lbnRlZCgnZWNyZWNvdmVyJyksXG4gICAgICAgICAgICB2YWxpZGF0b3Jfc3Rha2U6IG5vdEltcGxlbWVudGVkKCd2YWxpZGF0b3Jfc3Rha2UnKSxcbiAgICAgICAgICAgIHZhbGlkYXRvcl90b3RhbF9zdGFrZTogbm90SW1wbGVtZW50ZWQoJ3ZhbGlkYXRvcl90b3RhbF9zdGFrZScpLFxuICAgICAgICAgICAgLy8gUHJvaGliaXRlZFxuICAgICAgICAgICAgd3JpdGVfcmVnaXN0ZXI6IHByb2hpYml0ZWRJblZpZXcoJ3dyaXRlX3JlZ2lzdGVyJyksXG4gICAgICAgICAgICBzaWduZXJfYWNjb3VudF9pZDogcHJvaGliaXRlZEluVmlldygnc2lnbmVyX2FjY291bnRfaWQnKSxcbiAgICAgICAgICAgIHNpZ25lcl9hY2NvdW50X3BrOiBwcm9oaWJpdGVkSW5WaWV3KCdzaWduZXJfYWNjb3VudF9waycpLFxuICAgICAgICAgICAgcHJlZGVjZXNzb3JfYWNjb3VudF9pZDogcHJvaGliaXRlZEluVmlldygncHJlZGVjZXNzb3JfYWNjb3VudF9pZCcpLFxuICAgICAgICAgICAgYXR0YWNoZWRfZGVwb3NpdDogcHJvaGliaXRlZEluVmlldygnYXR0YWNoZWRfZGVwb3NpdCcpLFxuICAgICAgICAgICAgcHJlcGFpZF9nYXM6IHByb2hpYml0ZWRJblZpZXcoJ3ByZXBhaWRfZ2FzJyksXG4gICAgICAgICAgICB1c2VkX2dhczogcHJvaGliaXRlZEluVmlldygndXNlZF9nYXMnKSxcbiAgICAgICAgICAgIHByb21pc2VfY3JlYXRlOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2NyZWF0ZScpLFxuICAgICAgICAgICAgcHJvbWlzZV90aGVuOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX3RoZW4nKSxcbiAgICAgICAgICAgIHByb21pc2VfYW5kOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2FuZCcpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9jcmVhdGU6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfY3JlYXRlJyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX3RoZW46IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfdGhlbicpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fY3JlYXRlX2FjY291bnQ6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfYWN0aW9uX2NyZWF0ZV9hY2NvdW50JyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl9kZXBsb3lfY29udHJhY3Q6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfYWN0aW9uX2RlcGxveV9jb250cmFjdCcpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fZnVuY3Rpb25fY2FsbDogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9hY3Rpb25fZnVuY3Rpb25fY2FsbCcpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fZnVuY3Rpb25fY2FsbF93ZWlnaHQ6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfYWN0aW9uX2Z1bmN0aW9uX2NhbGxfd2VpZ2h0JyksXG4gICAgICAgICAgICBwcm9taXNlX2JhdGNoX2FjdGlvbl90cmFuc2ZlcjogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9hY3Rpb25fdHJhbnNmZXInKSxcbiAgICAgICAgICAgIHByb21pc2VfYmF0Y2hfYWN0aW9uX3N0YWtlOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2JhdGNoX2FjdGlvbl9zdGFrZScpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fYWRkX2tleV93aXRoX2Z1bGxfYWNjZXNzOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2JhdGNoX2FjdGlvbl9hZGRfa2V5X3dpdGhfZnVsbF9hY2Nlc3MnKSxcbiAgICAgICAgICAgIHByb21pc2VfYmF0Y2hfYWN0aW9uX2FkZF9rZXlfd2l0aF9mdW5jdGlvbl9jYWxsOiBwcm9oaWJpdGVkSW5WaWV3KCdwcm9taXNlX2JhdGNoX2FjdGlvbl9hZGRfa2V5X3dpdGhfZnVuY3Rpb25fY2FsbCcpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fZGVsZXRlX2tleTogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9iYXRjaF9hY3Rpb25fZGVsZXRlX2tleScpLFxuICAgICAgICAgICAgcHJvbWlzZV9iYXRjaF9hY3Rpb25fZGVsZXRlX2FjY291bnQ6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfYmF0Y2hfYWN0aW9uX2RlbGV0ZV9hY2NvdW50JyksXG4gICAgICAgICAgICBwcm9taXNlX3Jlc3VsdHNfY291bnQ6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfcmVzdWx0c19jb3VudCcpLFxuICAgICAgICAgICAgcHJvbWlzZV9yZXN1bHQ6IHByb2hpYml0ZWRJblZpZXcoJ3Byb21pc2VfcmVzdWx0JyksXG4gICAgICAgICAgICBwcm9taXNlX3JldHVybjogcHJvaGliaXRlZEluVmlldygncHJvbWlzZV9yZXR1cm4nKSxcbiAgICAgICAgICAgIHN0b3JhZ2Vfd3JpdGU6IHByb2hpYml0ZWRJblZpZXcoJ3N0b3JhZ2Vfd3JpdGUnKSxcbiAgICAgICAgICAgIHN0b3JhZ2VfcmVtb3ZlOiBwcm9oaWJpdGVkSW5WaWV3KCdzdG9yYWdlX3JlbW92ZScpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBleGVjdXRlKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IHlpZWxkIFdlYkFzc2VtYmx5LmNvbXBpbGUodGhpcy53YXNtKTtcbiAgICAgICAgICAgIGNvbnN0IGluc3RhbmNlID0geWllbGQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCB7IGVudjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdldEhvc3RJbXBvcnRzKCkpLCB7IG1lbW9yeTogdGhpcy5tZW1vcnkgfSkgfSk7XG4gICAgICAgICAgICBjb25zdCBjYWxsTWV0aG9kID0gaW5zdGFuY2UuZXhwb3J0c1ttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIGlmIChjYWxsTWV0aG9kID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgbWV0aG9kICcke21ldGhvZE5hbWV9JyBkb2VzIG5vdCBleGlzdHMgaW4gY29udHJhY3QgJHt0aGlzLmNvbnRleHQuY29udHJhY3RJZH0gZm9yIGJsb2NrIGlkICR7dGhpcy5jb250ZXh0LmJsb2NrSGVpZ2h0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbE1ldGhvZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHRoaXMucmVzdWx0LFxuICAgICAgICAgICAgICAgIGxvZ3M6IHRoaXMubG9nc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5SdW50aW1lID0gUnVudGltZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/runtime.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/storage.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/storage.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Storage = void 0;\nconst lru_map_1 = __webpack_require__(/*! lru_map */ \"(ssr)/./node_modules/.pnpm/lru_map@0.4.1/node_modules/lru_map/dist/lru.js\");\nclass Storage {\n    constructor(options = { max: Storage.MAX_ELEMENTS }) {\n        this.cache = new lru_map_1.LRUMap(options.max);\n        this.blockHeights = new Map();\n    }\n    load(blockRef) {\n        const noBlockId = !('blockId' in blockRef);\n        if (noBlockId)\n            return undefined;\n        let blockId = blockRef.blockId;\n        // block hash is passed, so get its corresponding block height\n        if (blockId.toString().length == 44) {\n            blockId = this.blockHeights.get(blockId.toString());\n        }\n        // get cached values for the given block height\n        return this.cache.get(blockId);\n    }\n    save(blockHash, { blockHeight, blockTimestamp, contractCode, contractState }) {\n        this.blockHeights.set(blockHash, blockHeight);\n        this.cache.set(blockHeight, { blockHeight, blockTimestamp, contractCode, contractState });\n    }\n}\nexports.Storage = Storage;\nStorage.MAX_ELEMENTS = 100;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9sb2NhbC12aWV3LWV4ZWN1dGlvbi9zdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixrQkFBa0IsbUJBQU8sQ0FBQywwRkFBUztBQUNuQztBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDBEQUEwRDtBQUNoRjtBQUNBLHNDQUFzQywwREFBMEQ7QUFDaEc7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi9sb2NhbC12aWV3LWV4ZWN1dGlvbi9zdG9yYWdlLmpzPzU4M2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0b3JhZ2UgPSB2b2lkIDA7XG5jb25zdCBscnVfbWFwXzEgPSByZXF1aXJlKFwibHJ1X21hcFwiKTtcbmNsYXNzIFN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7IG1heDogU3RvcmFnZS5NQVhfRUxFTUVOVFMgfSkge1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IGxydV9tYXBfMS5MUlVNYXAob3B0aW9ucy5tYXgpO1xuICAgICAgICB0aGlzLmJsb2NrSGVpZ2h0cyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgbG9hZChibG9ja1JlZikge1xuICAgICAgICBjb25zdCBub0Jsb2NrSWQgPSAhKCdibG9ja0lkJyBpbiBibG9ja1JlZik7XG4gICAgICAgIGlmIChub0Jsb2NrSWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgYmxvY2tJZCA9IGJsb2NrUmVmLmJsb2NrSWQ7XG4gICAgICAgIC8vIGJsb2NrIGhhc2ggaXMgcGFzc2VkLCBzbyBnZXQgaXRzIGNvcnJlc3BvbmRpbmcgYmxvY2sgaGVpZ2h0XG4gICAgICAgIGlmIChibG9ja0lkLnRvU3RyaW5nKCkubGVuZ3RoID09IDQ0KSB7XG4gICAgICAgICAgICBibG9ja0lkID0gdGhpcy5ibG9ja0hlaWdodHMuZ2V0KGJsb2NrSWQudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNhY2hlZCB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBibG9jayBoZWlnaHRcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGJsb2NrSWQpO1xuICAgIH1cbiAgICBzYXZlKGJsb2NrSGFzaCwgeyBibG9ja0hlaWdodCwgYmxvY2tUaW1lc3RhbXAsIGNvbnRyYWN0Q29kZSwgY29udHJhY3RTdGF0ZSB9KSB7XG4gICAgICAgIHRoaXMuYmxvY2tIZWlnaHRzLnNldChibG9ja0hhc2gsIGJsb2NrSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jYWNoZS5zZXQoYmxvY2tIZWlnaHQsIHsgYmxvY2tIZWlnaHQsIGJsb2NrVGltZXN0YW1wLCBjb250cmFjdENvZGUsIGNvbnRyYWN0U3RhdGUgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yYWdlID0gU3RvcmFnZTtcblN0b3JhZ2UuTUFYX0VMRU1FTlRTID0gMTAwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/local-view-execution/storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/types.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/types.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MultisigStateStatus = exports.MultisigDeleteRequestRejectionError = void 0;\nvar MultisigDeleteRequestRejectionError;\n(function (MultisigDeleteRequestRejectionError) {\n    MultisigDeleteRequestRejectionError[\"CANNOT_DESERIALIZE_STATE\"] = \"Cannot deserialize the contract state\";\n    MultisigDeleteRequestRejectionError[\"MULTISIG_NOT_INITIALIZED\"] = \"Smart contract panicked: Multisig contract should be initialized before usage\";\n    MultisigDeleteRequestRejectionError[\"NO_SUCH_REQUEST\"] = \"Smart contract panicked: panicked at 'No such request: either wrong number or already confirmed'\";\n    MultisigDeleteRequestRejectionError[\"REQUEST_COOLDOWN_ERROR\"] = \"Request cannot be deleted immediately after creation.\";\n    MultisigDeleteRequestRejectionError[\"METHOD_NOT_FOUND\"] = \"Contract method is not found\";\n})(MultisigDeleteRequestRejectionError = exports.MultisigDeleteRequestRejectionError || (exports.MultisigDeleteRequestRejectionError = {}));\nvar MultisigStateStatus;\n(function (MultisigStateStatus) {\n    MultisigStateStatus[MultisigStateStatus[\"INVALID_STATE\"] = 0] = \"INVALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"STATE_NOT_INITIALIZED\"] = 1] = \"STATE_NOT_INITIALIZED\";\n    MultisigStateStatus[MultisigStateStatus[\"VALID_STATE\"] = 2] = \"VALID_STATE\";\n    MultisigStateStatus[MultisigStateStatus[\"UNKNOWN_STATE\"] = 3] = \"UNKNOWN_STATE\";\n})(MultisigStateStatus = exports.MultisigStateStatus || (exports.MultisigStateStatus = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQ0FBMkM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdGQUF3RiwyQ0FBMkMsS0FBSztBQUN6STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdEQUF3RCwyQkFBMkIsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlbGxvLW5lYXIvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrYWNjb3VudHNAMS4wLjQvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL2FjY291bnRzL2xpYi90eXBlcy5qcz80YWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NdWx0aXNpZ1N0YXRlU3RhdHVzID0gZXhwb3J0cy5NdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvciA9IHZvaWQgMDtcbnZhciBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcjtcbihmdW5jdGlvbiAoTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IpIHtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIkNBTk5PVF9ERVNFUklBTElaRV9TVEFURVwiXSA9IFwiQ2Fubm90IGRlc2VyaWFsaXplIHRoZSBjb250cmFjdCBzdGF0ZVwiO1xuICAgIE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yW1wiTVVMVElTSUdfTk9UX0lOSVRJQUxJWkVEXCJdID0gXCJTbWFydCBjb250cmFjdCBwYW5pY2tlZDogTXVsdGlzaWcgY29udHJhY3Qgc2hvdWxkIGJlIGluaXRpYWxpemVkIGJlZm9yZSB1c2FnZVwiO1xuICAgIE11bHRpc2lnRGVsZXRlUmVxdWVzdFJlamVjdGlvbkVycm9yW1wiTk9fU1VDSF9SRVFVRVNUXCJdID0gXCJTbWFydCBjb250cmFjdCBwYW5pY2tlZDogcGFuaWNrZWQgYXQgJ05vIHN1Y2ggcmVxdWVzdDogZWl0aGVyIHdyb25nIG51bWJlciBvciBhbHJlYWR5IGNvbmZpcm1lZCdcIjtcbiAgICBNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvcltcIlJFUVVFU1RfQ09PTERPV05fRVJST1JcIl0gPSBcIlJlcXVlc3QgY2Fubm90IGJlIGRlbGV0ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgY3JlYXRpb24uXCI7XG4gICAgTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3JbXCJNRVRIT0RfTk9UX0ZPVU5EXCJdID0gXCJDb250cmFjdCBtZXRob2QgaXMgbm90IGZvdW5kXCI7XG59KShNdWx0aXNpZ0RlbGV0ZVJlcXVlc3RSZWplY3Rpb25FcnJvciA9IGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgfHwgKGV4cG9ydHMuTXVsdGlzaWdEZWxldGVSZXF1ZXN0UmVqZWN0aW9uRXJyb3IgPSB7fSkpO1xudmFyIE11bHRpc2lnU3RhdGVTdGF0dXM7XG4oZnVuY3Rpb24gKE11bHRpc2lnU3RhdGVTdGF0dXMpIHtcbiAgICBNdWx0aXNpZ1N0YXRlU3RhdHVzW011bHRpc2lnU3RhdGVTdGF0dXNbXCJJTlZBTElEX1NUQVRFXCJdID0gMF0gPSBcIklOVkFMSURfU1RBVEVcIjtcbiAgICBNdWx0aXNpZ1N0YXRlU3RhdHVzW011bHRpc2lnU3RhdGVTdGF0dXNbXCJTVEFURV9OT1RfSU5JVElBTElaRURcIl0gPSAxXSA9IFwiU1RBVEVfTk9UX0lOSVRJQUxJWkVEXCI7XG4gICAgTXVsdGlzaWdTdGF0ZVN0YXR1c1tNdWx0aXNpZ1N0YXRlU3RhdHVzW1wiVkFMSURfU1RBVEVcIl0gPSAyXSA9IFwiVkFMSURfU1RBVEVcIjtcbiAgICBNdWx0aXNpZ1N0YXRlU3RhdHVzW011bHRpc2lnU3RhdGVTdGF0dXNbXCJVTktOT1dOX1NUQVRFXCJdID0gM10gPSBcIlVOS05PV05fU1RBVEVcIjtcbn0pKE11bHRpc2lnU3RhdGVTdGF0dXMgPSBleHBvcnRzLk11bHRpc2lnU3RhdGVTdGF0dXMgfHwgKGV4cG9ydHMuTXVsdGlzaWdTdGF0ZVN0YXR1cyA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/types.js\n");

/***/ })

};
;