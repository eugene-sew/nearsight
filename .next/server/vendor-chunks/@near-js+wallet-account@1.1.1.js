"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@near-js+wallet-account@1.1.1";
exports.ids = ["vendor-chunks/@near-js+wallet-account@1.1.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletConnection = exports.ConnectedWalletAccount = exports.Near = void 0;\nvar near_1 = __webpack_require__(/*! ./near */ \"(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/near.js\");\nObject.defineProperty(exports, \"Near\", ({ enumerable: true, get: function () { return near_1.Near; } }));\nvar wallet_account_1 = __webpack_require__(/*! ./wallet_account */ \"(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/wallet_account.js\");\nObject.defineProperty(exports, \"ConnectedWalletAccount\", ({ enumerable: true, get: function () { return wallet_account_1.ConnectedWalletAccount; } }));\nObject.defineProperty(exports, \"WalletConnection\", ({ enumerable: true, get: function () { return wallet_account_1.WalletConnection; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrd2FsbGV0LWFjY291bnRAMS4xLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL3dhbGxldC1hY2NvdW50L2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyw4QkFBOEIsR0FBRyxZQUFZO0FBQ3hFLGFBQWEsbUJBQU8sQ0FBQyx5SEFBUTtBQUM3Qix3Q0FBdUMsRUFBRSxxQ0FBcUMsdUJBQXVCLEVBQUM7QUFDdEcsdUJBQXVCLG1CQUFPLENBQUMsNklBQWtCO0FBQ2pELDBEQUF5RCxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQztBQUNwSixvREFBbUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK3dhbGxldC1hY2NvdW50QDEuMS4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy93YWxsZXQtYWNjb3VudC9saWIvaW5kZXguanM/MDU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0Q29ubmVjdGlvbiA9IGV4cG9ydHMuQ29ubmVjdGVkV2FsbGV0QWNjb3VudCA9IGV4cG9ydHMuTmVhciA9IHZvaWQgMDtcbnZhciBuZWFyXzEgPSByZXF1aXJlKFwiLi9uZWFyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmVhclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmVhcl8xLk5lYXI7IH0gfSk7XG52YXIgd2FsbGV0X2FjY291bnRfMSA9IHJlcXVpcmUoXCIuL3dhbGxldF9hY2NvdW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGVkV2FsbGV0QWNjb3VudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2FsbGV0X2FjY291bnRfMS5Db25uZWN0ZWRXYWxsZXRBY2NvdW50OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiV2FsbGV0Q29ubmVjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gd2FsbGV0X2FjY291bnRfMS5XYWxsZXRDb25uZWN0aW9uOyB9IH0pO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/near.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/near.js ***!
  \***********************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Near = void 0;\n/**\n * This module contains the main class developers will use to interact with NEAR.\n * The {@link Near} class is used to interact with {@link \"@near-js/accounts\".account.Account | Account} through the {@link \"@near-js/providers\".json-rpc-provider.JsonRpcProvider | JsonRpcProvider}.\n * It is configured via the {@link NearConfig}.\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#account](https://docs.near.org/tools/near-api-js/quick-reference#account)\n *\n * @module near\n */\nconst accounts_1 = __webpack_require__(/*! @near-js/accounts */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\n/**\n * This is the main class developers should use to interact with NEAR.\n * @example\n * ```js\n * const near = new Near(config);\n * ```\n */\nclass Near {\n    constructor(config) {\n        var _a;\n        this.config = config;\n        this.connection = accounts_1.Connection.fromConfig({\n            networkId: config.networkId,\n            provider: { type: 'JsonRpcProvider', args: { url: config.nodeUrl, headers: config.headers } },\n            signer: config.signer || { type: 'InMemorySigner', keyStore: config.keyStore || ((_a = config.deps) === null || _a === void 0 ? void 0 : _a.keyStore) },\n            jsvmAccountId: config.jsvmAccountId || `jsvm.${config.networkId}`\n        });\n        if (config.masterAccount) {\n            // TODO: figure out better way of specifiying initial balance.\n            // Hardcoded number below must be enough to pay the gas cost to dev-deploy with near-shell for multiple times\n            const initialBalance = config.initialBalance ? new bn_js_1.default(config.initialBalance) : new bn_js_1.default('500000000000000000000000000');\n            this.accountCreator = new accounts_1.LocalAccountCreator(new accounts_1.Account(this.connection, config.masterAccount), initialBalance);\n        }\n        else if (config.helperUrl) {\n            this.accountCreator = new accounts_1.UrlAccountCreator(this.connection, config.helperUrl);\n        }\n        else {\n            this.accountCreator = null;\n        }\n    }\n    /**\n     * @param accountId near accountId used to interact with the network.\n     */\n    account(accountId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const account = new accounts_1.Account(this.connection, accountId);\n            return account;\n        });\n    }\n    /**\n     * Create an account using the {@link AccountCreator}. Either:\n     * * using a masterAccount with {@link LocalAccountCreator}\n     * * using the helperUrl with {@link UrlAccountCreator}\n     * @see {@link NearConfig#masterAccount} and {@link NearConfig#helperUrl}\n     *\n     * @param accountId\n     * @param publicKey\n     */\n    createAccount(accountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.accountCreator) {\n                throw new Error('Must specify account creator, either via masterAccount or helperUrl configuration settings.');\n            }\n            yield this.accountCreator.createAccount(accountId, publicKey);\n            return new accounts_1.Account(this.connection, accountId);\n        });\n    }\n}\nexports.Near = Near;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrd2FsbGV0LWFjY291bnRAMS4xLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL3dhbGxldC1hY2NvdW50L2xpYi9uZWFyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFlBQVk7QUFDWjtBQUNBO0FBQ0EsUUFBUSxZQUFZLGdDQUFnQyxxREFBcUQsYUFBYSwrRUFBK0U7QUFDck0sNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMseUhBQW1CO0FBQzlDLGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQyxnREFBZ0Q7QUFDekcsdUNBQXVDLDRIQUE0SDtBQUNuSywyREFBMkQsaUJBQWlCO0FBQzVFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pELHFDQUFxQztBQUNyQyxtQ0FBbUM7QUFDbkMsYUFBYSxnQ0FBZ0MsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVsbG8tbmVhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbmVhci1qcyt3YWxsZXQtYWNjb3VudEAxLjEuMS9ub2RlX21vZHVsZXMvQG5lYXItanMvd2FsbGV0LWFjY291bnQvbGliL25lYXIuanM/ODZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OZWFyID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBjb250YWlucyB0aGUgbWFpbiBjbGFzcyBkZXZlbG9wZXJzIHdpbGwgdXNlIHRvIGludGVyYWN0IHdpdGggTkVBUi5cbiAqIFRoZSB7QGxpbmsgTmVhcn0gY2xhc3MgaXMgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHtAbGluayBcIkBuZWFyLWpzL2FjY291bnRzXCIuYWNjb3VudC5BY2NvdW50IHwgQWNjb3VudH0gdGhyb3VnaCB0aGUge0BsaW5rIFwiQG5lYXItanMvcHJvdmlkZXJzXCIuanNvbi1ycGMtcHJvdmlkZXIuSnNvblJwY1Byb3ZpZGVyIHwgSnNvblJwY1Byb3ZpZGVyfS5cbiAqIEl0IGlzIGNvbmZpZ3VyZWQgdmlhIHRoZSB7QGxpbmsgTmVhckNvbmZpZ30uXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSNhY2NvdW50XShodHRwczovL2RvY3MubmVhci5vcmcvdG9vbHMvbmVhci1hcGktanMvcXVpY2stcmVmZXJlbmNlI2FjY291bnQpXG4gKlxuICogQG1vZHVsZSBuZWFyXG4gKi9cbmNvbnN0IGFjY291bnRzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvYWNjb3VudHNcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gY2xhc3MgZGV2ZWxvcGVycyBzaG91bGQgdXNlIHRvIGludGVyYWN0IHdpdGggTkVBUi5cbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgbmVhciA9IG5ldyBOZWFyKGNvbmZpZyk7XG4gKiBgYGBcbiAqL1xuY2xhc3MgTmVhciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGFjY291bnRzXzEuQ29ubmVjdGlvbi5mcm9tQ29uZmlnKHtcbiAgICAgICAgICAgIG5ldHdvcmtJZDogY29uZmlnLm5ldHdvcmtJZCxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB7IHR5cGU6ICdKc29uUnBjUHJvdmlkZXInLCBhcmdzOiB7IHVybDogY29uZmlnLm5vZGVVcmwsIGhlYWRlcnM6IGNvbmZpZy5oZWFkZXJzIH0gfSxcbiAgICAgICAgICAgIHNpZ25lcjogY29uZmlnLnNpZ25lciB8fCB7IHR5cGU6ICdJbk1lbW9yeVNpZ25lcicsIGtleVN0b3JlOiBjb25maWcua2V5U3RvcmUgfHwgKChfYSA9IGNvbmZpZy5kZXBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eua2V5U3RvcmUpIH0sXG4gICAgICAgICAgICBqc3ZtQWNjb3VudElkOiBjb25maWcuanN2bUFjY291bnRJZCB8fCBganN2bS4ke2NvbmZpZy5uZXR3b3JrSWR9YFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5tYXN0ZXJBY2NvdW50KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IGJldHRlciB3YXkgb2Ygc3BlY2lmaXlpbmcgaW5pdGlhbCBiYWxhbmNlLlxuICAgICAgICAgICAgLy8gSGFyZGNvZGVkIG51bWJlciBiZWxvdyBtdXN0IGJlIGVub3VnaCB0byBwYXkgdGhlIGdhcyBjb3N0IHRvIGRldi1kZXBsb3kgd2l0aCBuZWFyLXNoZWxsIGZvciBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbEJhbGFuY2UgPSBjb25maWcuaW5pdGlhbEJhbGFuY2UgPyBuZXcgYm5fanNfMS5kZWZhdWx0KGNvbmZpZy5pbml0aWFsQmFsYW5jZSkgOiBuZXcgYm5fanNfMS5kZWZhdWx0KCc1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudENyZWF0b3IgPSBuZXcgYWNjb3VudHNfMS5Mb2NhbEFjY291bnRDcmVhdG9yKG5ldyBhY2NvdW50c18xLkFjY291bnQodGhpcy5jb25uZWN0aW9uLCBjb25maWcubWFzdGVyQWNjb3VudCksIGluaXRpYWxCYWxhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuaGVscGVyVXJsKSB7XG4gICAgICAgICAgICB0aGlzLmFjY291bnRDcmVhdG9yID0gbmV3IGFjY291bnRzXzEuVXJsQWNjb3VudENyZWF0b3IodGhpcy5jb25uZWN0aW9uLCBjb25maWcuaGVscGVyVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3VudENyZWF0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhY2NvdW50SWQgbmVhciBhY2NvdW50SWQgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBuZXR3b3JrLlxuICAgICAqL1xuICAgIGFjY291bnQoYWNjb3VudElkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gbmV3IGFjY291bnRzXzEuQWNjb3VudCh0aGlzLmNvbm5lY3Rpb24sIGFjY291bnRJZCk7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBhY2NvdW50IHVzaW5nIHRoZSB7QGxpbmsgQWNjb3VudENyZWF0b3J9LiBFaXRoZXI6XG4gICAgICogKiB1c2luZyBhIG1hc3RlckFjY291bnQgd2l0aCB7QGxpbmsgTG9jYWxBY2NvdW50Q3JlYXRvcn1cbiAgICAgKiAqIHVzaW5nIHRoZSBoZWxwZXJVcmwgd2l0aCB7QGxpbmsgVXJsQWNjb3VudENyZWF0b3J9XG4gICAgICogQHNlZSB7QGxpbmsgTmVhckNvbmZpZyNtYXN0ZXJBY2NvdW50fSBhbmQge0BsaW5rIE5lYXJDb25maWcjaGVscGVyVXJsfVxuICAgICAqXG4gICAgICogQHBhcmFtIGFjY291bnRJZFxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXlcbiAgICAgKi9cbiAgICBjcmVhdGVBY2NvdW50KGFjY291bnRJZCwgcHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudENyZWF0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhY2NvdW50IGNyZWF0b3IsIGVpdGhlciB2aWEgbWFzdGVyQWNjb3VudCBvciBoZWxwZXJVcmwgY29uZmlndXJhdGlvbiBzZXR0aW5ncy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYWNjb3VudENyZWF0b3IuY3JlYXRlQWNjb3VudChhY2NvdW50SWQsIHB1YmxpY0tleSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGFjY291bnRzXzEuQWNjb3VudCh0aGlzLmNvbm5lY3Rpb24sIGFjY291bnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhciA9IE5lYXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/near.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/wallet_account.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/wallet_account.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectedWalletAccount = exports.WalletConnection = void 0;\n/**\n * This module exposes two classes:\n * * {@link WalletConnection} which redirects users to [NEAR Wallet](https://wallet.near.org/) for key management.\n * * {@link ConnectedWalletAccount} is an {@link \"@near-js/accounts\".account.Account | Account} implementation that uses {@link WalletConnection} to get keys\n *\n * @module walletAccount\n */\nconst accounts_1 = __webpack_require__(/*! @near-js/accounts */ \"(ssr)/./node_modules/.pnpm/@near-js+accounts@1.0.4/node_modules/@near-js/accounts/lib/index.js\");\nconst crypto_1 = __webpack_require__(/*! @near-js/crypto */ \"(ssr)/./node_modules/.pnpm/@near-js+crypto@1.2.1/node_modules/@near-js/crypto/lib/index.js\");\nconst utils_1 = __webpack_require__(/*! @near-js/utils */ \"(ssr)/./node_modules/.pnpm/@near-js+utils@0.1.0/node_modules/@near-js/utils/lib/index.js\");\nconst transactions_1 = __webpack_require__(/*! @near-js/transactions */ \"(ssr)/./node_modules/.pnpm/@near-js+transactions@1.1.2/node_modules/@near-js/transactions/lib/index.js\");\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js\"));\nconst borsh_1 = __webpack_require__(/*! borsh */ \"(ssr)/./node_modules/.pnpm/borsh@1.0.0/node_modules/borsh/lib/cjs/index.js\");\nconst LOGIN_WALLET_URL_SUFFIX = '/login/';\nconst MULTISIG_HAS_METHOD = 'add_request_and_confirm';\nconst LOCAL_STORAGE_KEY_SUFFIX = '_wallet_auth_key';\nconst PENDING_ACCESS_KEY_PREFIX = 'pending_key'; // browser storage key for a pending access key (i.e. key has been generated but we are not sure it was added yet)\n/**\n * This class is not intended for use outside the browser. Without `window` (i.e. in server contexts), it will instantiate but will throw a clear error when used.\n *\n * @see [https://docs.near.org/tools/near-api-js/quick-reference#wallet](https://docs.near.org/tools/near-api-js/quick-reference#wallet)\n * @example\n * ```js\n * // create new WalletConnection instance\n * const wallet = new WalletConnection(near, 'my-app');\n *\n * // If not signed in redirect to the NEAR wallet to sign in\n * // keys will be stored in the BrowserLocalStorageKeyStore\n * if(!wallet.isSignedIn()) return wallet.requestSignIn()\n * ```\n */\nclass WalletConnection {\n    constructor(near, appKeyPrefix) {\n        if (typeof (appKeyPrefix) !== 'string') {\n            throw new Error('Please define a clear appKeyPrefix for this WalletConnection instance as the second argument to the constructor');\n        }\n        if (typeof window === 'undefined') {\n            return new Proxy(this, {\n                get(target, property) {\n                    if (property === 'isSignedIn') {\n                        return () => false;\n                    }\n                    if (property === 'getAccountId') {\n                        return () => '';\n                    }\n                    if (target[property] && typeof target[property] === 'function') {\n                        return () => {\n                            throw new Error('No window found in context, please ensure you are using WalletConnection on the browser');\n                        };\n                    }\n                    return target[property];\n                }\n            });\n        }\n        this._near = near;\n        const authDataKey = appKeyPrefix + LOCAL_STORAGE_KEY_SUFFIX;\n        const authData = JSON.parse(window.localStorage.getItem(authDataKey));\n        this._networkId = near.config.networkId;\n        this._walletBaseUrl = near.config.walletUrl;\n        appKeyPrefix = appKeyPrefix || near.config.contractName || 'default';\n        this._keyStore = near.connection.signer.keyStore;\n        this._authData = authData || { allKeys: [] };\n        this._authDataKey = authDataKey;\n        if (!this.isSignedIn()) {\n            this._completeSignInPromise = this._completeSignInWithAccessKey();\n        }\n    }\n    /**\n     * Returns true, if this WalletConnection is authorized with the wallet.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn();\n     * ```\n     */\n    isSignedIn() {\n        return !!this._authData.accountId;\n    }\n    /**\n     * Returns promise of completing signing in after redirecting from wallet\n     * @example\n     * ```js\n     * // on login callback page\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.isSignedIn(); // false\n     * await wallet.isSignedInAsync(); // true\n     * ```\n     */\n    isSignedInAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this._completeSignInPromise) {\n                return this.isSignedIn();\n            }\n            yield this._completeSignInPromise;\n            return this.isSignedIn();\n        });\n    }\n    /**\n     * Returns authorized Account ID.\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * wallet.getAccountId();\n     * ```\n     */\n    getAccountId() {\n        return this._authData.accountId || '';\n    }\n    /**\n     * Constructs string URL to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // return string URL to the NEAR Wallet\n     * const url = await wallet.requestSignInUrl({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    requestSignInUrl({ contractId, methodNames, successUrl, failureUrl }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const newUrl = new URL(this._walletBaseUrl + LOGIN_WALLET_URL_SUFFIX);\n            newUrl.searchParams.set('success_url', successUrl || currentUrl.href);\n            newUrl.searchParams.set('failure_url', failureUrl || currentUrl.href);\n            if (contractId) {\n                /* Throws exception if contract account does not exist */\n                const contractAccount = yield this._near.account(contractId);\n                yield contractAccount.state();\n                newUrl.searchParams.set('contract_id', contractId);\n                const accessKey = crypto_1.KeyPair.fromRandom('ed25519');\n                newUrl.searchParams.set('public_key', accessKey.getPublicKey().toString());\n                yield this._keyStore.setKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + accessKey.getPublicKey(), accessKey);\n            }\n            if (methodNames) {\n                methodNames.forEach(methodName => {\n                    newUrl.searchParams.append('methodNames', methodName);\n                });\n            }\n            return newUrl.toString();\n        });\n    }\n    /**\n     * Redirects current page to the wallet authentication page.\n     * @param options An optional options object\n     * @param options.contractId The NEAR account where the contract is deployed\n     * @param options.successUrl URL to redirect upon success. Default: current url\n     * @param options.failureUrl URL to redirect upon failure. Default: current url\n     *\n     * @example\n     * ```js\n     * const wallet = new WalletConnection(near, 'my-app');\n     * // redirects to the NEAR Wallet\n     * wallet.requestSignIn({ contractId: 'account-with-deploy-contract.near' });\n     * ```\n     */\n    requestSignIn(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = yield this.requestSignInUrl(options);\n            window.location.assign(url);\n        });\n    }\n    /**\n     * Constructs string URL to the wallet to sign a transaction or batch of transactions.\n     *\n     * @param options A required options object\n     * @param options.transactions List of transactions to sign\n     * @param options.callbackUrl URL to redirect upon success. Default: current url\n     * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param\n     *\n     */\n    requestSignTransactionsUrl({ transactions, meta, callbackUrl }) {\n        const currentUrl = new URL(window.location.href);\n        const newUrl = new URL('sign', this._walletBaseUrl);\n        newUrl.searchParams.set('transactions', transactions\n            .map(transaction => (0, borsh_1.serialize)(transactions_1.SCHEMA.Transaction, transaction))\n            .map(serialized => Buffer.from(serialized).toString('base64'))\n            .join(','));\n        newUrl.searchParams.set('callbackUrl', callbackUrl || currentUrl.href);\n        if (meta)\n            newUrl.searchParams.set('meta', meta);\n        return newUrl.toString();\n    }\n    /**\n     * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the wallet.\n     *\n     * @param options A required options object\n     * @param options.transactions List of transactions to sign\n     * @param options.callbackUrl URL to redirect upon success. Default: current url\n     * @param options.meta Meta information the wallet will send back to the application. `meta` will be attached to the `callbackUrl` as a url search param\n     *\n     */\n    requestSignTransactions(options) {\n        const url = this.requestSignTransactionsUrl(options);\n        window.location.assign(url);\n    }\n    /**\n     * @hidden\n     * Complete sign in for a given account id and public key. To be invoked by the app when getting a callback from the wallet.\n     */\n    _completeSignInWithAccessKey() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const currentUrl = new URL(window.location.href);\n            const publicKey = currentUrl.searchParams.get('public_key') || '';\n            const allKeys = (currentUrl.searchParams.get('all_keys') || '').split(',');\n            const accountId = currentUrl.searchParams.get('account_id') || '';\n            // TODO: Handle errors during login\n            if (accountId) {\n                const authData = {\n                    accountId,\n                    allKeys\n                };\n                window.localStorage.setItem(this._authDataKey, JSON.stringify(authData));\n                if (publicKey) {\n                    yield this._moveKeyFromTempToPermanent(accountId, publicKey);\n                }\n                this._authData = authData;\n            }\n            currentUrl.searchParams.delete('public_key');\n            currentUrl.searchParams.delete('all_keys');\n            currentUrl.searchParams.delete('account_id');\n            currentUrl.searchParams.delete('meta');\n            currentUrl.searchParams.delete('transactionHashes');\n            window.history.replaceState({}, document.title, currentUrl.toString());\n        });\n    }\n    /**\n     * @hidden\n     * @param accountId The NEAR account owning the given public key\n     * @param publicKey The public key being set to the key store\n     */\n    _moveKeyFromTempToPermanent(accountId, publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keyPair = yield this._keyStore.getKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n            yield this._keyStore.setKey(this._networkId, accountId, keyPair);\n            yield this._keyStore.removeKey(this._networkId, PENDING_ACCESS_KEY_PREFIX + publicKey);\n        });\n    }\n    /**\n     * Sign out from the current account\n     * @example\n     * walletConnection.signOut();\n     */\n    signOut() {\n        this._authData = {};\n        window.localStorage.removeItem(this._authDataKey);\n    }\n    /**\n     * Returns the current connected wallet account\n     */\n    account() {\n        if (!this._connectedAccount) {\n            this._connectedAccount = new ConnectedWalletAccount(this, this._near.connection, this._authData.accountId);\n        }\n        return this._connectedAccount;\n    }\n}\nexports.WalletConnection = WalletConnection;\n/**\n * {@link Account} implementation which redirects to wallet using {@link WalletConnection} when no local key is available.\n */\nclass ConnectedWalletAccount extends accounts_1.Account {\n    constructor(walletConnection, connection, accountId) {\n        super(connection, accountId);\n        this.walletConnection = walletConnection;\n    }\n    // Overriding Account methods\n    /**\n     * Sign a transaction by redirecting to the NEAR Wallet\n     * @see {@link WalletConnection#requestSignTransactions}\n     * @param options An optional options object\n     * @param options.receiverId The NEAR account ID of the transaction receiver.\n     * @param options.actions An array of transaction actions to be performed.\n     * @param options.walletMeta Additional metadata to be included in the wallet signing request.\n     * @param options.walletCallbackUrl URL to redirect upon completion of the wallet signing process. Default: current URL.\n     */\n    signAndSendTransaction({ receiverId, actions, walletMeta, walletCallbackUrl = window.location.href }) {\n        const _super = Object.create(null, {\n            signAndSendTransaction: { get: () => super.signAndSendTransaction }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const localKey = yield this.connection.signer.getPublicKey(this.accountId, this.connection.networkId);\n            let accessKey = yield this.accessKeyForTransaction(receiverId, actions, localKey);\n            if (!accessKey) {\n                throw new Error(`Cannot find matching key for transaction sent to ${receiverId}`);\n            }\n            if (localKey && localKey.toString() === accessKey.public_key) {\n                try {\n                    return yield _super.signAndSendTransaction.call(this, { receiverId, actions });\n                }\n                catch (e) {\n                    if (e.type === 'NotEnoughAllowance') {\n                        accessKey = yield this.accessKeyForTransaction(receiverId, actions);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n            const block = yield this.connection.provider.block({ finality: 'final' });\n            const blockHash = (0, utils_1.baseDecode)(block.header.hash);\n            const publicKey = crypto_1.PublicKey.from(accessKey.public_key);\n            // TODO: Cache & listen for nonce updates for given access key\n            const nonce = accessKey.access_key.nonce.add(new bn_js_1.default(1));\n            const transaction = (0, transactions_1.createTransaction)(this.accountId, publicKey, receiverId, nonce, actions, blockHash);\n            yield this.walletConnection.requestSignTransactions({\n                transactions: [transaction],\n                meta: walletMeta,\n                callbackUrl: walletCallbackUrl\n            });\n            return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    reject(new Error('Failed to redirect to sign transaction'));\n                }, 1000);\n            });\n            // TODO: Aggregate multiple transaction request with \"debounce\".\n            // TODO: Introduce TransactionQueue which also can be used to watch for status?\n        });\n    }\n    /**\n     * Check if given access key allows the function call or method attempted in transaction\n     * @param accessKey Array of \\{access_key: AccessKey, public_key: PublicKey\\} items\n     * @param receiverId The NEAR account attempting to have access\n     * @param actions The action(s) needed to be checked for access\n     */\n    accessKeyMatchesTransaction(accessKey, receiverId, actions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { access_key: { permission } } = accessKey;\n            if (permission === 'FullAccess') {\n                return true;\n            }\n            if (permission.FunctionCall) {\n                const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;\n                /********************************\n                Accept multisig access keys and let wallets attempt to signAndSendTransaction\n                If an access key has itself as receiverId and method permission add_request_and_confirm, then it is being used in a wallet with multisig contract: https://github.com/near/core-contracts/blob/671c05f09abecabe7a7e58efe942550a35fc3292/multisig/src/lib.rs#L149-L153\n                ********************************/\n                if (allowedReceiverId === this.accountId && allowedMethods.includes(MULTISIG_HAS_METHOD)) {\n                    return true;\n                }\n                if (allowedReceiverId === receiverId) {\n                    if (actions.length !== 1) {\n                        return false;\n                    }\n                    const [{ functionCall }] = actions;\n                    return functionCall &&\n                        (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?\n                        (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName));\n                    // TODO: Handle cases when allowance doesn't have enough to pay for gas\n                }\n            }\n            // TODO: Support other permissions than FunctionCall\n            return false;\n        });\n    }\n    /**\n     * Helper function returning the access key (if it exists) to the receiver that grants the designated permission\n     * @param receiverId The NEAR account seeking the access key for a transaction\n     * @param actions The action(s) sought to gain access to\n     * @param localKey A local public key provided to check for access\n     */\n    accessKeyForTransaction(receiverId, actions, localKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accessKeys = yield this.getAccessKeys();\n            if (localKey) {\n                const accessKey = accessKeys.find(key => key.public_key.toString() === localKey.toString());\n                if (accessKey && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n                    return accessKey;\n                }\n            }\n            const walletKeys = this.walletConnection._authData.allKeys;\n            for (const accessKey of accessKeys) {\n                if (walletKeys.indexOf(accessKey.public_key) !== -1 && (yield this.accessKeyMatchesTransaction(accessKey, receiverId, actions))) {\n                    return accessKey;\n                }\n            }\n            return null;\n        });\n    }\n}\nexports.ConnectedWalletAccount = ConnectedWalletAccount;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5lYXItanMrd2FsbGV0LWFjY291bnRAMS4xLjEvbm9kZV9tb2R1bGVzL0BuZWFyLWpzL3dhbGxldC1hY2NvdW50L2xpYi93YWxsZXRfYWNjb3VudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyx3QkFBd0I7QUFDekQ7QUFDQTtBQUNBLE1BQU0sd0JBQXdCO0FBQzlCLE1BQU0sOEJBQThCLE9BQU8scURBQXFELDBCQUEwQix3QkFBd0I7QUFDbEo7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMseUhBQW1CO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLG1IQUFpQjtBQUMxQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnSEFBZ0I7QUFDeEMsdUJBQXVCLG1CQUFPLENBQUMscUlBQXVCO0FBQ3RELGdDQUFnQyxtQkFBTyxDQUFDLGtGQUFPO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLHlGQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlEQUFpRDtBQUNwRztBQUNBO0FBQ0EsdUJBQXVCLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFpRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaUNBQWlDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsSUFBSSxlQUFlLGdEQUFnRCx3QkFBd0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyRUFBMkU7QUFDeEc7QUFDQSxzQ0FBc0M7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLFdBQVc7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHFCQUFxQjtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxtQkFBbUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsK0NBQStDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUErRDtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWxsby1uZWFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BuZWFyLWpzK3dhbGxldC1hY2NvdW50QDEuMS4xL25vZGVfbW9kdWxlcy9AbmVhci1qcy93YWxsZXQtYWNjb3VudC9saWIvd2FsbGV0X2FjY291bnQuanM/YjJjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0ZWRXYWxsZXRBY2NvdW50ID0gZXhwb3J0cy5XYWxsZXRDb25uZWN0aW9uID0gdm9pZCAwO1xuLyoqXG4gKiBUaGlzIG1vZHVsZSBleHBvc2VzIHR3byBjbGFzc2VzOlxuICogKiB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbn0gd2hpY2ggcmVkaXJlY3RzIHVzZXJzIHRvIFtORUFSIFdhbGxldF0oaHR0cHM6Ly93YWxsZXQubmVhci5vcmcvKSBmb3Iga2V5IG1hbmFnZW1lbnQuXG4gKiAqIHtAbGluayBDb25uZWN0ZWRXYWxsZXRBY2NvdW50fSBpcyBhbiB7QGxpbmsgXCJAbmVhci1qcy9hY2NvdW50c1wiLmFjY291bnQuQWNjb3VudCB8IEFjY291bnR9IGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbn0gdG8gZ2V0IGtleXNcbiAqXG4gKiBAbW9kdWxlIHdhbGxldEFjY291bnRcbiAqL1xuY29uc3QgYWNjb3VudHNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy9hY2NvdW50c1wiKTtcbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBuZWFyLWpzL2NyeXB0b1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5lYXItanMvdXRpbHNcIik7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IHJlcXVpcmUoXCJAbmVhci1qcy90cmFuc2FjdGlvbnNcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBib3JzaF8xID0gcmVxdWlyZShcImJvcnNoXCIpO1xuY29uc3QgTE9HSU5fV0FMTEVUX1VSTF9TVUZGSVggPSAnL2xvZ2luLyc7XG5jb25zdCBNVUxUSVNJR19IQVNfTUVUSE9EID0gJ2FkZF9yZXF1ZXN0X2FuZF9jb25maXJtJztcbmNvbnN0IExPQ0FMX1NUT1JBR0VfS0VZX1NVRkZJWCA9ICdfd2FsbGV0X2F1dGhfa2V5JztcbmNvbnN0IFBFTkRJTkdfQUNDRVNTX0tFWV9QUkVGSVggPSAncGVuZGluZ19rZXknOyAvLyBicm93c2VyIHN0b3JhZ2Uga2V5IGZvciBhIHBlbmRpbmcgYWNjZXNzIGtleSAoaS5lLiBrZXkgaGFzIGJlZW4gZ2VuZXJhdGVkIGJ1dCB3ZSBhcmUgbm90IHN1cmUgaXQgd2FzIGFkZGVkIHlldClcbi8qKlxuICogVGhpcyBjbGFzcyBpcyBub3QgaW50ZW5kZWQgZm9yIHVzZSBvdXRzaWRlIHRoZSBicm93c2VyLiBXaXRob3V0IGB3aW5kb3dgIChpLmUuIGluIHNlcnZlciBjb250ZXh0cyksIGl0IHdpbGwgaW5zdGFudGlhdGUgYnV0IHdpbGwgdGhyb3cgYSBjbGVhciBlcnJvciB3aGVuIHVzZWQuXG4gKlxuICogQHNlZSBbaHR0cHM6Ly9kb2NzLm5lYXIub3JnL3Rvb2xzL25lYXItYXBpLWpzL3F1aWNrLXJlZmVyZW5jZSN3YWxsZXRdKGh0dHBzOi8vZG9jcy5uZWFyLm9yZy90b29scy9uZWFyLWFwaS1qcy9xdWljay1yZWZlcmVuY2Ujd2FsbGV0KVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiAvLyBjcmVhdGUgbmV3IFdhbGxldENvbm5lY3Rpb24gaW5zdGFuY2VcbiAqIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXRDb25uZWN0aW9uKG5lYXIsICdteS1hcHAnKTtcbiAqXG4gKiAvLyBJZiBub3Qgc2lnbmVkIGluIHJlZGlyZWN0IHRvIHRoZSBORUFSIHdhbGxldCB0byBzaWduIGluXG4gKiAvLyBrZXlzIHdpbGwgYmUgc3RvcmVkIGluIHRoZSBCcm93c2VyTG9jYWxTdG9yYWdlS2V5U3RvcmVcbiAqIGlmKCF3YWxsZXQuaXNTaWduZWRJbigpKSByZXR1cm4gd2FsbGV0LnJlcXVlc3RTaWduSW4oKVxuICogYGBgXG4gKi9cbmNsYXNzIFdhbGxldENvbm5lY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG5lYXIsIGFwcEtleVByZWZpeCkge1xuICAgICAgICBpZiAodHlwZW9mIChhcHBLZXlQcmVmaXgpICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgZGVmaW5lIGEgY2xlYXIgYXBwS2V5UHJlZml4IGZvciB0aGlzIFdhbGxldENvbm5lY3Rpb24gaW5zdGFuY2UgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJveHkodGhpcywge1xuICAgICAgICAgICAgICAgIGdldCh0YXJnZXQsIHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2lzU2lnbmVkSW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnZ2V0QWNjb3VudElkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRbcHJvcGVydHldICYmIHR5cGVvZiB0YXJnZXRbcHJvcGVydHldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gd2luZG93IGZvdW5kIGluIGNvbnRleHQsIHBsZWFzZSBlbnN1cmUgeW91IGFyZSB1c2luZyBXYWxsZXRDb25uZWN0aW9uIG9uIHRoZSBicm93c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX25lYXIgPSBuZWFyO1xuICAgICAgICBjb25zdCBhdXRoRGF0YUtleSA9IGFwcEtleVByZWZpeCArIExPQ0FMX1NUT1JBR0VfS0VZX1NVRkZJWDtcbiAgICAgICAgY29uc3QgYXV0aERhdGEgPSBKU09OLnBhcnNlKHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShhdXRoRGF0YUtleSkpO1xuICAgICAgICB0aGlzLl9uZXR3b3JrSWQgPSBuZWFyLmNvbmZpZy5uZXR3b3JrSWQ7XG4gICAgICAgIHRoaXMuX3dhbGxldEJhc2VVcmwgPSBuZWFyLmNvbmZpZy53YWxsZXRVcmw7XG4gICAgICAgIGFwcEtleVByZWZpeCA9IGFwcEtleVByZWZpeCB8fCBuZWFyLmNvbmZpZy5jb250cmFjdE5hbWUgfHwgJ2RlZmF1bHQnO1xuICAgICAgICB0aGlzLl9rZXlTdG9yZSA9IG5lYXIuY29ubmVjdGlvbi5zaWduZXIua2V5U3RvcmU7XG4gICAgICAgIHRoaXMuX2F1dGhEYXRhID0gYXV0aERhdGEgfHwgeyBhbGxLZXlzOiBbXSB9O1xuICAgICAgICB0aGlzLl9hdXRoRGF0YUtleSA9IGF1dGhEYXRhS2V5O1xuICAgICAgICBpZiAoIXRoaXMuaXNTaWduZWRJbigpKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZVNpZ25JblByb21pc2UgPSB0aGlzLl9jb21wbGV0ZVNpZ25JbldpdGhBY2Nlc3NLZXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUsIGlmIHRoaXMgV2FsbGV0Q29ubmVjdGlvbiBpcyBhdXRob3JpemVkIHdpdGggdGhlIHdhbGxldC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3Qgd2FsbGV0ID0gbmV3IFdhbGxldENvbm5lY3Rpb24obmVhciwgJ215LWFwcCcpO1xuICAgICAqIHdhbGxldC5pc1NpZ25lZEluKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgaXNTaWduZWRJbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYXV0aERhdGEuYWNjb3VudElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHByb21pc2Ugb2YgY29tcGxldGluZyBzaWduaW5nIGluIGFmdGVyIHJlZGlyZWN0aW5nIGZyb20gd2FsbGV0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIG9uIGxvZ2luIGNhbGxiYWNrIHBhZ2VcbiAgICAgKiBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q29ubmVjdGlvbihuZWFyLCAnbXktYXBwJyk7XG4gICAgICogd2FsbGV0LmlzU2lnbmVkSW4oKTsgLy8gZmFsc2VcbiAgICAgKiBhd2FpdCB3YWxsZXQuaXNTaWduZWRJbkFzeW5jKCk7IC8vIHRydWVcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBpc1NpZ25lZEluQXN5bmMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbXBsZXRlU2lnbkluUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU2lnbmVkSW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2NvbXBsZXRlU2lnbkluUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU2lnbmVkSW4oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYXV0aG9yaXplZCBBY2NvdW50IElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0Q29ubmVjdGlvbihuZWFyLCAnbXktYXBwJyk7XG4gICAgICogd2FsbGV0LmdldEFjY291bnRJZCgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldEFjY291bnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dGhEYXRhLmFjY291bnRJZCB8fCAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBzdHJpbmcgVVJMIHRvIHRoZSB3YWxsZXQgYXV0aGVudGljYXRpb24gcGFnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0SWQgVGhlIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdWNjZXNzVXJsIFVSTCB0byByZWRpcmVjdCB1cG9uIHN1Y2Nlc3MuIERlZmF1bHQ6IGN1cnJlbnQgdXJsXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmFpbHVyZVVybCBVUkwgdG8gcmVkaXJlY3QgdXBvbiBmYWlsdXJlLiBEZWZhdWx0OiBjdXJyZW50IHVybFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXRDb25uZWN0aW9uKG5lYXIsICdteS1hcHAnKTtcbiAgICAgKiAvLyByZXR1cm4gc3RyaW5nIFVSTCB0byB0aGUgTkVBUiBXYWxsZXRcbiAgICAgKiBjb25zdCB1cmwgPSBhd2FpdCB3YWxsZXQucmVxdWVzdFNpZ25JblVybCh7IGNvbnRyYWN0SWQ6ICdhY2NvdW50LXdpdGgtZGVwbG95LWNvbnRyYWN0Lm5lYXInIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHJlcXVlc3RTaWduSW5VcmwoeyBjb250cmFjdElkLCBtZXRob2ROYW1lcywgc3VjY2Vzc1VybCwgZmFpbHVyZVVybCB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgICAgICBjb25zdCBuZXdVcmwgPSBuZXcgVVJMKHRoaXMuX3dhbGxldEJhc2VVcmwgKyBMT0dJTl9XQUxMRVRfVVJMX1NVRkZJWCk7XG4gICAgICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLnNldCgnc3VjY2Vzc191cmwnLCBzdWNjZXNzVXJsIHx8IGN1cnJlbnRVcmwuaHJlZik7XG4gICAgICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLnNldCgnZmFpbHVyZV91cmwnLCBmYWlsdXJlVXJsIHx8IGN1cnJlbnRVcmwuaHJlZik7XG4gICAgICAgICAgICBpZiAoY29udHJhY3RJZCkge1xuICAgICAgICAgICAgICAgIC8qIFRocm93cyBleGNlcHRpb24gaWYgY29udHJhY3QgYWNjb3VudCBkb2VzIG5vdCBleGlzdCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0QWNjb3VudCA9IHlpZWxkIHRoaXMuX25lYXIuYWNjb3VudChjb250cmFjdElkKTtcbiAgICAgICAgICAgICAgICB5aWVsZCBjb250cmFjdEFjY291bnQuc3RhdGUoKTtcbiAgICAgICAgICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLnNldCgnY29udHJhY3RfaWQnLCBjb250cmFjdElkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXkgPSBjcnlwdG9fMS5LZXlQYWlyLmZyb21SYW5kb20oJ2VkMjU1MTknKTtcbiAgICAgICAgICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLnNldCgncHVibGljX2tleScsIGFjY2Vzc0tleS5nZXRQdWJsaWNLZXkoKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9rZXlTdG9yZS5zZXRLZXkodGhpcy5fbmV0d29ya0lkLCBQRU5ESU5HX0FDQ0VTU19LRVlfUFJFRklYICsgYWNjZXNzS2V5LmdldFB1YmxpY0tleSgpLCBhY2Nlc3NLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGhvZE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kTmFtZXMuZm9yRWFjaChtZXRob2ROYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ21ldGhvZE5hbWVzJywgbWV0aG9kTmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3VXJsLnRvU3RyaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRpcmVjdHMgY3VycmVudCBwYWdlIHRvIHRoZSB3YWxsZXQgYXV0aGVudGljYXRpb24gcGFnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvbnRyYWN0SWQgVGhlIE5FQVIgYWNjb3VudCB3aGVyZSB0aGUgY29udHJhY3QgaXMgZGVwbG95ZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdWNjZXNzVXJsIFVSTCB0byByZWRpcmVjdCB1cG9uIHN1Y2Nlc3MuIERlZmF1bHQ6IGN1cnJlbnQgdXJsXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmFpbHVyZVVybCBVUkwgdG8gcmVkaXJlY3QgdXBvbiBmYWlsdXJlLiBEZWZhdWx0OiBjdXJyZW50IHVybFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIGNvbnN0IHdhbGxldCA9IG5ldyBXYWxsZXRDb25uZWN0aW9uKG5lYXIsICdteS1hcHAnKTtcbiAgICAgKiAvLyByZWRpcmVjdHMgdG8gdGhlIE5FQVIgV2FsbGV0XG4gICAgICogd2FsbGV0LnJlcXVlc3RTaWduSW4oeyBjb250cmFjdElkOiAnYWNjb3VudC13aXRoLWRlcGxveS1jb250cmFjdC5uZWFyJyB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICByZXF1ZXN0U2lnbkluKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IHlpZWxkIHRoaXMucmVxdWVzdFNpZ25JblVybChvcHRpb25zKTtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgc3RyaW5nIFVSTCB0byB0aGUgd2FsbGV0IHRvIHNpZ24gYSB0cmFuc2FjdGlvbiBvciBiYXRjaCBvZiB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBIHJlcXVpcmVkIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNhY3Rpb25zIExpc3Qgb2YgdHJhbnNhY3Rpb25zIHRvIHNpZ25cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYWxsYmFja1VybCBVUkwgdG8gcmVkaXJlY3QgdXBvbiBzdWNjZXNzLiBEZWZhdWx0OiBjdXJyZW50IHVybFxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGEgTWV0YSBpbmZvcm1hdGlvbiB0aGUgd2FsbGV0IHdpbGwgc2VuZCBiYWNrIHRvIHRoZSBhcHBsaWNhdGlvbi4gYG1ldGFgIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGBjYWxsYmFja1VybGAgYXMgYSB1cmwgc2VhcmNoIHBhcmFtXG4gICAgICpcbiAgICAgKi9cbiAgICByZXF1ZXN0U2lnblRyYW5zYWN0aW9uc1VybCh7IHRyYW5zYWN0aW9ucywgbWV0YSwgY2FsbGJhY2tVcmwgfSkge1xuICAgICAgICBjb25zdCBjdXJyZW50VXJsID0gbmV3IFVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgICAgIGNvbnN0IG5ld1VybCA9IG5ldyBVUkwoJ3NpZ24nLCB0aGlzLl93YWxsZXRCYXNlVXJsKTtcbiAgICAgICAgbmV3VXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3RyYW5zYWN0aW9ucycsIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLm1hcCh0cmFuc2FjdGlvbiA9PiAoMCwgYm9yc2hfMS5zZXJpYWxpemUpKHRyYW5zYWN0aW9uc18xLlNDSEVNQS5UcmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24pKVxuICAgICAgICAgICAgLm1hcChzZXJpYWxpemVkID0+IEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZWQpLnRvU3RyaW5nKCdiYXNlNjQnKSlcbiAgICAgICAgICAgIC5qb2luKCcsJykpO1xuICAgICAgICBuZXdVcmwuc2VhcmNoUGFyYW1zLnNldCgnY2FsbGJhY2tVcmwnLCBjYWxsYmFja1VybCB8fCBjdXJyZW50VXJsLmhyZWYpO1xuICAgICAgICBpZiAobWV0YSlcbiAgICAgICAgICAgIG5ld1VybC5zZWFyY2hQYXJhbXMuc2V0KCdtZXRhJywgbWV0YSk7XG4gICAgICAgIHJldHVybiBuZXdVcmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgdGhlIHVzZXIgdG8gcXVpY2tseSBzaWduIGZvciBhIHRyYW5zYWN0aW9uIG9yIGJhdGNoIG9mIHRyYW5zYWN0aW9ucyBieSByZWRpcmVjdGluZyB0byB0aGUgd2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQSByZXF1aXJlZCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zYWN0aW9ucyBMaXN0IG9mIHRyYW5zYWN0aW9ucyB0byBzaWduXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2FsbGJhY2tVcmwgVVJMIHRvIHJlZGlyZWN0IHVwb24gc3VjY2Vzcy4gRGVmYXVsdDogY3VycmVudCB1cmxcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRhIE1ldGEgaW5mb3JtYXRpb24gdGhlIHdhbGxldCB3aWxsIHNlbmQgYmFjayB0byB0aGUgYXBwbGljYXRpb24uIGBtZXRhYCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBgY2FsbGJhY2tVcmxgIGFzIGEgdXJsIHNlYXJjaCBwYXJhbVxuICAgICAqXG4gICAgICovXG4gICAgcmVxdWVzdFNpZ25UcmFuc2FjdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLnJlcXVlc3RTaWduVHJhbnNhY3Rpb25zVXJsKG9wdGlvbnMpO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKHVybCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBDb21wbGV0ZSBzaWduIGluIGZvciBhIGdpdmVuIGFjY291bnQgaWQgYW5kIHB1YmxpYyBrZXkuIFRvIGJlIGludm9rZWQgYnkgdGhlIGFwcCB3aGVuIGdldHRpbmcgYSBjYWxsYmFjayBmcm9tIHRoZSB3YWxsZXQuXG4gICAgICovXG4gICAgX2NvbXBsZXRlU2lnbkluV2l0aEFjY2Vzc0tleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmdldCgncHVibGljX2tleScpIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgYWxsS2V5cyA9IChjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2FsbF9rZXlzJykgfHwgJycpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50SWQgPSBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2FjY291bnRfaWQnKSB8fCAnJztcbiAgICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSBlcnJvcnMgZHVyaW5nIGxvZ2luXG4gICAgICAgICAgICBpZiAoYWNjb3VudElkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXV0aERhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgICAgICAgICAgICAgYWxsS2V5c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuX2F1dGhEYXRhS2V5LCBKU09OLnN0cmluZ2lmeShhdXRoRGF0YSkpO1xuICAgICAgICAgICAgICAgIGlmIChwdWJsaWNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fbW92ZUtleUZyb21UZW1wVG9QZXJtYW5lbnQoYWNjb3VudElkLCBwdWJsaWNLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRoRGF0YSA9IGF1dGhEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCdwdWJsaWNfa2V5Jyk7XG4gICAgICAgICAgICBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ2FsbF9rZXlzJyk7XG4gICAgICAgICAgICBjdXJyZW50VXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoJ2FjY291bnRfaWQnKTtcbiAgICAgICAgICAgIGN1cnJlbnRVcmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnbWV0YScpO1xuICAgICAgICAgICAgY3VycmVudFVybC5zZWFyY2hQYXJhbXMuZGVsZXRlKCd0cmFuc2FjdGlvbkhhc2hlcycpO1xuICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgY3VycmVudFVybC50b1N0cmluZygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gYWNjb3VudElkIFRoZSBORUFSIGFjY291bnQgb3duaW5nIHRoZSBnaXZlbiBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0tleSBUaGUgcHVibGljIGtleSBiZWluZyBzZXQgdG8gdGhlIGtleSBzdG9yZVxuICAgICAqL1xuICAgIF9tb3ZlS2V5RnJvbVRlbXBUb1Blcm1hbmVudChhY2NvdW50SWQsIHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5UGFpciA9IHlpZWxkIHRoaXMuX2tleVN0b3JlLmdldEtleSh0aGlzLl9uZXR3b3JrSWQsIFBFTkRJTkdfQUNDRVNTX0tFWV9QUkVGSVggKyBwdWJsaWNLZXkpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fa2V5U3RvcmUuc2V0S2V5KHRoaXMuX25ldHdvcmtJZCwgYWNjb3VudElkLCBrZXlQYWlyKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX2tleVN0b3JlLnJlbW92ZUtleSh0aGlzLl9uZXR3b3JrSWQsIFBFTkRJTkdfQUNDRVNTX0tFWV9QUkVGSVggKyBwdWJsaWNLZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiBvdXQgZnJvbSB0aGUgY3VycmVudCBhY2NvdW50XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB3YWxsZXRDb25uZWN0aW9uLnNpZ25PdXQoKTtcbiAgICAgKi9cbiAgICBzaWduT3V0KCkge1xuICAgICAgICB0aGlzLl9hdXRoRGF0YSA9IHt9O1xuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5fYXV0aERhdGFLZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3RlZCB3YWxsZXQgYWNjb3VudFxuICAgICAqL1xuICAgIGFjY291bnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGVkQWNjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGVkQWNjb3VudCA9IG5ldyBDb25uZWN0ZWRXYWxsZXRBY2NvdW50KHRoaXMsIHRoaXMuX25lYXIuY29ubmVjdGlvbiwgdGhpcy5fYXV0aERhdGEuYWNjb3VudElkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGVkQWNjb3VudDtcbiAgICB9XG59XG5leHBvcnRzLldhbGxldENvbm5lY3Rpb24gPSBXYWxsZXRDb25uZWN0aW9uO1xuLyoqXG4gKiB7QGxpbmsgQWNjb3VudH0gaW1wbGVtZW50YXRpb24gd2hpY2ggcmVkaXJlY3RzIHRvIHdhbGxldCB1c2luZyB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbn0gd2hlbiBubyBsb2NhbCBrZXkgaXMgYXZhaWxhYmxlLlxuICovXG5jbGFzcyBDb25uZWN0ZWRXYWxsZXRBY2NvdW50IGV4dGVuZHMgYWNjb3VudHNfMS5BY2NvdW50IHtcbiAgICBjb25zdHJ1Y3Rvcih3YWxsZXRDb25uZWN0aW9uLCBjb25uZWN0aW9uLCBhY2NvdW50SWQpIHtcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgYWNjb3VudElkKTtcbiAgICAgICAgdGhpcy53YWxsZXRDb25uZWN0aW9uID0gd2FsbGV0Q29ubmVjdGlvbjtcbiAgICB9XG4gICAgLy8gT3ZlcnJpZGluZyBBY2NvdW50IG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBTaWduIGEgdHJhbnNhY3Rpb24gYnkgcmVkaXJlY3RpbmcgdG8gdGhlIE5FQVIgV2FsbGV0XG4gICAgICogQHNlZSB7QGxpbmsgV2FsbGV0Q29ubmVjdGlvbiNyZXF1ZXN0U2lnblRyYW5zYWN0aW9uc31cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY2VpdmVySWQgVGhlIE5FQVIgYWNjb3VudCBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gcmVjZWl2ZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWN0aW9ucyBBbiBhcnJheSBvZiB0cmFuc2FjdGlvbiBhY3Rpb25zIHRvIGJlIHBlcmZvcm1lZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53YWxsZXRNZXRhIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gYmUgaW5jbHVkZWQgaW4gdGhlIHdhbGxldCBzaWduaW5nIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMud2FsbGV0Q2FsbGJhY2tVcmwgVVJMIHRvIHJlZGlyZWN0IHVwb24gY29tcGxldGlvbiBvZiB0aGUgd2FsbGV0IHNpZ25pbmcgcHJvY2Vzcy4gRGVmYXVsdDogY3VycmVudCBVUkwuXG4gICAgICovXG4gICAgc2lnbkFuZFNlbmRUcmFuc2FjdGlvbih7IHJlY2VpdmVySWQsIGFjdGlvbnMsIHdhbGxldE1ldGEsIHdhbGxldENhbGxiYWNrVXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYgfSkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IHsgZ2V0OiAoKSA9PiBzdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbEtleSA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5zaWduZXIuZ2V0UHVibGljS2V5KHRoaXMuYWNjb3VudElkLCB0aGlzLmNvbm5lY3Rpb24ubmV0d29ya0lkKTtcbiAgICAgICAgICAgIGxldCBhY2Nlc3NLZXkgPSB5aWVsZCB0aGlzLmFjY2Vzc0tleUZvclRyYW5zYWN0aW9uKHJlY2VpdmVySWQsIGFjdGlvbnMsIGxvY2FsS2V5KTtcbiAgICAgICAgICAgIGlmICghYWNjZXNzS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZmluZCBtYXRjaGluZyBrZXkgZm9yIHRyYW5zYWN0aW9uIHNlbnQgdG8gJHtyZWNlaXZlcklkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxvY2FsS2V5ICYmIGxvY2FsS2V5LnRvU3RyaW5nKCkgPT09IGFjY2Vzc0tleS5wdWJsaWNfa2V5KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIF9zdXBlci5zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmNhbGwodGhpcywgeyByZWNlaXZlcklkLCBhY3Rpb25zIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAnTm90RW5vdWdoQWxsb3dhbmNlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzS2V5ID0geWllbGQgdGhpcy5hY2Nlc3NLZXlGb3JUcmFuc2FjdGlvbihyZWNlaXZlcklkLCBhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5ibG9jayh7IGZpbmFsaXR5OiAnZmluYWwnIH0pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tIYXNoID0gKDAsIHV0aWxzXzEuYmFzZURlY29kZSkoYmxvY2suaGVhZGVyLmhhc2gpO1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gY3J5cHRvXzEuUHVibGljS2V5LmZyb20oYWNjZXNzS2V5LnB1YmxpY19rZXkpO1xuICAgICAgICAgICAgLy8gVE9ETzogQ2FjaGUgJiBsaXN0ZW4gZm9yIG5vbmNlIHVwZGF0ZXMgZm9yIGdpdmVuIGFjY2VzcyBrZXlcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gYWNjZXNzS2V5LmFjY2Vzc19rZXkubm9uY2UuYWRkKG5ldyBibl9qc18xLmRlZmF1bHQoMSkpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAoMCwgdHJhbnNhY3Rpb25zXzEuY3JlYXRlVHJhbnNhY3Rpb24pKHRoaXMuYWNjb3VudElkLCBwdWJsaWNLZXksIHJlY2VpdmVySWQsIG5vbmNlLCBhY3Rpb25zLCBibG9ja0hhc2gpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy53YWxsZXRDb25uZWN0aW9uLnJlcXVlc3RTaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgbWV0YTogd2FsbGV0TWV0YSxcbiAgICAgICAgICAgICAgICBjYWxsYmFja1VybDogd2FsbGV0Q2FsbGJhY2tVcmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHJlZGlyZWN0IHRvIHNpZ24gdHJhbnNhY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFnZ3JlZ2F0ZSBtdWx0aXBsZSB0cmFuc2FjdGlvbiByZXF1ZXN0IHdpdGggXCJkZWJvdW5jZVwiLlxuICAgICAgICAgICAgLy8gVE9ETzogSW50cm9kdWNlIFRyYW5zYWN0aW9uUXVldWUgd2hpY2ggYWxzbyBjYW4gYmUgdXNlZCB0byB3YXRjaCBmb3Igc3RhdHVzP1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZ2l2ZW4gYWNjZXNzIGtleSBhbGxvd3MgdGhlIGZ1bmN0aW9uIGNhbGwgb3IgbWV0aG9kIGF0dGVtcHRlZCBpbiB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSBhY2Nlc3NLZXkgQXJyYXkgb2YgXFx7YWNjZXNzX2tleTogQWNjZXNzS2V5LCBwdWJsaWNfa2V5OiBQdWJsaWNLZXlcXH0gaXRlbXNcbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCBUaGUgTkVBUiBhY2NvdW50IGF0dGVtcHRpbmcgdG8gaGF2ZSBhY2Nlc3NcbiAgICAgKiBAcGFyYW0gYWN0aW9ucyBUaGUgYWN0aW9uKHMpIG5lZWRlZCB0byBiZSBjaGVja2VkIGZvciBhY2Nlc3NcbiAgICAgKi9cbiAgICBhY2Nlc3NLZXlNYXRjaGVzVHJhbnNhY3Rpb24oYWNjZXNzS2V5LCByZWNlaXZlcklkLCBhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFjY2Vzc19rZXk6IHsgcGVybWlzc2lvbiB9IH0gPSBhY2Nlc3NLZXk7XG4gICAgICAgICAgICBpZiAocGVybWlzc2lvbiA9PT0gJ0Z1bGxBY2Nlc3MnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGVybWlzc2lvbi5GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHJlY2VpdmVyX2lkOiBhbGxvd2VkUmVjZWl2ZXJJZCwgbWV0aG9kX25hbWVzOiBhbGxvd2VkTWV0aG9kcyB9ID0gcGVybWlzc2lvbi5GdW5jdGlvbkNhbGw7XG4gICAgICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAgICAgQWNjZXB0IG11bHRpc2lnIGFjY2VzcyBrZXlzIGFuZCBsZXQgd2FsbGV0cyBhdHRlbXB0IHRvIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBJZiBhbiBhY2Nlc3Mga2V5IGhhcyBpdHNlbGYgYXMgcmVjZWl2ZXJJZCBhbmQgbWV0aG9kIHBlcm1pc3Npb24gYWRkX3JlcXVlc3RfYW5kX2NvbmZpcm0sIHRoZW4gaXQgaXMgYmVpbmcgdXNlZCBpbiBhIHdhbGxldCB3aXRoIG11bHRpc2lnIGNvbnRyYWN0OiBodHRwczovL2dpdGh1Yi5jb20vbmVhci9jb3JlLWNvbnRyYWN0cy9ibG9iLzY3MWMwNWYwOWFiZWNhYmU3YTdlNThlZmU5NDI1NTBhMzVmYzMyOTIvbXVsdGlzaWcvc3JjL2xpYi5ycyNMMTQ5LUwxNTNcbiAgICAgICAgICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dlZFJlY2VpdmVySWQgPT09IHRoaXMuYWNjb3VudElkICYmIGFsbG93ZWRNZXRob2RzLmluY2x1ZGVzKE1VTFRJU0lHX0hBU19NRVRIT0QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dlZFJlY2VpdmVySWQgPT09IHJlY2VpdmVySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3sgZnVuY3Rpb25DYWxsIH1dID0gYWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2FsbCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFmdW5jdGlvbkNhbGwuZGVwb3NpdCB8fCBmdW5jdGlvbkNhbGwuZGVwb3NpdC50b1N0cmluZygpID09PSAnMCcpICYmIC8vIFRPRE86IFNob3VsZCBzdXBwb3J0IGNoYXJnaW5nIGFtb3VudCBzbWFsbGVyIHRoYW4gYWxsb3dhbmNlP1xuICAgICAgICAgICAgICAgICAgICAgICAgKGFsbG93ZWRNZXRob2RzLmxlbmd0aCA9PT0gMCB8fCBhbGxvd2VkTWV0aG9kcy5pbmNsdWRlcyhmdW5jdGlvbkNhbGwubWV0aG9kTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgY2FzZXMgd2hlbiBhbGxvd2FuY2UgZG9lc24ndCBoYXZlIGVub3VnaCB0byBwYXkgZm9yIGdhc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IFN1cHBvcnQgb3RoZXIgcGVybWlzc2lvbnMgdGhhbiBGdW5jdGlvbkNhbGxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGFjY2VzcyBrZXkgKGlmIGl0IGV4aXN0cykgdG8gdGhlIHJlY2VpdmVyIHRoYXQgZ3JhbnRzIHRoZSBkZXNpZ25hdGVkIHBlcm1pc3Npb25cbiAgICAgKiBAcGFyYW0gcmVjZWl2ZXJJZCBUaGUgTkVBUiBhY2NvdW50IHNlZWtpbmcgdGhlIGFjY2VzcyBrZXkgZm9yIGEgdHJhbnNhY3Rpb25cbiAgICAgKiBAcGFyYW0gYWN0aW9ucyBUaGUgYWN0aW9uKHMpIHNvdWdodCB0byBnYWluIGFjY2VzcyB0b1xuICAgICAqIEBwYXJhbSBsb2NhbEtleSBBIGxvY2FsIHB1YmxpYyBrZXkgcHJvdmlkZWQgdG8gY2hlY2sgZm9yIGFjY2Vzc1xuICAgICAqL1xuICAgIGFjY2Vzc0tleUZvclRyYW5zYWN0aW9uKHJlY2VpdmVySWQsIGFjdGlvbnMsIGxvY2FsS2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXlzID0geWllbGQgdGhpcy5nZXRBY2Nlc3NLZXlzKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2Nlc3NLZXkgPSBhY2Nlc3NLZXlzLmZpbmQoa2V5ID0+IGtleS5wdWJsaWNfa2V5LnRvU3RyaW5nKCkgPT09IGxvY2FsS2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIGlmIChhY2Nlc3NLZXkgJiYgKHlpZWxkIHRoaXMuYWNjZXNzS2V5TWF0Y2hlc1RyYW5zYWN0aW9uKGFjY2Vzc0tleSwgcmVjZWl2ZXJJZCwgYWN0aW9ucykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FsbGV0S2V5cyA9IHRoaXMud2FsbGV0Q29ubmVjdGlvbi5fYXV0aERhdGEuYWxsS2V5cztcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWNjZXNzS2V5IG9mIGFjY2Vzc0tleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAod2FsbGV0S2V5cy5pbmRleE9mKGFjY2Vzc0tleS5wdWJsaWNfa2V5KSAhPT0gLTEgJiYgKHlpZWxkIHRoaXMuYWNjZXNzS2V5TWF0Y2hlc1RyYW5zYWN0aW9uKGFjY2Vzc0tleSwgcmVjZWl2ZXJJZCwgYWN0aW9ucykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2Nlc3NLZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdGVkV2FsbGV0QWNjb3VudCA9IENvbm5lY3RlZFdhbGxldEFjY291bnQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@near-js+wallet-account@1.1.1/node_modules/@near-js/wallet-account/lib/wallet_account.js\n");

/***/ })

};
;